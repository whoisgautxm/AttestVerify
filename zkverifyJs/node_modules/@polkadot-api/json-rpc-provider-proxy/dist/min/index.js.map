{"version":3,"sources":["../../src/index.ts","../../src/subscription-manager/chainHeadFollow.ts","../../src/subscription-manager/transaction-submit-watch.ts","../../src/subscription-manager/subscription-manager.ts","../../src/get-sync-provider.ts"],"sourcesContent":["export * from \"./get-sync-provider\"\n","import { SubscriptionId, SubscriptionLogic } from \"@/internal-types\"\n\nconst [START_METHODS, STOP_METHODS, NOTIFICATION_METHODS] = [\n  \"follow\",\n  \"unfollow\",\n  \"followEvent\",\n].map(\n  (name) =>\n    new Set(\n      [\"v1\", \"unstable\"].map((version) => `chainHead_${version}_${name}`),\n    ),\n)\nconst STOP_EVENT = \"stop\"\n\nexport const chainHeadFollow = (\n  onMessage: (msg: string) => void,\n): SubscriptionLogic => {\n  let notificationMethod = \"\"\n  return {\n    onSent(parsed) {\n      if (START_METHODS.has(parsed.method)) {\n        notificationMethod = parsed.method + \"Event\"\n        return {\n          type: \"subscribe\",\n          id: parsed.id,\n          onRes: (innerParsed) =>\n            innerParsed.id === parsed.id ? { id: innerParsed.result } : null,\n        }\n      }\n\n      if (STOP_METHODS.has(parsed.method))\n        return {\n          type: \"unsubscribe\",\n          id: Object.values(parsed.params)[0] as string,\n        }\n\n      return null\n    },\n    onNotification(parsed) {\n      if (!NOTIFICATION_METHODS.has(parsed.method)) return null\n\n      return parsed.params.result.event === STOP_EVENT\n        ? {\n            type: \"end\",\n            id: parsed.params.subscription as SubscriptionId,\n          }\n        : null\n    },\n    onAbort: (id) => {\n      onMessage(\n        JSON.stringify({\n          jsonrpc: \"2.0\",\n          method: notificationMethod,\n          params: {\n            subscription: id,\n            result: {\n              event: STOP_EVENT,\n            },\n          },\n        }),\n      )\n    },\n  }\n}\n","import { SubscriptionId, SubscriptionLogic } from \"@/internal-types\"\n\nconst versions = [\"v1\", \"unstable\"] as const\nconst groupNames = [\"transactionWatch\", \"transaction\"] as const\nconst groupNameVersionPermutations = versions\n  .map((v) => groupNames.map((g) => [v, g] as const))\n  .flat()\n\nconst [START_METHODS, STOP_METHODS] = [\"submitAndWatch\", \"unwatch\"].map(\n  (name) =>\n    new Set(\n      groupNameVersionPermutations.map(\n        ([version, groupName]) => `${groupName}_${version}_${name}`,\n      ),\n    ),\n)\nconst ABORT_EVENT = \"dropped\"\n\nconst terminalEvents = new Set([ABORT_EVENT, \"finalized\", \"error\", \"invalid\"])\n\nexport const txSubmitAndWatch = (\n  onMessage: (msg: string) => void,\n): SubscriptionLogic => {\n  let notificationMethod = \"\"\n  return {\n    onSent(parsed) {\n      if (START_METHODS.has(parsed.method)) {\n        if (!notificationMethod) {\n          const [groupName, version] = (parsed.method as string).split(\"_\")\n          notificationMethod = [groupName, version, \"watchEvent\"].join(\"_\")\n        }\n        return {\n          type: \"subscribe\",\n          id: parsed.id,\n          onRes: (innerParsed) =>\n            innerParsed.id === parsed.id ? { id: innerParsed.result } : null,\n        }\n      }\n\n      if (STOP_METHODS.has(parsed.method))\n        return {\n          type: \"unsubscribe\",\n          id: Object.values(parsed.params)[0] as string,\n        }\n\n      return null\n    },\n    onNotification(parsed) {\n      if (notificationMethod !== parsed.method) return null\n\n      return terminalEvents.has(parsed.params.result.event)\n        ? {\n            type: \"end\",\n            id: parsed.params.subscription as SubscriptionId,\n          }\n        : null\n    },\n    onAbort: (id) => {\n      onMessage(\n        JSON.stringify({\n          jsonrpc: \"2.0\",\n          method: notificationMethod,\n          params: {\n            subscription: id,\n            result: {\n              event: ABORT_EVENT,\n            },\n          },\n        }),\n      )\n    },\n  }\n}\n","import type {\n  RequestId,\n  SubscriptionId,\n  SubscriptionLogic,\n} from \"../internal-types\"\nimport { chainHeadFollow } from \"./chainHeadFollow\"\nimport { txSubmitAndWatch } from \"./transaction-submit-watch\"\n\nexport const addSubscription = ({\n  onSent,\n  onNotification,\n  onAbort,\n}: SubscriptionLogic) => {\n  const preActive = new Map<\n    RequestId,\n    (parsed: any) => { id: SubscriptionId } | null\n  >()\n  const active = new Set<SubscriptionId>()\n\n  const onDisconnect = () => {\n    preActive.clear()\n    active.clear()\n  }\n\n  return {\n    onSent(parsed: any) {\n      const result = onSent(parsed)\n      if (!result) return\n      if (result.type === \"subscribe\") {\n        preActive.set(result.id, result.onRes)\n      } else {\n        active.delete(result.id)\n      }\n    },\n    onResponse(parsed: any) {\n      const match = preActive.get(parsed.id)?.(parsed)\n      if (!match) return\n      preActive.delete(parsed.id)\n      active.add(match.id)\n    },\n    onNotifiaction(parsed: any) {\n      const result = onNotification(parsed)\n      if (!result) return\n      active.delete(result.id)\n    },\n    onDisconnect,\n    onAbort() {\n      const activeCopy = [...active]\n      onDisconnect()\n      activeCopy.forEach(onAbort)\n    },\n  }\n}\n\nexport const getSubscriptionManager = (onMessage: (msg: string) => void) => {\n  const subscriptions = [chainHeadFollow, txSubmitAndWatch].map((logic) =>\n    addSubscription(logic(onMessage)),\n  )\n\n  return {\n    onSent(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onSent(parsed)\n      })\n    },\n    onResponse(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onResponse(parsed)\n      })\n    },\n    onNotifiaction(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onNotifiaction(parsed)\n      })\n    },\n    onDisconnect() {\n      subscriptions.forEach((s) => s.onDisconnect())\n    },\n    onAbort() {\n      subscriptions.forEach((s) => s.onAbort())\n    },\n  }\n}\n","import type { RequestId } from \"./internal-types\"\nimport type {\n  JsonRpcProvider,\n  JsonRpcConnection,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { getSubscriptionManager } from \"./subscription-manager\"\n\nexport type AsyncJsonRpcProvider = (\n  onMessage: (message: string) => void,\n  onHalt: () => void,\n) => JsonRpcConnection\n\nexport const getSyncProvider =\n  (input: () => Promise<AsyncJsonRpcProvider>): JsonRpcProvider =>\n  (onMessage) => {\n    // if it's null it means that the consumer has called `disconnect`\n    // of it's a Promise it means that it's being respolved, otherwise it's resolved\n    let provider: JsonRpcConnection | Promise<JsonRpcConnection> | null\n\n    let bufferedMessages: Array<string> = []\n    const pendingResponses = new Set<RequestId>()\n    const subscriptionManager = getSubscriptionManager(onMessage)\n\n    const onMessageProxy = (message: string) => {\n      let parsed: any\n      try {\n        parsed = JSON.parse(message)\n      } catch (_) {\n        console.error(`Unable to parse incoming message: ${message}`)\n        return\n      }\n\n      if (parsed.id !== undefined) {\n        pendingResponses.delete(parsed.id)\n        subscriptionManager.onResponse(parsed)\n      } else {\n        subscriptionManager.onNotifiaction(parsed)\n      }\n\n      onMessage(message)\n    }\n\n    const send = (message: string) => {\n      if (!provider) return\n\n      const parsed = JSON.parse(message)\n      subscriptionManager.onSent(parsed)\n      if (parsed.id) pendingResponses.add(parsed.id)\n\n      if (provider instanceof Promise) {\n        bufferedMessages.push(message)\n      } else provider.send(message)\n    }\n\n    const onHalt = (): Promise<JsonRpcConnection> => {\n      bufferedMessages = []\n      const pendingResponsesCopy = [...pendingResponses]\n      pendingResponses.clear()\n\n      // it means that the user has disconnected while the\n      // provider promise was being rejected. Therefore, we must\n      // throw to prevent the Promise from recovering.\n      // The rejection will be handled from the teardown logic.\n      if (!provider) throw null\n\n      // It needs to restart before sending the errored\n      // responses/notifications because the consumer may\n      // react to those by sending new requests\n      const result = start()\n\n      subscriptionManager.onAbort()\n      pendingResponsesCopy.forEach((id) => {\n        onMessage(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            error: { code: -32603, message: \"Internal error\" },\n            id,\n          }),\n        )\n      })\n\n      return result\n    }\n\n    const start = (): Promise<JsonRpcConnection> => {\n      const onResolve = (getProvider: AsyncJsonRpcProvider) => {\n        let halted = false\n        const _onHalt = () => {\n          if (halted) return\n          halted = true\n          onHalt()\n        }\n        const _onMessageProxy = (msg: string) => {\n          if (halted) return\n          onMessageProxy(msg)\n        }\n\n        const result = getProvider(_onMessageProxy, _onHalt)\n        bufferedMessages.forEach((m) => {\n          result.send(m)\n        })\n        bufferedMessages = []\n        return (provider = result)\n      }\n\n      provider = input().then(onResolve, withMacroTask(onHalt))\n      return provider\n    }\n\n    const disconnect = () => {\n      if (!provider) return\n\n      const finishIt = (input: JsonRpcConnection | null) => {\n        subscriptionManager.onDisconnect()\n        pendingResponses.clear()\n        provider = null\n        input?.disconnect()\n      }\n\n      if (provider instanceof Promise) {\n        provider.then(finishIt, finishIt)\n        provider = null\n      } else finishIt(provider)\n    }\n\n    start()\n    return {\n      send,\n      disconnect,\n    }\n  }\n\nconst withMacroTask =\n  <Args extends Array<any>, T>(\n    inputFn: (...args: Args) => Promise<T>,\n  ): ((...args: Args) => Promise<T>) =>\n  (...args) =>\n    new Promise((res) => setTimeout(res, 0)).then(() => inputFn(...args))\n"],"mappings":"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","names":["src_exports","__export","getSyncProvider","__toCommonJS","START_METHODS","STOP_METHODS","NOTIFICATION_METHODS","name","version","STOP_EVENT","chainHeadFollow","onMessage","notificationMethod","parsed","innerParsed","id","versions","groupNames","groupNameVersionPermutations","v","g","START_METHODS","STOP_METHODS","name","version","groupName","ABORT_EVENT","terminalEvents","txSubmitAndWatch","onMessage","notificationMethod","parsed","innerParsed","id","addSubscription","onSent","onNotification","onAbort","preActive","active","onDisconnect","parsed","result","match","activeCopy","getSubscriptionManager","onMessage","subscriptions","chainHeadFollow","txSubmitAndWatch","logic","s","getSyncProvider","input","onMessage","provider","bufferedMessages","pendingResponses","subscriptionManager","getSubscriptionManager","onMessageProxy","message","parsed","send","onHalt","pendingResponsesCopy","result","start","id","onResolve","getProvider","halted","msg","m","withMacroTask","disconnect","finishIt","inputFn","args","res"]}