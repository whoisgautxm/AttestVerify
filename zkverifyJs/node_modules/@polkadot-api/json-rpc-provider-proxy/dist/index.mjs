// src/subscription-manager/chainHeadFollow.ts
var [START_METHODS, STOP_METHODS, NOTIFICATION_METHODS] = [
  "follow",
  "unfollow",
  "followEvent"
].map(
  (name) => new Set(
    ["v1", "unstable"].map((version) => `chainHead_${version}_${name}`)
  )
);
var STOP_EVENT = "stop";
var chainHeadFollow = (onMessage) => {
  let notificationMethod = "";
  return {
    onSent(parsed) {
      if (START_METHODS.has(parsed.method)) {
        notificationMethod = parsed.method + "Event";
        return {
          type: "subscribe",
          id: parsed.id,
          onRes: (innerParsed) => innerParsed.id === parsed.id ? { id: innerParsed.result } : null
        };
      }
      if (STOP_METHODS.has(parsed.method))
        return {
          type: "unsubscribe",
          id: Object.values(parsed.params)[0]
        };
      return null;
    },
    onNotification(parsed) {
      if (!NOTIFICATION_METHODS.has(parsed.method))
        return null;
      return parsed.params.result.event === STOP_EVENT ? {
        type: "end",
        id: parsed.params.subscription
      } : null;
    },
    onAbort: (id) => {
      onMessage(
        JSON.stringify({
          jsonrpc: "2.0",
          method: notificationMethod,
          params: {
            subscription: id,
            result: {
              event: STOP_EVENT
            }
          }
        })
      );
    }
  };
};

// src/subscription-manager/transaction-submit-watch.ts
var versions = ["v1", "unstable"];
var groupNames = ["transactionWatch", "transaction"];
var groupNameVersionPermutations = versions.map((v) => groupNames.map((g) => [v, g])).flat();
var [START_METHODS2, STOP_METHODS2] = ["submitAndWatch", "unwatch"].map(
  (name) => new Set(
    groupNameVersionPermutations.map(
      ([version, groupName]) => `${groupName}_${version}_${name}`
    )
  )
);
var ABORT_EVENT = "dropped";
var terminalEvents = /* @__PURE__ */ new Set([ABORT_EVENT, "finalized", "error", "invalid"]);
var txSubmitAndWatch = (onMessage) => {
  let notificationMethod = "";
  return {
    onSent(parsed) {
      if (START_METHODS2.has(parsed.method)) {
        if (!notificationMethod) {
          const [groupName, version] = parsed.method.split("_");
          notificationMethod = [groupName, version, "watchEvent"].join("_");
        }
        return {
          type: "subscribe",
          id: parsed.id,
          onRes: (innerParsed) => innerParsed.id === parsed.id ? { id: innerParsed.result } : null
        };
      }
      if (STOP_METHODS2.has(parsed.method))
        return {
          type: "unsubscribe",
          id: Object.values(parsed.params)[0]
        };
      return null;
    },
    onNotification(parsed) {
      if (notificationMethod !== parsed.method)
        return null;
      return terminalEvents.has(parsed.params.result.event) ? {
        type: "end",
        id: parsed.params.subscription
      } : null;
    },
    onAbort: (id) => {
      onMessage(
        JSON.stringify({
          jsonrpc: "2.0",
          method: notificationMethod,
          params: {
            subscription: id,
            result: {
              event: ABORT_EVENT
            }
          }
        })
      );
    }
  };
};

// src/subscription-manager/subscription-manager.ts
var addSubscription = ({
  onSent,
  onNotification,
  onAbort
}) => {
  const preActive = /* @__PURE__ */ new Map();
  const active = /* @__PURE__ */ new Set();
  const onDisconnect = () => {
    preActive.clear();
    active.clear();
  };
  return {
    onSent(parsed) {
      const result = onSent(parsed);
      if (!result)
        return;
      if (result.type === "subscribe") {
        preActive.set(result.id, result.onRes);
      } else {
        active.delete(result.id);
      }
    },
    onResponse(parsed) {
      const match = preActive.get(parsed.id)?.(parsed);
      if (!match)
        return;
      preActive.delete(parsed.id);
      active.add(match.id);
    },
    onNotifiaction(parsed) {
      const result = onNotification(parsed);
      if (!result)
        return;
      active.delete(result.id);
    },
    onDisconnect,
    onAbort() {
      const activeCopy = [...active];
      onDisconnect();
      activeCopy.forEach(onAbort);
    }
  };
};
var getSubscriptionManager = (onMessage) => {
  const subscriptions = [chainHeadFollow, txSubmitAndWatch].map(
    (logic) => addSubscription(logic(onMessage))
  );
  return {
    onSent(parsed) {
      subscriptions.forEach((s) => {
        s.onSent(parsed);
      });
    },
    onResponse(parsed) {
      subscriptions.forEach((s) => {
        s.onResponse(parsed);
      });
    },
    onNotifiaction(parsed) {
      subscriptions.forEach((s) => {
        s.onNotifiaction(parsed);
      });
    },
    onDisconnect() {
      subscriptions.forEach((s) => s.onDisconnect());
    },
    onAbort() {
      subscriptions.forEach((s) => s.onAbort());
    }
  };
};

// src/get-sync-provider.ts
var getSyncProvider = (input) => (onMessage) => {
  let provider;
  let bufferedMessages = [];
  const pendingResponses = /* @__PURE__ */ new Set();
  const subscriptionManager = getSubscriptionManager(onMessage);
  const onMessageProxy = (message) => {
    let parsed;
    try {
      parsed = JSON.parse(message);
    } catch (_) {
      console.error(`Unable to parse incoming message: ${message}`);
      return;
    }
    if (parsed.id !== void 0) {
      pendingResponses.delete(parsed.id);
      subscriptionManager.onResponse(parsed);
    } else {
      subscriptionManager.onNotifiaction(parsed);
    }
    onMessage(message);
  };
  const send = (message) => {
    if (!provider)
      return;
    const parsed = JSON.parse(message);
    subscriptionManager.onSent(parsed);
    if (parsed.id)
      pendingResponses.add(parsed.id);
    if (provider instanceof Promise) {
      bufferedMessages.push(message);
    } else
      provider.send(message);
  };
  const onHalt = () => {
    bufferedMessages = [];
    const pendingResponsesCopy = [...pendingResponses];
    pendingResponses.clear();
    if (!provider)
      throw null;
    const result = start();
    subscriptionManager.onAbort();
    pendingResponsesCopy.forEach((id) => {
      onMessage(
        JSON.stringify({
          jsonrpc: "2.0",
          error: { code: -32603, message: "Internal error" },
          id
        })
      );
    });
    return result;
  };
  const start = () => {
    const onResolve = (getProvider) => {
      let halted = false;
      const _onHalt = () => {
        if (halted)
          return;
        halted = true;
        onHalt();
      };
      const _onMessageProxy = (msg) => {
        if (halted)
          return;
        onMessageProxy(msg);
      };
      const result = getProvider(_onMessageProxy, _onHalt);
      bufferedMessages.forEach((m) => {
        result.send(m);
      });
      bufferedMessages = [];
      return provider = result;
    };
    provider = input().then(onResolve, withMacroTask(onHalt));
    return provider;
  };
  const disconnect = () => {
    if (!provider)
      return;
    const finishIt = (input2) => {
      subscriptionManager.onDisconnect();
      pendingResponses.clear();
      provider = null;
      input2?.disconnect();
    };
    if (provider instanceof Promise) {
      provider.then(finishIt, finishIt);
      provider = null;
    } else
      finishIt(provider);
  };
  start();
  return {
    send,
    disconnect
  };
};
var withMacroTask = (inputFn) => (...args) => new Promise((res) => setTimeout(res, 0)).then(() => inputFn(...args));
export {
  getSyncProvider
};
//# sourceMappingURL=index.mjs.map