{"version":3,"sources":["../src/index.ts","../src/subscription-manager/chainHeadFollow.ts","../src/subscription-manager/transaction-submit-watch.ts","../src/subscription-manager/subscription-manager.ts","../src/get-sync-provider.ts"],"sourcesContent":["export * from \"./get-sync-provider\"\n","import { SubscriptionId, SubscriptionLogic } from \"@/internal-types\"\n\nconst [START_METHODS, STOP_METHODS, NOTIFICATION_METHODS] = [\n  \"follow\",\n  \"unfollow\",\n  \"followEvent\",\n].map(\n  (name) =>\n    new Set(\n      [\"v1\", \"unstable\"].map((version) => `chainHead_${version}_${name}`),\n    ),\n)\nconst STOP_EVENT = \"stop\"\n\nexport const chainHeadFollow = (\n  onMessage: (msg: string) => void,\n): SubscriptionLogic => {\n  let notificationMethod = \"\"\n  return {\n    onSent(parsed) {\n      if (START_METHODS.has(parsed.method)) {\n        notificationMethod = parsed.method + \"Event\"\n        return {\n          type: \"subscribe\",\n          id: parsed.id,\n          onRes: (innerParsed) =>\n            innerParsed.id === parsed.id ? { id: innerParsed.result } : null,\n        }\n      }\n\n      if (STOP_METHODS.has(parsed.method))\n        return {\n          type: \"unsubscribe\",\n          id: Object.values(parsed.params)[0] as string,\n        }\n\n      return null\n    },\n    onNotification(parsed) {\n      if (!NOTIFICATION_METHODS.has(parsed.method)) return null\n\n      return parsed.params.result.event === STOP_EVENT\n        ? {\n            type: \"end\",\n            id: parsed.params.subscription as SubscriptionId,\n          }\n        : null\n    },\n    onAbort: (id) => {\n      onMessage(\n        JSON.stringify({\n          jsonrpc: \"2.0\",\n          method: notificationMethod,\n          params: {\n            subscription: id,\n            result: {\n              event: STOP_EVENT,\n            },\n          },\n        }),\n      )\n    },\n  }\n}\n","import { SubscriptionId, SubscriptionLogic } from \"@/internal-types\"\n\nconst versions = [\"v1\", \"unstable\"] as const\nconst groupNames = [\"transactionWatch\", \"transaction\"] as const\nconst groupNameVersionPermutations = versions\n  .map((v) => groupNames.map((g) => [v, g] as const))\n  .flat()\n\nconst [START_METHODS, STOP_METHODS] = [\"submitAndWatch\", \"unwatch\"].map(\n  (name) =>\n    new Set(\n      groupNameVersionPermutations.map(\n        ([version, groupName]) => `${groupName}_${version}_${name}`,\n      ),\n    ),\n)\nconst ABORT_EVENT = \"dropped\"\n\nconst terminalEvents = new Set([ABORT_EVENT, \"finalized\", \"error\", \"invalid\"])\n\nexport const txSubmitAndWatch = (\n  onMessage: (msg: string) => void,\n): SubscriptionLogic => {\n  let notificationMethod = \"\"\n  return {\n    onSent(parsed) {\n      if (START_METHODS.has(parsed.method)) {\n        if (!notificationMethod) {\n          const [groupName, version] = (parsed.method as string).split(\"_\")\n          notificationMethod = [groupName, version, \"watchEvent\"].join(\"_\")\n        }\n        return {\n          type: \"subscribe\",\n          id: parsed.id,\n          onRes: (innerParsed) =>\n            innerParsed.id === parsed.id ? { id: innerParsed.result } : null,\n        }\n      }\n\n      if (STOP_METHODS.has(parsed.method))\n        return {\n          type: \"unsubscribe\",\n          id: Object.values(parsed.params)[0] as string,\n        }\n\n      return null\n    },\n    onNotification(parsed) {\n      if (notificationMethod !== parsed.method) return null\n\n      return terminalEvents.has(parsed.params.result.event)\n        ? {\n            type: \"end\",\n            id: parsed.params.subscription as SubscriptionId,\n          }\n        : null\n    },\n    onAbort: (id) => {\n      onMessage(\n        JSON.stringify({\n          jsonrpc: \"2.0\",\n          method: notificationMethod,\n          params: {\n            subscription: id,\n            result: {\n              event: ABORT_EVENT,\n            },\n          },\n        }),\n      )\n    },\n  }\n}\n","import type {\n  RequestId,\n  SubscriptionId,\n  SubscriptionLogic,\n} from \"../internal-types\"\nimport { chainHeadFollow } from \"./chainHeadFollow\"\nimport { txSubmitAndWatch } from \"./transaction-submit-watch\"\n\nexport const addSubscription = ({\n  onSent,\n  onNotification,\n  onAbort,\n}: SubscriptionLogic) => {\n  const preActive = new Map<\n    RequestId,\n    (parsed: any) => { id: SubscriptionId } | null\n  >()\n  const active = new Set<SubscriptionId>()\n\n  const onDisconnect = () => {\n    preActive.clear()\n    active.clear()\n  }\n\n  return {\n    onSent(parsed: any) {\n      const result = onSent(parsed)\n      if (!result) return\n      if (result.type === \"subscribe\") {\n        preActive.set(result.id, result.onRes)\n      } else {\n        active.delete(result.id)\n      }\n    },\n    onResponse(parsed: any) {\n      const match = preActive.get(parsed.id)?.(parsed)\n      if (!match) return\n      preActive.delete(parsed.id)\n      active.add(match.id)\n    },\n    onNotifiaction(parsed: any) {\n      const result = onNotification(parsed)\n      if (!result) return\n      active.delete(result.id)\n    },\n    onDisconnect,\n    onAbort() {\n      const activeCopy = [...active]\n      onDisconnect()\n      activeCopy.forEach(onAbort)\n    },\n  }\n}\n\nexport const getSubscriptionManager = (onMessage: (msg: string) => void) => {\n  const subscriptions = [chainHeadFollow, txSubmitAndWatch].map((logic) =>\n    addSubscription(logic(onMessage)),\n  )\n\n  return {\n    onSent(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onSent(parsed)\n      })\n    },\n    onResponse(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onResponse(parsed)\n      })\n    },\n    onNotifiaction(parsed: any) {\n      subscriptions.forEach((s) => {\n        s.onNotifiaction(parsed)\n      })\n    },\n    onDisconnect() {\n      subscriptions.forEach((s) => s.onDisconnect())\n    },\n    onAbort() {\n      subscriptions.forEach((s) => s.onAbort())\n    },\n  }\n}\n","import type { RequestId } from \"./internal-types\"\nimport type {\n  JsonRpcProvider,\n  JsonRpcConnection,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { getSubscriptionManager } from \"./subscription-manager\"\n\nexport type AsyncJsonRpcProvider = (\n  onMessage: (message: string) => void,\n  onHalt: () => void,\n) => JsonRpcConnection\n\nexport const getSyncProvider =\n  (input: () => Promise<AsyncJsonRpcProvider>): JsonRpcProvider =>\n  (onMessage) => {\n    // if it's null it means that the consumer has called `disconnect`\n    // of it's a Promise it means that it's being respolved, otherwise it's resolved\n    let provider: JsonRpcConnection | Promise<JsonRpcConnection> | null\n\n    let bufferedMessages: Array<string> = []\n    const pendingResponses = new Set<RequestId>()\n    const subscriptionManager = getSubscriptionManager(onMessage)\n\n    const onMessageProxy = (message: string) => {\n      let parsed: any\n      try {\n        parsed = JSON.parse(message)\n      } catch (_) {\n        console.error(`Unable to parse incoming message: ${message}`)\n        return\n      }\n\n      if (parsed.id !== undefined) {\n        pendingResponses.delete(parsed.id)\n        subscriptionManager.onResponse(parsed)\n      } else {\n        subscriptionManager.onNotifiaction(parsed)\n      }\n\n      onMessage(message)\n    }\n\n    const send = (message: string) => {\n      if (!provider) return\n\n      const parsed = JSON.parse(message)\n      subscriptionManager.onSent(parsed)\n      if (parsed.id) pendingResponses.add(parsed.id)\n\n      if (provider instanceof Promise) {\n        bufferedMessages.push(message)\n      } else provider.send(message)\n    }\n\n    const onHalt = (): Promise<JsonRpcConnection> => {\n      bufferedMessages = []\n      const pendingResponsesCopy = [...pendingResponses]\n      pendingResponses.clear()\n\n      // it means that the user has disconnected while the\n      // provider promise was being rejected. Therefore, we must\n      // throw to prevent the Promise from recovering.\n      // The rejection will be handled from the teardown logic.\n      if (!provider) throw null\n\n      // It needs to restart before sending the errored\n      // responses/notifications because the consumer may\n      // react to those by sending new requests\n      const result = start()\n\n      subscriptionManager.onAbort()\n      pendingResponsesCopy.forEach((id) => {\n        onMessage(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            error: { code: -32603, message: \"Internal error\" },\n            id,\n          }),\n        )\n      })\n\n      return result\n    }\n\n    const start = (): Promise<JsonRpcConnection> => {\n      const onResolve = (getProvider: AsyncJsonRpcProvider) => {\n        let halted = false\n        const _onHalt = () => {\n          if (halted) return\n          halted = true\n          onHalt()\n        }\n        const _onMessageProxy = (msg: string) => {\n          if (halted) return\n          onMessageProxy(msg)\n        }\n\n        const result = getProvider(_onMessageProxy, _onHalt)\n        bufferedMessages.forEach((m) => {\n          result.send(m)\n        })\n        bufferedMessages = []\n        return (provider = result)\n      }\n\n      provider = input().then(onResolve, withMacroTask(onHalt))\n      return provider\n    }\n\n    const disconnect = () => {\n      if (!provider) return\n\n      const finishIt = (input: JsonRpcConnection | null) => {\n        subscriptionManager.onDisconnect()\n        pendingResponses.clear()\n        provider = null\n        input?.disconnect()\n      }\n\n      if (provider instanceof Promise) {\n        provider.then(finishIt, finishIt)\n        provider = null\n      } else finishIt(provider)\n    }\n\n    start()\n    return {\n      send,\n      disconnect,\n    }\n  }\n\nconst withMacroTask =\n  <Args extends Array<any>, T>(\n    inputFn: (...args: Args) => Promise<T>,\n  ): ((...args: Args) => Promise<T>) =>\n  (...args) =>\n    new Promise((res) => setTimeout(res, 0)).then(() => inputFn(...args))\n"],"mappings":"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","names":["START_METHODS","STOP_METHODS","input"]}