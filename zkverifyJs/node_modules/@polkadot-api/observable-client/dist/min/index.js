"use strict";var K=Object.defineProperty;var Xe=Object.getOwnPropertyDescriptor;var Ye=Object.getOwnPropertyNames;var et=Object.prototype.hasOwnProperty;var tt=(n,e,r)=>e in n?K(n,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):n[e]=r;var rt=(n,e)=>{for(var r in e)K(n,r,{get:e[r],enumerable:!0})},nt=(n,e,r,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of Ye(e))!et.call(n,i)&&i!==r&&K(n,i,{get:()=>e[i],enumerable:!(s=Xe(e,i))||s.enumerable});return n};var st=n=>nt(K({},"__esModule",{value:!0}),n);var re=(n,e,r)=>tt(n,typeof e!="symbol"?e+"":e,r);var ht={};rt(ht,{BlockNotPinnedError:()=>C,BlockPrunedError:()=>N,NotBestBlockError:()=>U,getObservableClient:()=>ft});module.exports=st(ht);var q=require("rxjs"),H=(0,q.share)({connector:()=>new q.ReplaySubject(1),resetOnError:!0,resetOnComplete:!0,resetOnRefCountZero:!0});var Q=require("rxjs"),he=(n,e=1/0)=>r=>new Q.Observable(s=>{let i,p=new Map,u=new Map,t=new Map,l=0,g=0,d=0,h=()=>{let o=p.get(g);if(!o){u.size===0&&(typeof i>"u"||i.closed)&&s.complete();return}let c=g++;p.delete(c),d!==c&&t.set(c,[]),u.set(c,o.subscribe({next(y){d===c?s.next(y):t.get(c).push(y)},complete(){if(u.delete(c),c===d)for(d++;t.has(d)&&(t.get(d).forEach(y=>s.next(y)),t.delete(d),!u.has(d));)d++;h()},error(y){s.error(y)}}))};return i=r.subscribe({next(o){let c=l++;p.set(c,(0,Q.defer)(()=>n(o,c))),u.size<e&&h()},error(o){s.error(o)},complete(){u.size===0&&s.complete()}}),()=>{u.forEach(o=>o.unsubscribe()),i.unsubscribe(),p.clear(),t.clear()}});var ve=require("rxjs"),ye=n=>e=>new ve.Observable(r=>{let s=!1,i=e.subscribe({next(p){s=!0,r.next(p)},error(p){r.error(p)},complete(){r.complete()}});return s||r.next(n),i});var He=require("@polkadot-api/substrate-bindings"),Me=require("@polkadot-api/substrate-client"),m=require("rxjs");var ke=require("@polkadot-api/substrate-client"),xe=require("rxjs");var Z=class{constructor(){re(this,"first");re(this,"last")}getRemoveFn(e){return()=>{e.prev?e.prev.next=e.next:this.first=e.next,e.next?e.next.prev=e.prev:this.last=e.prev,delete e.prev,delete e.next}}push(e){let r={value:e};return this.last===void 0?this.last=this.first=r:(this.last.next=r,r.prev=this.last,this.last=r),this.getRemoveFn(r)}unshift(e){return this.first={value:e,next:this.first},this.first.next&&(this.first.next.prev=this.first),this.last||(this.last=this.first),this.getRemoveFn(this.first)}pop(){let e=this.first?.value;return this.first&&(this.first=this.first.next,this.first?(delete this.first.prev?.next,delete this.first.prev):this.last=void 0),e}isEmpty(){return!this.first}},ne=()=>{let n=new Map,e=(o,c)=>{n.set(o,()=>{n.delete(o),c()})},r=o=>{n.get(o)?.()},s=new Z,i=s.unshift.bind(s),p=s.push.bind(s),u=(o,c)=>{let y=c?i:p;e(o.source$,y(o))},t=()=>{let o=s.pop();o&&(n.delete(o.source$),l(o))},l=o=>{let{source$:c,observer:y}=o,T=!1,x=c.subscribe({next(F){y.next(F)},error(F){(T=F instanceof ke.OperationLimitError)?u(o,!0):y.error(F)},complete(){y.complete()}});x.closed?T||t():e(c,()=>{x.unsubscribe(),t()})},g=(o=!1)=>c=>new xe.Observable(y=>{let T={observer:y,source$:c};return s.isEmpty()?l(T):u(T,o),()=>{r(c)}}),d=g();return{withRecovery:g,withRecoveryFn:o=>(...c)=>d(o(...c))}};var W=require("rxjs"),se=(n,e)=>r=>(s,...i)=>(s===null||s==="finalized"?n:s==="best"?e:(0,W.of)(s)).pipe((0,W.take)(1),(0,W.mergeMap)(u=>r(u,...i)));var we=require("rxjs"),G=n=>(...e)=>new we.Observable(r=>{let s=new AbortController;return n(...e,s.signal).then(i=>{r.next(i),r.complete()},i=>{r.error(i)}),()=>{r.unsubscribe(),s.abort(),s=void 0}});var oe=n=>e=>(...r)=>n()[e](...r);var R=require("rxjs");var C=class extends Error{constructor(){super("Block is not pinned"),this.name="BlockNotPinnedError"}},N=class extends Error{constructor(){super("Block pruned"),this.name="BlockPrunedError"}},U=class extends Error{constructor(){super("Block is not best block or finalized"),this.name="NotBestBlockError"}};var Oe=require("@polkadot-api/substrate-client"),P=require("rxjs"),Te=n=>{let e=null,r=P.noop,s=new P.Observable(i=>{e=n(!0,p=>{i.next(p)},p=>{e=null,i.error(p)}),r=()=>{i.complete(),e?.unfollow()}}).pipe((0,P.share)());return{getFollower:()=>{if(!e)throw new Error("Missing chainHead subscription");return e},unfollow:()=>{r()},follow$:s}},J=()=>n=>new P.Observable(e=>{let r=new P.Subscription,s=()=>n.subscribe({next:i=>e.next(i),error:i=>{i instanceof Oe.StopError?(e.next({type:"stop-error"}),r.add(s())):e.error(i)},complete:()=>e.complete()});return r.add(s()),r});var _=require("@polkadot-api/metadata-builders"),k=require("@polkadot-api/substrate-bindings"),Be=require("@polkadot-api/utils"),O=require("rxjs");var ot=(0,Be.toHex)(k.u32.enc(15)),it=(0,k.Tuple)(k.compact,(0,k.Bytes)()),at=(0,k.Option)((0,k.Bytes)()),lt=(0,k.Vector)(k.u32).dec,Re=(n,e)=>{let r=s=>{let i=(l,g,d)=>n(l,g,d).pipe((0,O.catchError)(h=>{if(h instanceof C)return e.pipe((0,O.take)(1),(0,O.switchMap)(o=>i(o,g,d)));throw h})),p=i(s,"Metadata_metadata_versions","").pipe((0,O.map)(lt)),u=i(s,"Metadata_metadata","").pipe((0,O.map)(l=>{let[,g]=it.dec(l);return{metadata:k.metadata.dec(g).metadata.value,metadataRaw:g}})),t=i(s,"Metadata_metadata_at_version",ot).pipe((0,O.map)(l=>{let g=at.dec(l);return{metadata:k.metadata.dec(g).metadata.value,metadataRaw:g}}));return p.pipe((0,O.catchError)(()=>(0,O.of)([14])),(0,O.mergeMap)(l=>l.includes(15)?t:u))};return s=>{let i=new Set([s]),p=r(s).pipe((0,O.map)(({metadata:t,metadataRaw:l})=>{let g=(0,_.getChecksumBuilder)(t),d=(0,_.getDynamicBuilder)(t),h=d.buildStorage("System","Events"),o=t.extrinsic.signedExtensions.find(T=>T.identifier==="ChargeAssetTxPayment"),c=null;if(o){let T=(0,_.getLookupFn)(t.lookup)(o.type);if(T.type==="struct"){let x=T.value.asset_id;x.type==="option"&&(c=x.value.id)}}return{asset:c===null?[k._void.enc,null]:[d.buildDefinition(c).enc,g.buildDefinition(c)],metadataRaw:l,metadata:t,checksumBuilder:g,dynamicBuilder:d,events:{key:h.enc(),dec:h.dec},accountId:(0,k.AccountId)(d.ss58Prefix)}}),(0,O.shareReplay)(1)),u={at:s,runtime:p,addBlock:t=>(i.add(t),u),deleteBlocks:t=>(t.forEach(l=>{i.delete(l)}),i.size),usages:i};return p.subscribe(),u}};var A=require("rxjs");var ze=(n,e)=>{n.get(n.get(e).parent)?.children.delete(e),n.delete(e)},ct=(n,e)=>{let r=[...e],s=n.blocks.get(n.blocks.get(n.finalized).parent),i=[];for(;s;)i.push(s.hash),s.refCount===0&&!s.unpinned&&(r.push(s.hash),s.unpinned=!0),s=n.blocks.get(s.parent);let p=[...e];for(let u=i.length-1;u>=0;u--){if(s=n.blocks.get(i[u]),!s.unpinned)return r;p.push(s.hash)}return p.forEach(u=>{ze(n.blocks,u)}),Object.entries(n.runtimes).map(([u,t])=>({key:u,usages:t.deleteBlocks(p)})).filter(u=>u.usages===0).map(u=>u.key).forEach(u=>{delete n.runtimes[u]}),r},Ae=(n,e,r,s,i)=>{let p=(0,A.merge)(s,n.pipe(ut(e),J())).pipe((0,A.scan)((t,l)=>{switch(l.type){case"initialized":t.recovering&&(l.finalizedBlockHashes.some(c=>t.blocks.has(c))||(t=Se()));let[g]=l.finalizedBlockHashes.slice(-1);t.finalized=t.best=g;let d=l.finalizedBlockHashes.length-1;l.finalizedBlockHashes.forEach((o,c)=>{t.blocks.has(o)?t.blocks.get(o).recovering=!1:t.blocks.set(o,{hash:o,parent:c===0?l.parentHash:l.finalizedBlockHashes[c-1],children:new Set(c===d?[]:[l.finalizedBlockHashes[c+1]]),runtime:o,refCount:0,number:l.number+c,recovering:!1})});let h=Object.values(t.runtimes).find(o=>o.usages.has(g));return t.finalizedRuntime=h??(t.runtimes[g]=u(g)),t;case"stop-error":for(let o of t.blocks.values())o.recovering=!0;return t.recovering=!0,t;case"newBlock":{let{parentBlockHash:o,blockHash:c}=l;if(t.blocks.has(c))t.blocks.get(c).recovering=!1;else{let y=t.blocks.get(o);y.children.add(c),l.newRuntime&&(t.runtimes[c]=u(c),t.runtimes[c].runtime.subscribe());let T={hash:c,number:y.number+1,parent:o,children:new Set,runtime:l.newRuntime?c:y.runtime,refCount:0,recovering:!1};t.blocks.set(c,T),t.runtimes[T.runtime].addBlock(c)}return t}case"bestBlockChanged":{if(t.recovering){for(let[o,c]of t.blocks)c.recovering&&ze(t.blocks,o);t.recovering=!1}return t.best=l.bestBlockHash,t}case"finalized":{t.finalized=l.finalizedBlockHashes.slice(-1)[0],t.finalizedRuntime=t.runtimes[t.blocks.get(t.finalized).runtime];let o=[...new Set(l.prunedBlockHashes)];return i(ct(t,o)),t}case"blockUsage":{if(!t.blocks.has(l.value.hash))return t;let o=t.blocks.get(l.value.hash);return o.refCount+=l.value.type==="hold"?1:-1,o.refCount===0&&o.number<t.blocks.get(t.finalized).number&&!o.recovering&&(o.unpinned=!0,i([o.hash])),t}}},Se()),(0,A.filter)(t=>!!t.finalizedRuntime.runtime),(0,A.map)(t=>({...t})),H),u=Re(M(p,r),p.pipe((0,A.map)(t=>t.finalized)));return p},Se=()=>({best:"",finalized:"",runtimes:{},blocks:new Map,finalizedRuntime:{},recovering:!1}),ut=n=>e=>e.pipe((0,A.concatMap)(r=>r.type!=="initialized"?(0,A.of)(r):n(r.finalizedBlockHashes[0]).then(s=>({...r,number:s.number,parentHash:s.parentHash}))));var E=require("rxjs"),$e=(n,e)=>n.pipe((0,E.takeWhile)(r=>r.blocks.has(e)),(0,E.distinctUntilChanged)((r,s)=>r.finalized===s.finalized&&r.best===s.best),(0,E.filter)(r=>r.blocks.get(r.best).number>=r.blocks.get(e).number),(0,E.map)(r=>{let{number:s}=r.blocks.get(e),i=r.blocks.get(r.best),p=r.finalized===i.hash;for(;i.number>s;)i=r.blocks.get(i.parent),p=p||r.finalized===i.hash;return p?"finalized":i.hash===e?"best":null}),(0,E.distinctUntilChanged)(),(0,E.takeWhile)(r=>r!=="finalized",!0));function ie(n,e,r){return(s,i,...p)=>(i?(0,R.pipe)(bt(s,e.pipe(J(),(0,R.filter)(t=>t.type==="finalized"),(0,R.mergeMap)(t=>t.prunedBlockHashes))),pt(s,n)):t=>t)(r(s,...p))}var pt=(n,e)=>r=>$e(e,n).pipe((0,R.take)(1),(0,R.switchMap)(s=>s?r:(0,R.throwError)(()=>new U))),bt=(n,e)=>r=>new R.Observable(s=>{let i=e.pipe((0,R.filter)(u=>u===n)).subscribe(()=>{s.error(new N)}),p=r.subscribe(s);return()=>{i.unsubscribe(),p.unsubscribe()}});var Ce=require("rxjs");function M(n,e){return(r,...s)=>{let i=e(r,...s);return new Ce.Observable(p=>{let u=null,t=!1,l=()=>{t||(t=!0,u=i.subscribe({next:h=>p.next(h),error:h=>p.error(h),complete:()=>p.complete()}),u.add(()=>{t=!1,u=null}))},g=!1,d=n.subscribe({next:h=>{let o=h.blocks.get(r);o?o.recovering?u?.unsubscribe():l():g&&p.error(new C),g=h.recovering},error:h=>p.error(h)});return()=>{d.unsubscribe(),u?.unsubscribe()}})}}var Ee=require("@polkadot-api/substrate-client"),I=require("rxjs"),mt=n=>{let e=n.pipe((0,I.catchError)(r=>r instanceof Ee.OperationInaccessibleError?(0,I.timer)(750).pipe((0,I.concatMap)(()=>e)):(0,I.throwError)(()=>r)));return e},X=n=>(...e)=>mt(n(...e));var Y=require("rxjs"),Pe=(n,e)=>{let r=(s,i,p,u)=>new Y.Observable(t=>n().storageSubscription(s,i,p??null,l=>{t.next(l)},l=>{t.error(l)},()=>{t.complete()},l=>{l!==0&&t.next(r(s,i.slice(-l),p,!0))})).pipe((0,Y.mergeAll)(),e(u));return r};var w=require("rxjs"),ae=(n,e,r,s)=>{let i=t=>(0,w.takeUntil)(n.pipe((0,w.filter)(({blocks:l})=>!l.has(t)))),p=(t,l,g)=>{if(g)return(0,w.of)({hash:t,found:{type:!1,isValid:!0}});let d=i(t);return e(t).pipe((0,w.mergeMap)(h=>{let o=h.indexOf(l);return o>-1?d(s(t)).pipe((0,w.map)(c=>({hash:t,found:{type:!0,index:o,events:c}}))):r(t,l).pipe((0,w.map)(c=>({hash:t,found:{type:!1,isValid:c}})))}),d)},u=(t,l,g)=>p(t,l,g.has(t)).pipe((0,w.mergeMap)(d=>{let{found:h}=d;return h.type||!h.isValid?(0,w.of)(d):n.pipe(i(t),(0,w.mergeMap)(o=>o.blocks.get(t).children),(0,w.distinct)(),(0,w.mergeMap)(o=>u(o,l,g)))}));return t=>n.pipe((0,w.take)(1),(0,w.mergeMap)(l=>u(l.finalized,t,new Set(l.blocks.keys()))))};var Ie=require("rxjs"),V=require("@polkadot-api/utils"),dt=new Uint8Array([2]),gt=(n,e)=>(0,V.toHex)((0,V.mergeUint8)(dt,(0,V.fromHex)(n),(0,V.fromHex)(e))),Fe=n=>(e,r)=>n(e,"TaggedTransactionQueue_validate_transaction",gt(r,e)).pipe((0,Ie.map)(s=>s.startsWith("0x00")));var le=({hash:n,number:e,parent:r})=>({hash:n,number:e,parent:r}),Ve=n=>{let{getFollower:e,unfollow:r,follow$:s}=Te(n),i=oe(e),{withRecovery:p,withRecoveryFn:u}=ne(),t=new m.Subject,l=a=>(b,...f)=>new m.Observable(v=>{t.next({type:"blockUsage",value:{type:"hold",hash:b}});let z=a(b,...f).subscribe(v);return()=>{setTimeout(()=>{t.next({type:"blockUsage",value:{type:"release",hash:b}})},0),z.unsubscribe()}}),g=a=>(b,...f)=>new m.Observable(v=>{let z=!1;return x.pipe((0,m.take)(1)).subscribe($=>{let B=$.blocks.get(b);z=!!B&&!B.unpinned}),z?a(b,...f).subscribe(v):v.error(new C)}),d=a=>e().header(a).then(He.blockHeader.dec),h=a=>e().unpin(a).catch(b=>{if(!(b instanceof Me.DisjointError))throw b}),o=a=>g(l((f=>ie(x,s,f))(M(x,X(u(G(a))))))),c=(a,b=!0)=>(f,...v)=>a(f,b,...v),y=X(u(G(i("call")))),T=new Map,x=Ae(s,d,l(y),t,a=>{h(a),a.forEach(b=>{T.delete(b)})}),F=l(a=>x.pipe((0,m.take)(1),(0,m.mergeMap)(b=>b.runtimes[b.blocks.get(a).runtime].runtime))),Ue=a=>b=>b.pipe(he(f=>F(a(f)).pipe((0,m.map)(v=>[f,v])))),D=(a,b,f)=>{let v=T.get(a)??new Map,z=v.get(b);if(z)return z;T.set(a,v);let $=new m.ReplaySubject,B=f.pipe((0,m.share)({connector:()=>$}),(0,m.tap)({complete(){v.set(b,$)}}));return v.set(b,B),B},ce=x.pipe((0,m.distinctUntilChanged)((a,b)=>a.finalized===b.finalized),(0,m.map)(a=>le(a.blocks.get(a.finalized))),H),ue=x.pipe((0,m.distinctUntilChanged)((a,b)=>a.best===b.best),(0,m.map)(a=>le(a.blocks.get(a.best))),H),pe=x.pipe((0,m.distinctUntilChanged)((a,b)=>a.finalized===b.finalized&&a.best===b.best),(0,m.scan)((a,b)=>{let f=S=>a.get(S)||le(b.blocks.get(S)),v=f(b.best),z=f(b.finalized),$=v.number-z.number+1,B=new Array($);for(let S=0,j=v.hash;S<$;S++)B[S]=f(j),j=B[S].parent;return new Map(B.map(S=>[S.hash,S]))},new Map),(0,m.map)(a=>[...a.values()]),H),ee=x.pipe((0,m.distinctUntilChanged)((a,b)=>a.finalizedRuntime===b.finalizedRuntime),(0,m.switchMap)(({finalizedRuntime:{runtime:a}})=>a.pipe(ye(null))),H),_e=ee.pipe((0,m.map)(a=>a?.metadata??null)),L=se(ce.pipe((0,m.map)(a=>a.hash)),ue.pipe((0,m.map)(a=>a.hash))),be=o(i("body")),De=a=>D(a,"body",be(a,!0)),Le=o(i("storage")),me=L((a,b,f,v,z=null,$)=>x.pipe((0,m.take)(1),(0,m.mergeMap)(B=>B.runtimes[B.blocks.get(a).runtime].runtime),(0,m.mergeMap)(B=>{let S=v(B),j=D(a,`storage-${f}-${S}-${z??""}`,Le(a,b,f,S,z));return $?D(a,`storage-${f}-${S}-${z??""}-dec`,j.pipe((0,m.map)(Je=>$(Je,B)))):j}))),je=Pe(e,p),Ke=X(L(l(M(x,(a,b,f)=>je(a,b,f??null,!1))))),qe=L(l(M(x,a=>(0,m.defer)(()=>d(a)))));(0,m.merge)(ee,pe).subscribe();let de=(a,b=!1)=>me(a,b,"value",f=>f.events.key,null,(f,v)=>v.events.dec(f)),Qe=o(i("call")),ge=L((a,b,f,v)=>D(a,`call-${f}-${v}`,Qe(a,b,f,v))),te=Fe(c(ge,!1)),fe=a=>D(a,"body",be(a,!1)),Ze=ae(x,fe,te,de),Ge=ae(x,fe,te,()=>(0,m.of)());return{follow$:s,finalized$:ce,best$:ue,bestBlocks$:pe,runtime$:ee,metadata$:_e,header$:qe,body$:De,call$:c(ge),storage$:c(me),storageQueries$:Ke,eventsAt$:c(de),trackTx$:Ze,trackTxWithoutEvents$:Ge,validateTx$:te,pinnedBlocks$:x,withRuntime:Ue,getRuntimeContext$:L(F),unfollow:r}};var We=require("rxjs"),Ne=n=>e=>new We.Observable(r=>n(e,s=>{r.error(s)}));var ft=({chainHead:n,transaction:e,destroy:r})=>({chainHead$:()=>Ve(n),broadcastTx$:Ne(e),destroy:r});
//# sourceMappingURL=index.js.map