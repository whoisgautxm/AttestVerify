{"version":3,"sources":["../../src/index.ts","../../src/utils/shareLatest.ts","../../src/utils/concatMapEager.ts","../../src/utils/with-default-value.ts","../../src/chainHead/chainHead.ts","../../src/chainHead/enhancers/operationLimitRecovery.ts","../../src/chainHead/enhancers/optionalHash.ts","../../src/chainHead/enhancers/fromAbortControllerFn.ts","../../src/chainHead/enhancers/lazyFollower.ts","../../src/chainHead/enhancers/whileBestBlock.ts","../../src/chainHead/errors.ts","../../src/chainHead/streams/follow.ts","../../src/chainHead/streams/get-runtime-creator.ts","../../src/chainHead/streams/pinned-blocks.ts","../../src/chainHead/streams/block-operations.ts","../../src/chainHead/enhancers/withStopRecovery.ts","../../src/chainHead/enhancers/operationInaccessibleRecovery.ts","../../src/chainHead/storage-queries.ts","../../src/chainHead/track-tx.ts","../../src/chainHead/validate-tx.ts","../../src/tx.ts","../../src/getObservableClient.ts"],"sourcesContent":["export * from \"./getObservableClient\"\nexport {\n  BlockNotPinnedError,\n  BlockPrunedError,\n  NotBestBlockError,\n  AnalyzedBlock,\n  PinnedBlock,\n} from \"./chainHead\"\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let topSubscription: Subscription\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (\n            innerSubscriptions.size === 0 &&\n            (typeof topSubscription === \"undefined\" || topSubscription.closed)\n          ) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n        innerSubscriptions.set(\n          idx,\n          inner$.subscribe({\n            next(x: O) {\n              if (observerIdx === idx) {\n                observer.next(x)\n              } else {\n                results.get(idx)!.push(x)\n              }\n            },\n            complete() {\n              innerSubscriptions.delete(idx)\n              if (idx === observerIdx) {\n                observerIdx++\n                while (results.has(observerIdx)) {\n                  results.get(observerIdx)!.forEach((x) => observer.next(x))\n                  results.delete(observerIdx)\n                  if (innerSubscriptions.has(observerIdx)) {\n                    break\n                  }\n                  observerIdx++\n                }\n              }\n              nextSubscription()\n            },\n            error(e: any) {\n              observer.error(e)\n            },\n          }),\n        )\n      }\n\n      topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nexport const withDefaultValue =\n  <V, T>(defaultValue: V) =>\n  (source$: Observable<T>): Observable<V | T> =>\n    new Observable((observer) => {\n      let hasEmited = false\n\n      const subscription = source$.subscribe({\n        next(v) {\n          hasEmited = true\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      if (!hasEmited) observer.next(defaultValue)\n\n      return subscription\n    })\n","import { concatMapEager, shareLatest } from \"@/utils\"\nimport { blockHeader } from \"@polkadot-api/substrate-bindings\"\nimport {\n  ChainHead,\n  DisjointError,\n  FollowEventWithRuntime,\n  StorageItemInput,\n  StorageResult,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  ReplaySubject,\n  Subject,\n  defer,\n  distinctUntilChanged,\n  map,\n  merge,\n  mergeMap,\n  of,\n  scan,\n  share,\n  switchMap,\n  take,\n  tap,\n} from \"rxjs\"\n\nimport { withDefaultValue } from \"@/utils\"\nimport {\n  fromAbortControllerFn,\n  getWithOptionalhash$,\n  getWithRecovery,\n  withEnsureCanonicalChain,\n  withLazyFollower,\n  withOperationInaccessibleRecovery,\n  withStopRecovery,\n} from \"./enhancers\"\nimport { BlockNotPinnedError } from \"./errors\"\nimport { getRecoveralStorage$ } from \"./storage-queries\"\nimport type {\n  BlockUsageEvent,\n  PinnedBlocks,\n  PinnedBlock,\n  RuntimeContext,\n  SystemEvent,\n} from \"./streams\"\nimport { getFollow$, getPinnedBlocks$ } from \"./streams\"\nimport { getTrackTx } from \"./track-tx\"\nimport { getValidateTx } from \"./validate-tx\"\n\nexport type {\n  PinnedBlocks,\n  PinnedBlock,\n  FollowEventWithRuntime,\n  RuntimeContext,\n  SystemEvent,\n}\n\nexport type BlockInfo = {\n  hash: string\n  number: number\n  parent: string\n}\n\nconst toBlockInfo = ({ hash, number, parent }: PinnedBlock): BlockInfo => ({\n  hash,\n  number,\n  parent,\n})\n\nexport const getChainHead$ = (chainHead: ChainHead) => {\n  const { getFollower, unfollow, follow$ } = getFollow$(chainHead)\n  const lazyFollower = withLazyFollower(getFollower)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n\n  const blockUsage$ = new Subject<BlockUsageEvent>()\n  const withRefcount =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        blockUsage$.next({ type: \"blockUsage\", value: { type: \"hold\", hash } })\n        const subscription = fn(hash, ...args).subscribe(observer)\n        return () => {\n          setTimeout(() => {\n            blockUsage$.next({\n              type: \"blockUsage\",\n              value: { type: \"release\", hash },\n            })\n          }, 0)\n          subscription.unsubscribe()\n        }\n      })\n\n  const withInMemory =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        let isPresent = false\n        pinnedBlocks$.pipe(take(1)).subscribe((blocks) => {\n          const block = blocks.blocks.get(hash)\n          isPresent = !!block && !block.unpinned\n        })\n\n        return isPresent\n          ? fn(hash, ...args).subscribe(observer)\n          : observer.error(new BlockNotPinnedError())\n      })\n\n  const getHeader = (hash: string) =>\n    getFollower().header(hash).then(blockHeader.dec)\n\n  const unpin = (hashes: string[]) =>\n    getFollower()\n      .unpin(hashes)\n      .catch((e) => {\n        if (e instanceof DisjointError) return\n        throw e\n      })\n\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n  ) => {\n    const canonicalChain = (_fn: (hash: string, ...args: A) => Observable<T>) =>\n      withEnsureCanonicalChain(pinnedBlocks$, follow$, _fn)\n\n    return withInMemory(\n      withRefcount(\n        canonicalChain(\n          withStopRecovery(\n            pinnedBlocks$,\n            withOperationInaccessibleRecovery(\n              withRecoveryFn(fromAbortControllerFn(fn)),\n            ),\n          ),\n        ),\n      ),\n    )\n  }\n\n  const withCanonicalChain: <Args extends Array<any>, T>(\n    fn: (\n      hash: string | null,\n      withCanonical: boolean,\n      ...args: Args\n    ) => Observable<T>,\n    withCanonicalChain?: boolean,\n  ) => (hash: string | null, ...args: Args) => Observable<T> =\n    (fn, withCanonicalChain = true) =>\n    (hash, ...args) =>\n      fn(hash, withCanonicalChain, ...args)\n\n  const _call$ = withOperationInaccessibleRecovery(\n    withRecoveryFn(fromAbortControllerFn(lazyFollower(\"call\"))),\n  )\n\n  const cache = new Map<string, Map<string, Observable<any>>>()\n  const pinnedBlocks$ = getPinnedBlocks$(\n    follow$,\n    getHeader,\n    withRefcount(_call$),\n    blockUsage$,\n    (blocks) => {\n      unpin(blocks)\n      blocks.forEach((hash) => {\n        cache.delete(hash)\n      })\n    },\n  )\n\n  const getRuntimeContext$ = withRefcount((hash: string) =>\n    pinnedBlocks$.pipe(\n      take(1),\n      mergeMap(\n        (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n      ),\n    ),\n  )\n\n  const withRuntime =\n    <T>(mapper: (x: T) => string) =>\n    (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n      source$.pipe(\n        concatMapEager((x) =>\n          getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime])),\n        ),\n      )\n\n  const upsertCachedStream = <T>(\n    hash: string,\n    key: string,\n    stream: Observable<T>,\n  ): Observable<T> => {\n    const hashCache = cache.get(hash) ?? new Map()\n    const cached = hashCache.get(key)\n    if (cached) return cached\n\n    cache.set(hash, hashCache)\n\n    const connector = new ReplaySubject<T>()\n    const result = stream.pipe(\n      share({\n        connector: () => connector,\n      }),\n      tap({\n        complete() {\n          hashCache.set(key, connector)\n        },\n      }),\n    )\n    hashCache.set(key, result)\n\n    return result\n  }\n\n  const finalized$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalized === b.finalized),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.finalized)!)),\n    shareLatest,\n  )\n\n  const best$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.best === b.best),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best)!)),\n    shareLatest,\n  )\n\n  const bestBlocks$ = pinnedBlocks$.pipe(\n    distinctUntilChanged(\n      (prev, current) =>\n        prev.finalized === current.finalized && prev.best === current.best,\n    ),\n    scan((acc, pinned) => {\n      const getBlockInfo = (hash: string) =>\n        acc.get(hash) || toBlockInfo(pinned.blocks.get(hash)!)\n\n      const best = getBlockInfo(pinned.best)\n      const finalized = getBlockInfo(pinned.finalized)\n\n      const len = best.number - finalized.number + 1\n      const result = new Array<BlockInfo>(len)\n      for (let i = 0, hash = best.hash; i < len; i++) {\n        result[i] = getBlockInfo(hash)\n        hash = result[i].parent\n      }\n\n      return new Map(result.map((b) => [b.hash, b]))\n    }, new Map<string, BlockInfo>()),\n    map((x) => [...x.values()]),\n    shareLatest,\n  )\n\n  const runtime$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),\n    switchMap(({ finalizedRuntime: { runtime } }) =>\n      runtime.pipe(withDefaultValue(null)),\n    ),\n    shareLatest,\n  )\n\n  const metadata$ = runtime$.pipe(map((x) => x?.metadata ?? null))\n\n  const withOptionalHash$ = getWithOptionalhash$(\n    finalized$.pipe(map((b) => b.hash)),\n    best$.pipe(map((b) => b.hash)),\n  )\n\n  const _body$ = commonEnhancer(lazyFollower(\"body\"))\n  const body$ = (hash: string) =>\n    upsertCachedStream(hash, \"body\", _body$(hash, true))\n\n  const _storage$ = commonEnhancer(lazyFollower(\"storage\"))\n\n  const storage$ = withOptionalHash$(\n    <Type extends StorageItemInput[\"type\"], T>(\n      hash: string,\n      withCanonicalChain: boolean,\n      type: Type,\n      keyMapper: (ctx: RuntimeContext) => string,\n      childTrie: string | null = null,\n      mapper?: (data: StorageResult<Type>, ctx: RuntimeContext) => T,\n    ): Observable<unknown extends T ? StorageResult<Type> : T> =>\n      pinnedBlocks$.pipe(\n        take(1),\n        mergeMap(\n          (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n        ),\n        mergeMap((ctx) => {\n          const key = keyMapper(ctx)\n          const unMapped$ = upsertCachedStream(\n            hash,\n            `storage-${type}-${key}-${childTrie ?? \"\"}`,\n            _storage$(hash, withCanonicalChain, type, key, childTrie),\n          )\n\n          return mapper\n            ? upsertCachedStream(\n                hash,\n                `storage-${type}-${key}-${childTrie ?? \"\"}-dec`,\n                unMapped$.pipe(map((x) => mapper(x, ctx))),\n              )\n            : unMapped$\n        }),\n      ) as Observable<unknown extends T ? StorageResult<Type> : T>,\n  )\n\n  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery)\n  const storageQueries$ = withOperationInaccessibleRecovery(\n    withOptionalHash$(\n      withRefcount(\n        withStopRecovery(\n          pinnedBlocks$,\n          (\n            hash: string,\n            queries: Array<StorageItemInput>,\n            childTrie?: string,\n          ) => recoveralStorage$(hash, queries, childTrie ?? null, false),\n        ),\n      ),\n    ),\n  )\n\n  const header$ = withOptionalHash$(\n    withRefcount(\n      withStopRecovery(pinnedBlocks$, (hash: string) =>\n        defer(() => getHeader(hash)),\n      ),\n    ),\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  merge(runtime$, bestBlocks$).subscribe()\n\n  const eventsAt$ = (hash: string | null, canonical = false) =>\n    storage$(\n      hash,\n      canonical,\n      \"value\",\n      (ctx) => ctx.events.key,\n      null,\n      (x, ctx) => ctx.events.dec(x!),\n    )\n\n  const __call$ = commonEnhancer(lazyFollower(\"call\"))\n  const call$ = withOptionalHash$(\n    (hash: string, canonical: boolean, fn: string, args: string) =>\n      upsertCachedStream(\n        hash,\n        `call-${fn}-${args}`,\n        __call$(hash, canonical, fn, args),\n      ),\n  )\n\n  const validateTx$ = getValidateTx(withCanonicalChain(call$, false))\n\n  const innerBody$ = (hash: string) =>\n    upsertCachedStream(hash, \"body\", _body$(hash, false))\n\n  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$)\n  const trackTxWithoutEvents$ = getTrackTx(\n    pinnedBlocks$,\n    innerBody$,\n    validateTx$,\n    () => of(),\n  )\n\n  return {\n    follow$,\n    finalized$,\n    best$,\n    bestBlocks$,\n    runtime$,\n    metadata$,\n\n    header$,\n    body$,\n    call$: withCanonicalChain(call$),\n    storage$: withCanonicalChain(storage$),\n    storageQueries$,\n    eventsAt$: withCanonicalChain(eventsAt$),\n\n    trackTx$,\n    trackTxWithoutEvents$,\n    validateTx$,\n    pinnedBlocks$,\n    withRuntime,\n    getRuntimeContext$: withOptionalHash$(getRuntimeContext$),\n    unfollow,\n  }\n}\nexport type ChainHead$ = ReturnType<typeof getChainHead$>\n","import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    let isOperationLimit = false\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        ;(isOperationLimit = e instanceof OperationLimitError)\n          ? addTask(data, true)\n          : observer.error(e)\n      },\n      complete() {\n        observer.complete()\n      },\n    })\n\n    if (!subscription.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n        onEmptySlot()\n      })\n    } else if (!isOperationLimit) onEmptySlot()\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n","import { Observable, mergeMap, of, take } from \"rxjs\"\n\nexport const getWithOptionalhash$ = (\n  finalized$: Observable<string>,\n  best$: Observable<string>,\n) => {\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) => {\n      const hash$ =\n        hash === null || hash === \"finalized\"\n          ? finalized$\n          : hash === \"best\"\n            ? best$\n            : of(hash)\n\n      return hash$.pipe(\n        take(1),\n        mergeMap((h) => fn(h, ...args)),\n      )\n    }\n}\n","import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n","import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n","import {\n  Finalized,\n  FollowEventWithRuntime,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  filter,\n  mergeMap,\n  pipe,\n  switchMap,\n  take,\n  throwError,\n} from \"rxjs\"\nimport { BlockPrunedError, NotBestBlockError } from \"../errors\"\nimport { PinnedBlocks, retryOnStopError } from \"../streams\"\nimport { isBestOrFinalizedBlock } from \"../streams/block-operations\"\n\nexport function withEnsureCanonicalChain<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  follow$: Observable<FollowEventWithRuntime>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n): (hash: string, ensureCanonical: boolean, ...args: A) => Observable<T> {\n  return (hash: string, ensureCanonical, ...args: A) => {\n    const enhancer: <T>(x: Observable<T>) => Observable<T> = ensureCanonical\n      ? pipe(\n          throwWhenPrune(\n            hash,\n            follow$.pipe(\n              retryOnStopError(),\n              filter((evt): evt is Finalized => evt.type === \"finalized\"),\n              mergeMap((evt) => evt.prunedBlockHashes),\n            ),\n          ),\n          onlyIfIsBestOrFinalized(hash, blocks$),\n        )\n      : (x) => x\n\n    return enhancer(fn(hash, ...args))\n  }\n}\n\nconst onlyIfIsBestOrFinalized =\n  <T>(hash: string, blocks$: Observable<PinnedBlocks>) =>\n  (source$: Observable<T>) =>\n    isBestOrFinalizedBlock(blocks$, hash).pipe(\n      take(1),\n      switchMap((isBest) =>\n        isBest ? source$ : throwError(() => new NotBestBlockError()),\n      ),\n    )\n\nconst throwWhenPrune =\n  <T>(hash: string, pruned$: Observable<string>) =>\n  (source$: Observable<T>) =>\n    new Observable<T>((subscriber) => {\n      const prunedSubscription = pruned$\n        .pipe(filter((h) => h === hash))\n        .subscribe(() => {\n          subscriber.error(new BlockPrunedError())\n        })\n      const sourceSubscription = source$.subscribe(subscriber)\n\n      return () => {\n        prunedSubscription.unsubscribe()\n        sourceSubscription.unsubscribe()\n      }\n    })\n","export class BlockNotPinnedError extends Error {\n  constructor() {\n    super(\"Block is not pinned\")\n    this.name = \"BlockNotPinnedError\"\n  }\n}\n\nexport class BlockPrunedError extends Error {\n  constructor() {\n    super(\"Block pruned\")\n    this.name = \"BlockPrunedError\"\n  }\n}\n\nexport class NotBestBlockError extends Error {\n  constructor() {\n    super(\"Block is not best block or finalized\")\n    this.name = \"NotBestBlockError\"\n  }\n}\n","import {\n  ChainHead,\n  FollowEventWithRuntime,\n  FollowResponse,\n  StopError,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, Subscription, noop, share } from \"rxjs\"\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse | null = null\n  let unfollow: () => void = noop\n\n  const follow$ = new Observable<FollowEventWithRuntime>((observer) => {\n    follower = chainHead(\n      true,\n      (e) => {\n        observer.next(e)\n      },\n      (e) => {\n        follower = null\n        observer.error(e)\n      },\n    )\n    unfollow = () => {\n      observer.complete()\n      follower?.unfollow()\n    }\n  }).pipe(share())\n\n  return {\n    getFollower: () => {\n      if (!follower) throw new Error(\"Missing chainHead subscription\")\n      return follower\n    },\n    unfollow: () => {\n      unfollow()\n    },\n    follow$,\n  }\n}\n\nexport const retryOnStopError =\n  <T extends { type: string }>() =>\n  (source$: Observable<T>) =>\n    new Observable<\n      | T\n      | {\n          type: \"stop-error\"\n        }\n    >((observer) => {\n      const subscription = new Subscription()\n      const subscribe = () =>\n        source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => {\n            if (e instanceof StopError) {\n              observer.next({ type: \"stop-error\" })\n              subscription.add(subscribe())\n            } else {\n              observer.error(e)\n            }\n          },\n          complete: () => observer.complete(),\n        })\n      subscription.add(subscribe())\n      return subscription\n    })\n","import {\n  getChecksumBuilder,\n  getDynamicBuilder,\n  getLookupFn,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  AccountId,\n  Codec,\n  Decoder,\n  SS58String,\n  Option,\n  V15,\n  u32,\n  Encoder,\n  _void,\n  Bytes,\n  metadata as metadataCodec,\n  V14,\n  Vector,\n  Tuple,\n  compact,\n} from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  catchError,\n  map,\n  mergeMap,\n  of,\n  shareReplay,\n  switchMap,\n  take,\n} from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\n\nexport type SystemEvent = {\n  phase:\n    | { type: \"ApplyExtrinsic\"; value: number }\n    | { type: \"Finalization\" }\n    | { type: \"Initialization\" }\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport interface RuntimeContext {\n  metadataRaw: Uint8Array\n  metadata: V15 | V14\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<Array<SystemEvent>>\n  }\n  accountId: Codec<SS58String>\n  asset: [Encoder<any>, string | null]\n}\n\nexport interface Runtime {\n  at: string\n  runtime: Observable<RuntimeContext>\n  addBlock: (block: string) => Runtime\n  deleteBlocks: (blocks: string[]) => number\n  usages: Set<string>\n}\n\nconst v15Args = toHex(u32.enc(15))\nconst opaqueMeta14 = Tuple(compact, Bytes())\nconst opaqueMeta15 = Option(Bytes())\nconst u32ListDecoder = Vector(u32).dec\n\nexport const getRuntimeCreator = (\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  finalized$: Observable<string>,\n) => {\n  const getMetadata$ = (\n    hash: string,\n  ): Observable<{ metadataRaw: Uint8Array; metadata: V14 | V15 }> => {\n    const recoverCall$ = (\n      hash: string,\n      method: string,\n      args: string,\n    ): Observable<string> =>\n      call$(hash, method, args).pipe(\n        catchError((e) => {\n          if (e instanceof BlockNotPinnedError) {\n            return finalized$.pipe(\n              take(1),\n              switchMap((newHash) => recoverCall$(newHash, method, args)),\n            )\n          }\n          throw e\n        }),\n      )\n\n    const versions = recoverCall$(hash, \"Metadata_metadata_versions\", \"\").pipe(\n      map(u32ListDecoder),\n    )\n\n    const v14 = recoverCall$(hash, \"Metadata_metadata\", \"\").pipe(\n      map((x) => {\n        const [, metadataRaw] = opaqueMeta14.dec(x)!\n        const metadata = metadataCodec.dec(metadataRaw)\n        return { metadata: metadata.metadata.value as V14, metadataRaw }\n      }),\n    )\n\n    const v15 = recoverCall$(\n      hash,\n      \"Metadata_metadata_at_version\",\n      v15Args,\n    ).pipe(\n      map((x) => {\n        const metadataRaw = opaqueMeta15.dec(x)!\n        const metadata = metadataCodec.dec(metadataRaw)\n        return { metadata: metadata.metadata.value as V15, metadataRaw }\n      }),\n    )\n\n    return versions.pipe(\n      catchError(() => of([14])),\n      mergeMap((v) => (v.includes(15) ? v15 : v14)),\n    )\n  }\n\n  return (hash: string): Runtime => {\n    const usages = new Set<string>([hash])\n\n    const runtimeContext$: Observable<RuntimeContext> = getMetadata$(hash).pipe(\n      map(({ metadata, metadataRaw }) => {\n        const checksumBuilder = getChecksumBuilder(metadata)\n        const dynamicBuilder = getDynamicBuilder(metadata)\n        const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n\n        const assetPayment = metadata.extrinsic.signedExtensions.find(\n          (x) => x.identifier === \"ChargeAssetTxPayment\",\n        )\n\n        let _assetId: null | number = null\n        if (assetPayment) {\n          const assetTxPayment = getLookupFn(metadata.lookup)(assetPayment.type)\n          if (assetTxPayment.type === \"struct\") {\n            const optionalAssetId = assetTxPayment.value.asset_id\n            if (optionalAssetId.type === \"option\")\n              _assetId = optionalAssetId.value.id\n          }\n        }\n\n        const asset: [Encoder<any>, string | null] =\n          _assetId === null\n            ? [_void.enc, null]\n            : [\n                dynamicBuilder.buildDefinition(_assetId).enc,\n                checksumBuilder.buildDefinition(_assetId),\n              ]\n\n        return {\n          asset,\n          metadataRaw,\n          metadata,\n          checksumBuilder,\n          dynamicBuilder,\n          events: {\n            key: events.enc(),\n            dec: events.dec as any,\n          },\n          accountId: AccountId(dynamicBuilder.ss58Prefix),\n        }\n      }),\n      shareReplay(1),\n    )\n\n    const result: Runtime = {\n      at: hash,\n      runtime: runtimeContext$,\n      addBlock: (block: string) => {\n        usages.add(block)\n        return result\n      },\n      deleteBlocks: (blocks) => {\n        blocks.forEach((block) => {\n          usages.delete(block)\n        })\n        return usages.size\n      },\n      usages,\n    }\n    runtimeContext$.subscribe()\n\n    return result\n  }\n}\n","import { shareLatest } from \"@/utils\"\nimport { BlockHeader } from \"@polkadot-api/substrate-bindings\"\nimport { FollowEventWithRuntime } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  Subject,\n  concatMap,\n  filter,\n  map,\n  merge,\n  of,\n  scan,\n} from \"rxjs\"\nimport { withStopRecovery } from \"../enhancers\"\nimport { retryOnStopError } from \"./follow\"\nimport { Runtime, getRuntimeCreator } from \"./get-runtime-creator\"\n\nexport interface PinnedBlock {\n  hash: string\n  number: number\n  parent: string\n  children: Set<string>\n  runtime: string\n  refCount: number\n  unpinned?: true\n  recovering: boolean\n}\n\nexport interface BlockUsageEvent {\n  type: \"blockUsage\"\n  value: { type: \"hold\"; hash: string } | { type: \"release\"; hash: string }\n}\n\nexport type PinnedBlocks = {\n  best: string\n  finalized: string\n  runtimes: Record<string, Runtime>\n  blocks: Map<string, PinnedBlock>\n  finalizedRuntime: Runtime\n  recovering: boolean\n}\n\nconst deleteBlock = (blocks: PinnedBlocks[\"blocks\"], blockHash: string) => {\n  blocks.get(blocks.get(blockHash)!.parent)?.children.delete(blockHash)\n  blocks.delete(blockHash)\n}\n\nconst getBlocksToUnpin = (blocks: PinnedBlocks, pruned: string[]) => {\n  const result: string[] = [...pruned]\n  let current = blocks.blocks.get(blocks.blocks.get(blocks.finalized)!.parent)\n\n  const trail: string[] = []\n  while (current) {\n    trail.push(current.hash)\n    if (current.refCount === 0 && !current.unpinned) {\n      result.push(current.hash)\n      current.unpinned = true\n    }\n\n    current = blocks.blocks.get(current.parent)\n  }\n\n  const deletedBlocks = [...pruned]\n  for (let i = trail.length - 1; i >= 0; i--) {\n    current = blocks.blocks.get(trail[i])!\n    if (!current.unpinned) return result\n    deletedBlocks.push(current.hash)\n  }\n\n  deletedBlocks.forEach((hash) => {\n    deleteBlock(blocks.blocks, hash)\n  })\n\n  Object.entries(blocks.runtimes)\n    .map(([key, value]) => ({\n      key,\n      usages: value.deleteBlocks(deletedBlocks),\n    }))\n    .filter((x) => x.usages === 0)\n    .map((x) => x.key)\n    .forEach((unusedRuntime) => {\n      delete blocks.runtimes[unusedRuntime]\n    })\n  return result\n}\n\nexport const getPinnedBlocks$ = (\n  follow$: Observable<FollowEventWithRuntime>,\n  getHeader: (hash: string) => Promise<BlockHeader>,\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  blockUsage$: Subject<BlockUsageEvent>,\n  onUnpin: (blocks: string[]) => void,\n) => {\n  const pinnedBlocks$: Observable<PinnedBlocks> = merge(\n    blockUsage$,\n    follow$.pipe(withInitializedNumber(getHeader), retryOnStopError()),\n  ).pipe(\n    scan((acc, event) => {\n      switch (event.type) {\n        case \"initialized\":\n          if (acc.recovering) {\n            const isConnected = event.finalizedBlockHashes.some((hash) =>\n              acc.blocks.has(hash),\n            )\n            if (!isConnected) {\n              acc = getInitialPinnedBlocks()\n            }\n          }\n\n          const [finalizedHash] = event.finalizedBlockHashes.slice(-1)\n          acc.finalized = acc.best = finalizedHash\n\n          const lastIdx = event.finalizedBlockHashes.length - 1\n          event.finalizedBlockHashes.forEach((hash, i) => {\n            if (acc.blocks.has(hash)) {\n              acc.blocks.get(hash)!.recovering = false\n            } else {\n              acc.blocks.set(hash, {\n                hash: hash,\n                parent:\n                  i === 0\n                    ? event.parentHash\n                    : event.finalizedBlockHashes[i - 1],\n                children: new Set(\n                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]],\n                ),\n                runtime: hash,\n                refCount: 0,\n                number: event.number + i,\n                recovering: false,\n              })\n            }\n          })\n\n          const finalizedRuntime = Object.values(acc.runtimes).find((runtime) =>\n            runtime.usages.has(finalizedHash),\n          )\n\n          acc.finalizedRuntime =\n            finalizedRuntime ??\n            (acc.runtimes[finalizedHash] = getRuntime(finalizedHash))\n\n          return acc\n\n        case \"stop-error\":\n          for (const block of acc.blocks.values()) {\n            block.recovering = true\n          }\n          acc.recovering = true\n\n          return acc\n\n        case \"newBlock\": {\n          const { parentBlockHash: parent, blockHash: hash } = event\n          if (acc.blocks.has(hash)) {\n            acc.blocks.get(hash)!.recovering = false\n          } else {\n            const parentNode = acc.blocks.get(parent)!\n            parentNode.children.add(hash)\n            if (event.newRuntime) {\n              acc.runtimes[hash] = getRuntime(hash)\n              acc.runtimes[hash].runtime.subscribe()\n            }\n            const block = {\n              hash,\n              number: parentNode.number + 1,\n              parent: parent,\n              children: new Set<string>(),\n              runtime: event.newRuntime ? hash : parentNode.runtime,\n              refCount: 0,\n              recovering: false,\n            }\n            acc.blocks.set(hash, block)\n            acc.runtimes[block.runtime].addBlock(hash)\n          }\n\n          return acc\n        }\n\n        case \"bestBlockChanged\": {\n          if (acc.recovering) {\n            for (const [hash, block] of acc.blocks) {\n              if (block.recovering) {\n                deleteBlock(acc.blocks, hash)\n              }\n            }\n            acc.recovering = false\n          }\n          acc.best = event.bestBlockHash\n          return acc\n        }\n\n        case \"finalized\": {\n          acc.finalized = event.finalizedBlockHashes.slice(-1)[0]\n          acc.finalizedRuntime =\n            acc.runtimes[acc.blocks.get(acc.finalized)!.runtime]\n\n          // TODO: remove this once https://github.com/paritytech/polkadot-sdk/issues/3658 is fixed\n          const actuallyPruned = [...new Set(event.prunedBlockHashes)]\n          onUnpin(getBlocksToUnpin(acc, actuallyPruned))\n          return acc\n        }\n\n        case \"blockUsage\": {\n          if (!acc.blocks.has(event.value.hash)) return acc\n\n          const block = acc.blocks.get(event.value.hash)!\n          block.refCount += event.value.type === \"hold\" ? 1 : -1\n          if (\n            block.refCount === 0 &&\n            block.number < acc.blocks.get(acc.finalized)!.number &&\n            !block.recovering\n          ) {\n            block.unpinned = true\n            onUnpin([block.hash])\n          }\n          return acc\n        }\n      }\n    }, getInitialPinnedBlocks()),\n    filter((x) => !!x.finalizedRuntime.runtime),\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  const getRuntime = getRuntimeCreator(\n    withStopRecovery(pinnedBlocks$, call$),\n    pinnedBlocks$.pipe(map((v) => v.finalized)),\n  )\n\n  return pinnedBlocks$\n}\n\nconst getInitialPinnedBlocks = (): PinnedBlocks => ({\n  best: \"\",\n  finalized: \"\",\n  runtimes: {},\n  blocks: new Map(),\n  finalizedRuntime: {} as Runtime,\n  recovering: false,\n})\n\nconst withInitializedNumber =\n  (getHeader: (hash: string) => Promise<BlockHeader>) =>\n  (source$: Observable<FollowEventWithRuntime>) =>\n    source$.pipe(\n      concatMap((event) => {\n        return event.type !== \"initialized\"\n          ? of(event)\n          : getHeader(event.finalizedBlockHashes[0]).then((header) => ({\n              ...event,\n              number: header.number,\n              parentHash: header.parentHash,\n            }))\n      }),\n    )\n","import { Observable, distinctUntilChanged, filter, map, takeWhile } from \"rxjs\"\nimport { PinnedBlocks } from \"./pinned-blocks\"\n\nexport const isBestOrFinalizedBlock = (\n  blocks$: Observable<PinnedBlocks>,\n  blockHash: string,\n) =>\n  blocks$.pipe(\n    takeWhile((b) => b.blocks.has(blockHash)),\n    distinctUntilChanged(\n      (a, b) => a.finalized === b.finalized && a.best === b.best,\n    ),\n    filter(\n      (x) => x.blocks.get(x.best)!.number >= x.blocks.get(blockHash)!.number,\n    ),\n    map((pinned): \"best\" | \"finalized\" | null => {\n      const { number } = pinned.blocks.get(blockHash)!\n      let current = pinned.blocks.get(pinned.best)!\n      let isFinalized = pinned.finalized === current.hash\n      while (current.number > number) {\n        current = pinned.blocks.get(current.parent)!\n        isFinalized = isFinalized || pinned.finalized === current.hash\n      }\n      if (isFinalized) return \"finalized\"\n      return current.hash === blockHash ? \"best\" : null\n    }),\n    distinctUntilChanged(),\n    takeWhile((x) => x !== \"finalized\", true),\n  )\n","import { Observable, ObservedValueOf, Subscription } from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { PinnedBlocks } from \"../streams\"\n\nexport function withStopRecovery<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n) {\n  return (hash: string, ...args: A) => {\n    const source$ = fn(hash, ...args)\n\n    return new Observable<ObservedValueOf<typeof source$>>((observer) => {\n      let sourceSub: Subscription | null = null\n      let isSubscribed = false\n      const performSourceSub = () => {\n        if (isSubscribed) return\n        isSubscribed = true\n        sourceSub = source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => observer.error(e),\n          complete: () => observer.complete(),\n        })\n        sourceSub.add(() => {\n          isSubscribed = false\n          sourceSub = null\n        })\n      }\n\n      let isRecovering = false\n      const blockSub = blocks$.subscribe({\n        next: (v) => {\n          const block = v.blocks.get(hash)\n          if (!block) {\n            // This branch conflicts with BlockPrunedError, as the block might disappear when it gets pruned\n            // We can avoid this conflict by checking that we're actually recovering.\n            if (isRecovering) {\n              observer.error(new BlockNotPinnedError())\n            }\n          } else if (block.recovering) {\n            // Pause while it's recovering, as we don't know if the block is there\n            sourceSub?.unsubscribe()\n          } else {\n            performSourceSub()\n          }\n          isRecovering = v.recovering\n        },\n        error: (e) => observer.error(e),\n      })\n\n      return () => {\n        blockSub.unsubscribe()\n        sourceSub?.unsubscribe()\n      }\n    })\n  }\n}\n","import { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\nimport { Observable, catchError, concatMap, throwError, timer } from \"rxjs\"\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const withOperationInaccessibleRecovery =\n  <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n  (...args: Args): Observable<T> =>\n    operable(fn(...args))\n","import {\n  FollowResponse,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, mergeAll } from \"rxjs\"\nimport { getWithRecovery } from \"./enhancers\"\n\nexport const getRecoveralStorage$ = (\n  getFollower: () => FollowResponse,\n  withRecovery: ReturnType<typeof getWithRecovery>[\"withRecovery\"],\n) => {\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            if (nDiscarded === 0) return\n\n            observer.next(\n              recoveralStorage$(\n                hash,\n                queries.slice(-nDiscarded),\n                childTrie,\n                true,\n              ),\n            )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  return recoveralStorage$\n}\n","import {\n  Observable,\n  distinct,\n  filter,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeUntil,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./streams\"\nimport { HexString } from \"@polkadot-api/substrate-bindings\"\n\nexport type AnalyzedBlock = {\n  hash: HexString\n  found:\n    | {\n        type: true\n        index: number\n        events: any\n      }\n    | {\n        type: false\n        isValid: boolean\n      }\n}\n\nexport const getTrackTx = (\n  blocks$: Observable<PinnedBlocks>,\n  getBody: (block: string) => Observable<string[]>, // Returns an observable that should emit just once and complete\n  getIsValid: (block: string, tx: string) => Observable<boolean>, // Returns an observable that should emit just once and complete\n  getEvents: (block: string) => Observable<any>, // Returns an observable that should emit just once and complete\n) => {\n  const whileBlockPresent = <TT>(\n    hash: string,\n  ): (<T = TT>(base: Observable<T>) => Observable<T>) =>\n    takeUntil(blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))))\n\n  const analyzeBlock = (\n    hash: string,\n    tx: string,\n    alreadyPresent: boolean,\n  ): Observable<AnalyzedBlock> => {\n    if (alreadyPresent)\n      return of({ hash, found: { type: false, isValid: true } })\n\n    const whilePresent = whileBlockPresent(hash)\n    return getBody(hash).pipe(\n      mergeMap((txs) => {\n        const index = txs.indexOf(tx)\n        return index > -1\n          ? whilePresent(getEvents(hash)).pipe(\n              map((events) => ({\n                hash,\n                found: {\n                  type: true as true,\n                  index,\n                  events,\n                },\n              })),\n            )\n          : getIsValid(hash, tx).pipe(\n              map((isValid) => ({\n                hash,\n                found: { type: false as false, isValid },\n              })),\n            )\n      }),\n      whilePresent,\n    )\n  }\n\n  const findInBranch = (\n    hash: string,\n    tx: string,\n    alreadyPresent: Set<string>,\n  ): Observable<AnalyzedBlock> =>\n    analyzeBlock(hash, tx, alreadyPresent.has(hash)).pipe(\n      mergeMap((analyzed) => {\n        const { found } = analyzed\n        return found.type || !found.isValid\n          ? of(analyzed)\n          : blocks$.pipe(\n              whileBlockPresent(hash),\n              mergeMap((x) => x.blocks.get(hash)!.children),\n              distinct(),\n              mergeMap((hash) => findInBranch(hash, tx, alreadyPresent)),\n            )\n      }),\n    )\n\n  return (tx: string): Observable<AnalyzedBlock> =>\n    blocks$.pipe(\n      take(1),\n      mergeMap((x) => findInBranch(x.finalized, tx, new Set(x.blocks.keys()))),\n    )\n}\n","import { Observable, map } from \"rxjs\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\n\nconst external = new Uint8Array([2])\n\nconst getValidateTxArgs = (tx: string, hash: string) =>\n  toHex(mergeUint8(external, fromHex(tx), fromHex(hash)))\n\nexport const getValidateTx =\n  (\n    call$: (\n      hash: string | null,\n      fnName: string,\n      parameters: string,\n    ) => Observable<string>,\n  ) =>\n  (blockHash: string, tx: string) =>\n    call$(\n      blockHash,\n      \"TaggedTransactionQueue_validate_transaction\",\n      getValidateTxArgs(tx, blockHash),\n    ).pipe(map((x) => x.startsWith(\"0x00\")))\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<never>((observer) =>\n      baseTransaction(transaction, (e) => {\n        observer.error(e)\n      }),\n    )\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nexport type * from \"./chainHead\"\n\nimport { getChainHead$ } from \"./chainHead\"\nimport getBroadcastTx$ from \"./tx\"\n\nexport const getObservableClient = ({\n  chainHead,\n  transaction,\n  destroy,\n}: SubstrateClient) => ({\n  chainHead$: () => getChainHead$(chainHead),\n  broadcastTx$: getBroadcastTx$(transaction),\n  destroy,\n})\n"],"mappings":"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","names":["src_exports","__export","BlockNotPinnedError","BlockPrunedError","NotBestBlockError","getObservableClient","__toCommonJS","import_rxjs","shareLatest","import_rxjs","concatMapEager","mapper","concurrent","source$","observer","topSubscription","queues","innerSubscriptions","results","mapperIdx","subscriptionIdx","observerIdx","nextSubscription","inner$","idx","x","e","outterValue","subscription","import_rxjs","withDefaultValue","defaultValue","source$","observer","hasEmited","subscription","v","e","import_substrate_bindings","import_substrate_client","import_rxjs","import_substrate_client","import_rxjs","PendingTaskQueue","__publicField","node","value","newNode","result","getWithRecovery","tearDownOperations","setTeardown","observable","cb","teardown","pendingTasks","unshift","push","addTask","task","topPriority","fn","onEmptySlot","data","process","source$","observer","isOperationLimit","subscription","x","e","withRecovery","pendingTask","withNormalRecovery","args","import_rxjs","getWithOptionalhash$","finalized$","best$","fn","hash","args","h","import_rxjs","fromAbortControllerFn","fn","args","observer","aborter","value","error","withLazyFollower","getFollower","key","args","import_rxjs","BlockNotPinnedError","BlockPrunedError","NotBestBlockError","import_substrate_client","import_rxjs","getFollow$","chainHead","follower","unfollow","follow$","observer","e","retryOnStopError","source$","subscription","subscribe","v","import_metadata_builders","import_substrate_bindings","import_utils","import_rxjs","v15Args","opaqueMeta14","opaqueMeta15","u32ListDecoder","getRuntimeCreator","call$","finalized$","getMetadata$","hash","recoverCall$","method","args","e","BlockNotPinnedError","newHash","versions","v14","x","metadataRaw","metadataCodec","v15","v","usages","runtimeContext$","metadata","checksumBuilder","dynamicBuilder","events","assetPayment","_assetId","assetTxPayment","optionalAssetId","result","block","blocks","import_rxjs","deleteBlock","blocks","blockHash","getBlocksToUnpin","pruned","result","current","trail","deletedBlocks","i","hash","key","value","x","unusedRuntime","getPinnedBlocks$","follow$","getHeader","call$","blockUsage$","onUnpin","pinnedBlocks$","withInitializedNumber","retryOnStopError","acc","event","getInitialPinnedBlocks","finalizedHash","lastIdx","finalizedRuntime","runtime","getRuntime","block","parent","parentNode","actuallyPruned","shareLatest","getRuntimeCreator","withStopRecovery","v","source$","header","import_rxjs","isBestOrFinalizedBlock","blocks$","blockHash","b","a","x","pinned","number","current","isFinalized","withEnsureCanonicalChain","blocks$","follow$","fn","hash","ensureCanonical","args","throwWhenPrune","retryOnStopError","evt","onlyIfIsBestOrFinalized","x","source$","isBestOrFinalizedBlock","isBest","NotBestBlockError","pruned$","subscriber","prunedSubscription","h","BlockPrunedError","sourceSubscription","import_rxjs","withStopRecovery","blocks$","fn","hash","args","source$","observer","sourceSub","isSubscribed","performSourceSub","v","e","isRecovering","blockSub","block","BlockNotPinnedError","import_substrate_client","import_rxjs","operable","source$","result","e","withOperationInaccessibleRecovery","fn","args","import_rxjs","getRecoveralStorage$","getFollower","withRecovery","recoveralStorage$","hash","queries","childTrie","isHighPriority","observer","items","error","nDiscarded","import_rxjs","getTrackTx","blocks$","getBody","getIsValid","getEvents","whileBlockPresent","hash","blocks","analyzeBlock","tx","alreadyPresent","whilePresent","txs","index","events","isValid","findInBranch","analyzed","found","x","import_rxjs","import_utils","external","getValidateTxArgs","tx","hash","getValidateTx","call$","blockHash","x","toBlockInfo","hash","number","parent","getChainHead$","chainHead","getFollower","unfollow","follow$","getFollow$","lazyFollower","withLazyFollower","withRecovery","withRecoveryFn","getWithRecovery","blockUsage$","withRefcount","fn","args","observer","subscription","withInMemory","isPresent","pinnedBlocks$","blocks","block","BlockNotPinnedError","getHeader","unpin","hashes","e","commonEnhancer","_fn","withEnsureCanonicalChain","withStopRecovery","withOperationInaccessibleRecovery","fromAbortControllerFn","withCanonicalChain","_call$","cache","getPinnedBlocks$","getRuntimeContext$","pinned","withRuntime","mapper","source$","concatMapEager","x","runtime","upsertCachedStream","key","stream","hashCache","cached","connector","result","finalized$","shareLatest","best$","bestBlocks$","prev","current","acc","getBlockInfo","best","finalized","len","i","b","runtime$","withDefaultValue","metadata$","withOptionalHash$","getWithOptionalhash$","_body$","body$","_storage$","storage$","type","keyMapper","childTrie","ctx","unMapped$","recoveralStorage$","getRecoveralStorage$","storageQueries$","queries","header$","eventsAt$","canonical","__call$","call$","validateTx$","getValidateTx","innerBody$","trackTx$","getTrackTx","trackTxWithoutEvents$","import_rxjs","tx_default","baseTransaction","transaction","observer","e","getObservableClient","chainHead","transaction","destroy","getChainHead$","tx_default"]}