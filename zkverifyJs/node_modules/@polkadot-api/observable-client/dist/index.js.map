{"version":3,"sources":["../src/index.ts","../src/utils/shareLatest.ts","../src/utils/concatMapEager.ts","../src/utils/with-default-value.ts","../src/chainHead/chainHead.ts","../src/chainHead/enhancers/operationLimitRecovery.ts","../src/chainHead/enhancers/optionalHash.ts","../src/chainHead/enhancers/fromAbortControllerFn.ts","../src/chainHead/enhancers/lazyFollower.ts","../src/chainHead/enhancers/whileBestBlock.ts","../src/chainHead/errors.ts","../src/chainHead/streams/follow.ts","../src/chainHead/streams/get-runtime-creator.ts","../src/chainHead/streams/pinned-blocks.ts","../src/chainHead/streams/block-operations.ts","../src/chainHead/enhancers/withStopRecovery.ts","../src/chainHead/enhancers/operationInaccessibleRecovery.ts","../src/chainHead/storage-queries.ts","../src/chainHead/track-tx.ts","../src/chainHead/validate-tx.ts","../src/tx.ts","../src/getObservableClient.ts"],"sourcesContent":["export * from \"./getObservableClient\"\nexport {\n  BlockNotPinnedError,\n  BlockPrunedError,\n  NotBestBlockError,\n  AnalyzedBlock,\n  PinnedBlock,\n} from \"./chainHead\"\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let topSubscription: Subscription\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (\n            innerSubscriptions.size === 0 &&\n            (typeof topSubscription === \"undefined\" || topSubscription.closed)\n          ) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n        innerSubscriptions.set(\n          idx,\n          inner$.subscribe({\n            next(x: O) {\n              if (observerIdx === idx) {\n                observer.next(x)\n              } else {\n                results.get(idx)!.push(x)\n              }\n            },\n            complete() {\n              innerSubscriptions.delete(idx)\n              if (idx === observerIdx) {\n                observerIdx++\n                while (results.has(observerIdx)) {\n                  results.get(observerIdx)!.forEach((x) => observer.next(x))\n                  results.delete(observerIdx)\n                  if (innerSubscriptions.has(observerIdx)) {\n                    break\n                  }\n                  observerIdx++\n                }\n              }\n              nextSubscription()\n            },\n            error(e: any) {\n              observer.error(e)\n            },\n          }),\n        )\n      }\n\n      topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nexport const withDefaultValue =\n  <V, T>(defaultValue: V) =>\n  (source$: Observable<T>): Observable<V | T> =>\n    new Observable((observer) => {\n      let hasEmited = false\n\n      const subscription = source$.subscribe({\n        next(v) {\n          hasEmited = true\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      if (!hasEmited) observer.next(defaultValue)\n\n      return subscription\n    })\n","import { concatMapEager, shareLatest } from \"@/utils\"\nimport { blockHeader } from \"@polkadot-api/substrate-bindings\"\nimport {\n  ChainHead,\n  DisjointError,\n  FollowEventWithRuntime,\n  StorageItemInput,\n  StorageResult,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  ReplaySubject,\n  Subject,\n  defer,\n  distinctUntilChanged,\n  map,\n  merge,\n  mergeMap,\n  of,\n  scan,\n  share,\n  switchMap,\n  take,\n  tap,\n} from \"rxjs\"\n\nimport { withDefaultValue } from \"@/utils\"\nimport {\n  fromAbortControllerFn,\n  getWithOptionalhash$,\n  getWithRecovery,\n  withEnsureCanonicalChain,\n  withLazyFollower,\n  withOperationInaccessibleRecovery,\n  withStopRecovery,\n} from \"./enhancers\"\nimport { BlockNotPinnedError } from \"./errors\"\nimport { getRecoveralStorage$ } from \"./storage-queries\"\nimport type {\n  BlockUsageEvent,\n  PinnedBlocks,\n  PinnedBlock,\n  RuntimeContext,\n  SystemEvent,\n} from \"./streams\"\nimport { getFollow$, getPinnedBlocks$ } from \"./streams\"\nimport { getTrackTx } from \"./track-tx\"\nimport { getValidateTx } from \"./validate-tx\"\n\nexport type {\n  PinnedBlocks,\n  PinnedBlock,\n  FollowEventWithRuntime,\n  RuntimeContext,\n  SystemEvent,\n}\n\nexport type BlockInfo = {\n  hash: string\n  number: number\n  parent: string\n}\n\nconst toBlockInfo = ({ hash, number, parent }: PinnedBlock): BlockInfo => ({\n  hash,\n  number,\n  parent,\n})\n\nexport const getChainHead$ = (chainHead: ChainHead) => {\n  const { getFollower, unfollow, follow$ } = getFollow$(chainHead)\n  const lazyFollower = withLazyFollower(getFollower)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n\n  const blockUsage$ = new Subject<BlockUsageEvent>()\n  const withRefcount =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        blockUsage$.next({ type: \"blockUsage\", value: { type: \"hold\", hash } })\n        const subscription = fn(hash, ...args).subscribe(observer)\n        return () => {\n          setTimeout(() => {\n            blockUsage$.next({\n              type: \"blockUsage\",\n              value: { type: \"release\", hash },\n            })\n          }, 0)\n          subscription.unsubscribe()\n        }\n      })\n\n  const withInMemory =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        let isPresent = false\n        pinnedBlocks$.pipe(take(1)).subscribe((blocks) => {\n          const block = blocks.blocks.get(hash)\n          isPresent = !!block && !block.unpinned\n        })\n\n        return isPresent\n          ? fn(hash, ...args).subscribe(observer)\n          : observer.error(new BlockNotPinnedError())\n      })\n\n  const getHeader = (hash: string) =>\n    getFollower().header(hash).then(blockHeader.dec)\n\n  const unpin = (hashes: string[]) =>\n    getFollower()\n      .unpin(hashes)\n      .catch((e) => {\n        if (e instanceof DisjointError) return\n        throw e\n      })\n\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n  ) => {\n    const canonicalChain = (_fn: (hash: string, ...args: A) => Observable<T>) =>\n      withEnsureCanonicalChain(pinnedBlocks$, follow$, _fn)\n\n    return withInMemory(\n      withRefcount(\n        canonicalChain(\n          withStopRecovery(\n            pinnedBlocks$,\n            withOperationInaccessibleRecovery(\n              withRecoveryFn(fromAbortControllerFn(fn)),\n            ),\n          ),\n        ),\n      ),\n    )\n  }\n\n  const withCanonicalChain: <Args extends Array<any>, T>(\n    fn: (\n      hash: string | null,\n      withCanonical: boolean,\n      ...args: Args\n    ) => Observable<T>,\n    withCanonicalChain?: boolean,\n  ) => (hash: string | null, ...args: Args) => Observable<T> =\n    (fn, withCanonicalChain = true) =>\n    (hash, ...args) =>\n      fn(hash, withCanonicalChain, ...args)\n\n  const _call$ = withOperationInaccessibleRecovery(\n    withRecoveryFn(fromAbortControllerFn(lazyFollower(\"call\"))),\n  )\n\n  const cache = new Map<string, Map<string, Observable<any>>>()\n  const pinnedBlocks$ = getPinnedBlocks$(\n    follow$,\n    getHeader,\n    withRefcount(_call$),\n    blockUsage$,\n    (blocks) => {\n      unpin(blocks)\n      blocks.forEach((hash) => {\n        cache.delete(hash)\n      })\n    },\n  )\n\n  const getRuntimeContext$ = withRefcount((hash: string) =>\n    pinnedBlocks$.pipe(\n      take(1),\n      mergeMap(\n        (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n      ),\n    ),\n  )\n\n  const withRuntime =\n    <T>(mapper: (x: T) => string) =>\n    (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n      source$.pipe(\n        concatMapEager((x) =>\n          getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime])),\n        ),\n      )\n\n  const upsertCachedStream = <T>(\n    hash: string,\n    key: string,\n    stream: Observable<T>,\n  ): Observable<T> => {\n    const hashCache = cache.get(hash) ?? new Map()\n    const cached = hashCache.get(key)\n    if (cached) return cached\n\n    cache.set(hash, hashCache)\n\n    const connector = new ReplaySubject<T>()\n    const result = stream.pipe(\n      share({\n        connector: () => connector,\n      }),\n      tap({\n        complete() {\n          hashCache.set(key, connector)\n        },\n      }),\n    )\n    hashCache.set(key, result)\n\n    return result\n  }\n\n  const finalized$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalized === b.finalized),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.finalized)!)),\n    shareLatest,\n  )\n\n  const best$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.best === b.best),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best)!)),\n    shareLatest,\n  )\n\n  const bestBlocks$ = pinnedBlocks$.pipe(\n    distinctUntilChanged(\n      (prev, current) =>\n        prev.finalized === current.finalized && prev.best === current.best,\n    ),\n    scan((acc, pinned) => {\n      const getBlockInfo = (hash: string) =>\n        acc.get(hash) || toBlockInfo(pinned.blocks.get(hash)!)\n\n      const best = getBlockInfo(pinned.best)\n      const finalized = getBlockInfo(pinned.finalized)\n\n      const len = best.number - finalized.number + 1\n      const result = new Array<BlockInfo>(len)\n      for (let i = 0, hash = best.hash; i < len; i++) {\n        result[i] = getBlockInfo(hash)\n        hash = result[i].parent\n      }\n\n      return new Map(result.map((b) => [b.hash, b]))\n    }, new Map<string, BlockInfo>()),\n    map((x) => [...x.values()]),\n    shareLatest,\n  )\n\n  const runtime$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),\n    switchMap(({ finalizedRuntime: { runtime } }) =>\n      runtime.pipe(withDefaultValue(null)),\n    ),\n    shareLatest,\n  )\n\n  const metadata$ = runtime$.pipe(map((x) => x?.metadata ?? null))\n\n  const withOptionalHash$ = getWithOptionalhash$(\n    finalized$.pipe(map((b) => b.hash)),\n    best$.pipe(map((b) => b.hash)),\n  )\n\n  const _body$ = commonEnhancer(lazyFollower(\"body\"))\n  const body$ = (hash: string) =>\n    upsertCachedStream(hash, \"body\", _body$(hash, true))\n\n  const _storage$ = commonEnhancer(lazyFollower(\"storage\"))\n\n  const storage$ = withOptionalHash$(\n    <Type extends StorageItemInput[\"type\"], T>(\n      hash: string,\n      withCanonicalChain: boolean,\n      type: Type,\n      keyMapper: (ctx: RuntimeContext) => string,\n      childTrie: string | null = null,\n      mapper?: (data: StorageResult<Type>, ctx: RuntimeContext) => T,\n    ): Observable<unknown extends T ? StorageResult<Type> : T> =>\n      pinnedBlocks$.pipe(\n        take(1),\n        mergeMap(\n          (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n        ),\n        mergeMap((ctx) => {\n          const key = keyMapper(ctx)\n          const unMapped$ = upsertCachedStream(\n            hash,\n            `storage-${type}-${key}-${childTrie ?? \"\"}`,\n            _storage$(hash, withCanonicalChain, type, key, childTrie),\n          )\n\n          return mapper\n            ? upsertCachedStream(\n                hash,\n                `storage-${type}-${key}-${childTrie ?? \"\"}-dec`,\n                unMapped$.pipe(map((x) => mapper(x, ctx))),\n              )\n            : unMapped$\n        }),\n      ) as Observable<unknown extends T ? StorageResult<Type> : T>,\n  )\n\n  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery)\n  const storageQueries$ = withOperationInaccessibleRecovery(\n    withOptionalHash$(\n      withRefcount(\n        withStopRecovery(\n          pinnedBlocks$,\n          (\n            hash: string,\n            queries: Array<StorageItemInput>,\n            childTrie?: string,\n          ) => recoveralStorage$(hash, queries, childTrie ?? null, false),\n        ),\n      ),\n    ),\n  )\n\n  const header$ = withOptionalHash$(\n    withRefcount(\n      withStopRecovery(pinnedBlocks$, (hash: string) =>\n        defer(() => getHeader(hash)),\n      ),\n    ),\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  merge(runtime$, bestBlocks$).subscribe()\n\n  const eventsAt$ = (hash: string | null, canonical = false) =>\n    storage$(\n      hash,\n      canonical,\n      \"value\",\n      (ctx) => ctx.events.key,\n      null,\n      (x, ctx) => ctx.events.dec(x!),\n    )\n\n  const __call$ = commonEnhancer(lazyFollower(\"call\"))\n  const call$ = withOptionalHash$(\n    (hash: string, canonical: boolean, fn: string, args: string) =>\n      upsertCachedStream(\n        hash,\n        `call-${fn}-${args}`,\n        __call$(hash, canonical, fn, args),\n      ),\n  )\n\n  const validateTx$ = getValidateTx(withCanonicalChain(call$, false))\n\n  const innerBody$ = (hash: string) =>\n    upsertCachedStream(hash, \"body\", _body$(hash, false))\n\n  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$)\n  const trackTxWithoutEvents$ = getTrackTx(\n    pinnedBlocks$,\n    innerBody$,\n    validateTx$,\n    () => of(),\n  )\n\n  return {\n    follow$,\n    finalized$,\n    best$,\n    bestBlocks$,\n    runtime$,\n    metadata$,\n\n    header$,\n    body$,\n    call$: withCanonicalChain(call$),\n    storage$: withCanonicalChain(storage$),\n    storageQueries$,\n    eventsAt$: withCanonicalChain(eventsAt$),\n\n    trackTx$,\n    trackTxWithoutEvents$,\n    validateTx$,\n    pinnedBlocks$,\n    withRuntime,\n    getRuntimeContext$: withOptionalHash$(getRuntimeContext$),\n    unfollow,\n  }\n}\nexport type ChainHead$ = ReturnType<typeof getChainHead$>\n","import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    let isOperationLimit = false\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        ;(isOperationLimit = e instanceof OperationLimitError)\n          ? addTask(data, true)\n          : observer.error(e)\n      },\n      complete() {\n        observer.complete()\n      },\n    })\n\n    if (!subscription.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n        onEmptySlot()\n      })\n    } else if (!isOperationLimit) onEmptySlot()\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n","import { Observable, mergeMap, of, take } from \"rxjs\"\n\nexport const getWithOptionalhash$ = (\n  finalized$: Observable<string>,\n  best$: Observable<string>,\n) => {\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) => {\n      const hash$ =\n        hash === null || hash === \"finalized\"\n          ? finalized$\n          : hash === \"best\"\n            ? best$\n            : of(hash)\n\n      return hash$.pipe(\n        take(1),\n        mergeMap((h) => fn(h, ...args)),\n      )\n    }\n}\n","import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n","import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n","import {\n  Finalized,\n  FollowEventWithRuntime,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  filter,\n  mergeMap,\n  pipe,\n  switchMap,\n  take,\n  throwError,\n} from \"rxjs\"\nimport { BlockPrunedError, NotBestBlockError } from \"../errors\"\nimport { PinnedBlocks, retryOnStopError } from \"../streams\"\nimport { isBestOrFinalizedBlock } from \"../streams/block-operations\"\n\nexport function withEnsureCanonicalChain<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  follow$: Observable<FollowEventWithRuntime>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n): (hash: string, ensureCanonical: boolean, ...args: A) => Observable<T> {\n  return (hash: string, ensureCanonical, ...args: A) => {\n    const enhancer: <T>(x: Observable<T>) => Observable<T> = ensureCanonical\n      ? pipe(\n          throwWhenPrune(\n            hash,\n            follow$.pipe(\n              retryOnStopError(),\n              filter((evt): evt is Finalized => evt.type === \"finalized\"),\n              mergeMap((evt) => evt.prunedBlockHashes),\n            ),\n          ),\n          onlyIfIsBestOrFinalized(hash, blocks$),\n        )\n      : (x) => x\n\n    return enhancer(fn(hash, ...args))\n  }\n}\n\nconst onlyIfIsBestOrFinalized =\n  <T>(hash: string, blocks$: Observable<PinnedBlocks>) =>\n  (source$: Observable<T>) =>\n    isBestOrFinalizedBlock(blocks$, hash).pipe(\n      take(1),\n      switchMap((isBest) =>\n        isBest ? source$ : throwError(() => new NotBestBlockError()),\n      ),\n    )\n\nconst throwWhenPrune =\n  <T>(hash: string, pruned$: Observable<string>) =>\n  (source$: Observable<T>) =>\n    new Observable<T>((subscriber) => {\n      const prunedSubscription = pruned$\n        .pipe(filter((h) => h === hash))\n        .subscribe(() => {\n          subscriber.error(new BlockPrunedError())\n        })\n      const sourceSubscription = source$.subscribe(subscriber)\n\n      return () => {\n        prunedSubscription.unsubscribe()\n        sourceSubscription.unsubscribe()\n      }\n    })\n","export class BlockNotPinnedError extends Error {\n  constructor() {\n    super(\"Block is not pinned\")\n    this.name = \"BlockNotPinnedError\"\n  }\n}\n\nexport class BlockPrunedError extends Error {\n  constructor() {\n    super(\"Block pruned\")\n    this.name = \"BlockPrunedError\"\n  }\n}\n\nexport class NotBestBlockError extends Error {\n  constructor() {\n    super(\"Block is not best block or finalized\")\n    this.name = \"NotBestBlockError\"\n  }\n}\n","import {\n  ChainHead,\n  FollowEventWithRuntime,\n  FollowResponse,\n  StopError,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, Subscription, noop, share } from \"rxjs\"\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse | null = null\n  let unfollow: () => void = noop\n\n  const follow$ = new Observable<FollowEventWithRuntime>((observer) => {\n    follower = chainHead(\n      true,\n      (e) => {\n        observer.next(e)\n      },\n      (e) => {\n        follower = null\n        observer.error(e)\n      },\n    )\n    unfollow = () => {\n      observer.complete()\n      follower?.unfollow()\n    }\n  }).pipe(share())\n\n  return {\n    getFollower: () => {\n      if (!follower) throw new Error(\"Missing chainHead subscription\")\n      return follower\n    },\n    unfollow: () => {\n      unfollow()\n    },\n    follow$,\n  }\n}\n\nexport const retryOnStopError =\n  <T extends { type: string }>() =>\n  (source$: Observable<T>) =>\n    new Observable<\n      | T\n      | {\n          type: \"stop-error\"\n        }\n    >((observer) => {\n      const subscription = new Subscription()\n      const subscribe = () =>\n        source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => {\n            if (e instanceof StopError) {\n              observer.next({ type: \"stop-error\" })\n              subscription.add(subscribe())\n            } else {\n              observer.error(e)\n            }\n          },\n          complete: () => observer.complete(),\n        })\n      subscription.add(subscribe())\n      return subscription\n    })\n","import {\n  getChecksumBuilder,\n  getDynamicBuilder,\n  getLookupFn,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  AccountId,\n  Codec,\n  Decoder,\n  SS58String,\n  Option,\n  V15,\n  u32,\n  Encoder,\n  _void,\n  Bytes,\n  metadata as metadataCodec,\n  V14,\n  Vector,\n  Tuple,\n  compact,\n} from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  catchError,\n  map,\n  mergeMap,\n  of,\n  shareReplay,\n  switchMap,\n  take,\n} from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\n\nexport type SystemEvent = {\n  phase:\n    | { type: \"ApplyExtrinsic\"; value: number }\n    | { type: \"Finalization\" }\n    | { type: \"Initialization\" }\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport interface RuntimeContext {\n  metadataRaw: Uint8Array\n  metadata: V15 | V14\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<Array<SystemEvent>>\n  }\n  accountId: Codec<SS58String>\n  asset: [Encoder<any>, string | null]\n}\n\nexport interface Runtime {\n  at: string\n  runtime: Observable<RuntimeContext>\n  addBlock: (block: string) => Runtime\n  deleteBlocks: (blocks: string[]) => number\n  usages: Set<string>\n}\n\nconst v15Args = toHex(u32.enc(15))\nconst opaqueMeta14 = Tuple(compact, Bytes())\nconst opaqueMeta15 = Option(Bytes())\nconst u32ListDecoder = Vector(u32).dec\n\nexport const getRuntimeCreator = (\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  finalized$: Observable<string>,\n) => {\n  const getMetadata$ = (\n    hash: string,\n  ): Observable<{ metadataRaw: Uint8Array; metadata: V14 | V15 }> => {\n    const recoverCall$ = (\n      hash: string,\n      method: string,\n      args: string,\n    ): Observable<string> =>\n      call$(hash, method, args).pipe(\n        catchError((e) => {\n          if (e instanceof BlockNotPinnedError) {\n            return finalized$.pipe(\n              take(1),\n              switchMap((newHash) => recoverCall$(newHash, method, args)),\n            )\n          }\n          throw e\n        }),\n      )\n\n    const versions = recoverCall$(hash, \"Metadata_metadata_versions\", \"\").pipe(\n      map(u32ListDecoder),\n    )\n\n    const v14 = recoverCall$(hash, \"Metadata_metadata\", \"\").pipe(\n      map((x) => {\n        const [, metadataRaw] = opaqueMeta14.dec(x)!\n        const metadata = metadataCodec.dec(metadataRaw)\n        return { metadata: metadata.metadata.value as V14, metadataRaw }\n      }),\n    )\n\n    const v15 = recoverCall$(\n      hash,\n      \"Metadata_metadata_at_version\",\n      v15Args,\n    ).pipe(\n      map((x) => {\n        const metadataRaw = opaqueMeta15.dec(x)!\n        const metadata = metadataCodec.dec(metadataRaw)\n        return { metadata: metadata.metadata.value as V15, metadataRaw }\n      }),\n    )\n\n    return versions.pipe(\n      catchError(() => of([14])),\n      mergeMap((v) => (v.includes(15) ? v15 : v14)),\n    )\n  }\n\n  return (hash: string): Runtime => {\n    const usages = new Set<string>([hash])\n\n    const runtimeContext$: Observable<RuntimeContext> = getMetadata$(hash).pipe(\n      map(({ metadata, metadataRaw }) => {\n        const checksumBuilder = getChecksumBuilder(metadata)\n        const dynamicBuilder = getDynamicBuilder(metadata)\n        const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n\n        const assetPayment = metadata.extrinsic.signedExtensions.find(\n          (x) => x.identifier === \"ChargeAssetTxPayment\",\n        )\n\n        let _assetId: null | number = null\n        if (assetPayment) {\n          const assetTxPayment = getLookupFn(metadata.lookup)(assetPayment.type)\n          if (assetTxPayment.type === \"struct\") {\n            const optionalAssetId = assetTxPayment.value.asset_id\n            if (optionalAssetId.type === \"option\")\n              _assetId = optionalAssetId.value.id\n          }\n        }\n\n        const asset: [Encoder<any>, string | null] =\n          _assetId === null\n            ? [_void.enc, null]\n            : [\n                dynamicBuilder.buildDefinition(_assetId).enc,\n                checksumBuilder.buildDefinition(_assetId),\n              ]\n\n        return {\n          asset,\n          metadataRaw,\n          metadata,\n          checksumBuilder,\n          dynamicBuilder,\n          events: {\n            key: events.enc(),\n            dec: events.dec as any,\n          },\n          accountId: AccountId(dynamicBuilder.ss58Prefix),\n        }\n      }),\n      shareReplay(1),\n    )\n\n    const result: Runtime = {\n      at: hash,\n      runtime: runtimeContext$,\n      addBlock: (block: string) => {\n        usages.add(block)\n        return result\n      },\n      deleteBlocks: (blocks) => {\n        blocks.forEach((block) => {\n          usages.delete(block)\n        })\n        return usages.size\n      },\n      usages,\n    }\n    runtimeContext$.subscribe()\n\n    return result\n  }\n}\n","import { shareLatest } from \"@/utils\"\nimport { BlockHeader } from \"@polkadot-api/substrate-bindings\"\nimport { FollowEventWithRuntime } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  Subject,\n  concatMap,\n  filter,\n  map,\n  merge,\n  of,\n  scan,\n} from \"rxjs\"\nimport { withStopRecovery } from \"../enhancers\"\nimport { retryOnStopError } from \"./follow\"\nimport { Runtime, getRuntimeCreator } from \"./get-runtime-creator\"\n\nexport interface PinnedBlock {\n  hash: string\n  number: number\n  parent: string\n  children: Set<string>\n  runtime: string\n  refCount: number\n  unpinned?: true\n  recovering: boolean\n}\n\nexport interface BlockUsageEvent {\n  type: \"blockUsage\"\n  value: { type: \"hold\"; hash: string } | { type: \"release\"; hash: string }\n}\n\nexport type PinnedBlocks = {\n  best: string\n  finalized: string\n  runtimes: Record<string, Runtime>\n  blocks: Map<string, PinnedBlock>\n  finalizedRuntime: Runtime\n  recovering: boolean\n}\n\nconst deleteBlock = (blocks: PinnedBlocks[\"blocks\"], blockHash: string) => {\n  blocks.get(blocks.get(blockHash)!.parent)?.children.delete(blockHash)\n  blocks.delete(blockHash)\n}\n\nconst getBlocksToUnpin = (blocks: PinnedBlocks, pruned: string[]) => {\n  const result: string[] = [...pruned]\n  let current = blocks.blocks.get(blocks.blocks.get(blocks.finalized)!.parent)\n\n  const trail: string[] = []\n  while (current) {\n    trail.push(current.hash)\n    if (current.refCount === 0 && !current.unpinned) {\n      result.push(current.hash)\n      current.unpinned = true\n    }\n\n    current = blocks.blocks.get(current.parent)\n  }\n\n  const deletedBlocks = [...pruned]\n  for (let i = trail.length - 1; i >= 0; i--) {\n    current = blocks.blocks.get(trail[i])!\n    if (!current.unpinned) return result\n    deletedBlocks.push(current.hash)\n  }\n\n  deletedBlocks.forEach((hash) => {\n    deleteBlock(blocks.blocks, hash)\n  })\n\n  Object.entries(blocks.runtimes)\n    .map(([key, value]) => ({\n      key,\n      usages: value.deleteBlocks(deletedBlocks),\n    }))\n    .filter((x) => x.usages === 0)\n    .map((x) => x.key)\n    .forEach((unusedRuntime) => {\n      delete blocks.runtimes[unusedRuntime]\n    })\n  return result\n}\n\nexport const getPinnedBlocks$ = (\n  follow$: Observable<FollowEventWithRuntime>,\n  getHeader: (hash: string) => Promise<BlockHeader>,\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  blockUsage$: Subject<BlockUsageEvent>,\n  onUnpin: (blocks: string[]) => void,\n) => {\n  const pinnedBlocks$: Observable<PinnedBlocks> = merge(\n    blockUsage$,\n    follow$.pipe(withInitializedNumber(getHeader), retryOnStopError()),\n  ).pipe(\n    scan((acc, event) => {\n      switch (event.type) {\n        case \"initialized\":\n          if (acc.recovering) {\n            const isConnected = event.finalizedBlockHashes.some((hash) =>\n              acc.blocks.has(hash),\n            )\n            if (!isConnected) {\n              acc = getInitialPinnedBlocks()\n            }\n          }\n\n          const [finalizedHash] = event.finalizedBlockHashes.slice(-1)\n          acc.finalized = acc.best = finalizedHash\n\n          const lastIdx = event.finalizedBlockHashes.length - 1\n          event.finalizedBlockHashes.forEach((hash, i) => {\n            if (acc.blocks.has(hash)) {\n              acc.blocks.get(hash)!.recovering = false\n            } else {\n              acc.blocks.set(hash, {\n                hash: hash,\n                parent:\n                  i === 0\n                    ? event.parentHash\n                    : event.finalizedBlockHashes[i - 1],\n                children: new Set(\n                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]],\n                ),\n                runtime: hash,\n                refCount: 0,\n                number: event.number + i,\n                recovering: false,\n              })\n            }\n          })\n\n          const finalizedRuntime = Object.values(acc.runtimes).find((runtime) =>\n            runtime.usages.has(finalizedHash),\n          )\n\n          acc.finalizedRuntime =\n            finalizedRuntime ??\n            (acc.runtimes[finalizedHash] = getRuntime(finalizedHash))\n\n          return acc\n\n        case \"stop-error\":\n          for (const block of acc.blocks.values()) {\n            block.recovering = true\n          }\n          acc.recovering = true\n\n          return acc\n\n        case \"newBlock\": {\n          const { parentBlockHash: parent, blockHash: hash } = event\n          if (acc.blocks.has(hash)) {\n            acc.blocks.get(hash)!.recovering = false\n          } else {\n            const parentNode = acc.blocks.get(parent)!\n            parentNode.children.add(hash)\n            if (event.newRuntime) {\n              acc.runtimes[hash] = getRuntime(hash)\n              acc.runtimes[hash].runtime.subscribe()\n            }\n            const block = {\n              hash,\n              number: parentNode.number + 1,\n              parent: parent,\n              children: new Set<string>(),\n              runtime: event.newRuntime ? hash : parentNode.runtime,\n              refCount: 0,\n              recovering: false,\n            }\n            acc.blocks.set(hash, block)\n            acc.runtimes[block.runtime].addBlock(hash)\n          }\n\n          return acc\n        }\n\n        case \"bestBlockChanged\": {\n          if (acc.recovering) {\n            for (const [hash, block] of acc.blocks) {\n              if (block.recovering) {\n                deleteBlock(acc.blocks, hash)\n              }\n            }\n            acc.recovering = false\n          }\n          acc.best = event.bestBlockHash\n          return acc\n        }\n\n        case \"finalized\": {\n          acc.finalized = event.finalizedBlockHashes.slice(-1)[0]\n          acc.finalizedRuntime =\n            acc.runtimes[acc.blocks.get(acc.finalized)!.runtime]\n\n          // TODO: remove this once https://github.com/paritytech/polkadot-sdk/issues/3658 is fixed\n          const actuallyPruned = [...new Set(event.prunedBlockHashes)]\n          onUnpin(getBlocksToUnpin(acc, actuallyPruned))\n          return acc\n        }\n\n        case \"blockUsage\": {\n          if (!acc.blocks.has(event.value.hash)) return acc\n\n          const block = acc.blocks.get(event.value.hash)!\n          block.refCount += event.value.type === \"hold\" ? 1 : -1\n          if (\n            block.refCount === 0 &&\n            block.number < acc.blocks.get(acc.finalized)!.number &&\n            !block.recovering\n          ) {\n            block.unpinned = true\n            onUnpin([block.hash])\n          }\n          return acc\n        }\n      }\n    }, getInitialPinnedBlocks()),\n    filter((x) => !!x.finalizedRuntime.runtime),\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  const getRuntime = getRuntimeCreator(\n    withStopRecovery(pinnedBlocks$, call$),\n    pinnedBlocks$.pipe(map((v) => v.finalized)),\n  )\n\n  return pinnedBlocks$\n}\n\nconst getInitialPinnedBlocks = (): PinnedBlocks => ({\n  best: \"\",\n  finalized: \"\",\n  runtimes: {},\n  blocks: new Map(),\n  finalizedRuntime: {} as Runtime,\n  recovering: false,\n})\n\nconst withInitializedNumber =\n  (getHeader: (hash: string) => Promise<BlockHeader>) =>\n  (source$: Observable<FollowEventWithRuntime>) =>\n    source$.pipe(\n      concatMap((event) => {\n        return event.type !== \"initialized\"\n          ? of(event)\n          : getHeader(event.finalizedBlockHashes[0]).then((header) => ({\n              ...event,\n              number: header.number,\n              parentHash: header.parentHash,\n            }))\n      }),\n    )\n","import { Observable, distinctUntilChanged, filter, map, takeWhile } from \"rxjs\"\nimport { PinnedBlocks } from \"./pinned-blocks\"\n\nexport const isBestOrFinalizedBlock = (\n  blocks$: Observable<PinnedBlocks>,\n  blockHash: string,\n) =>\n  blocks$.pipe(\n    takeWhile((b) => b.blocks.has(blockHash)),\n    distinctUntilChanged(\n      (a, b) => a.finalized === b.finalized && a.best === b.best,\n    ),\n    filter(\n      (x) => x.blocks.get(x.best)!.number >= x.blocks.get(blockHash)!.number,\n    ),\n    map((pinned): \"best\" | \"finalized\" | null => {\n      const { number } = pinned.blocks.get(blockHash)!\n      let current = pinned.blocks.get(pinned.best)!\n      let isFinalized = pinned.finalized === current.hash\n      while (current.number > number) {\n        current = pinned.blocks.get(current.parent)!\n        isFinalized = isFinalized || pinned.finalized === current.hash\n      }\n      if (isFinalized) return \"finalized\"\n      return current.hash === blockHash ? \"best\" : null\n    }),\n    distinctUntilChanged(),\n    takeWhile((x) => x !== \"finalized\", true),\n  )\n","import { Observable, ObservedValueOf, Subscription } from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { PinnedBlocks } from \"../streams\"\n\nexport function withStopRecovery<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n) {\n  return (hash: string, ...args: A) => {\n    const source$ = fn(hash, ...args)\n\n    return new Observable<ObservedValueOf<typeof source$>>((observer) => {\n      let sourceSub: Subscription | null = null\n      let isSubscribed = false\n      const performSourceSub = () => {\n        if (isSubscribed) return\n        isSubscribed = true\n        sourceSub = source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => observer.error(e),\n          complete: () => observer.complete(),\n        })\n        sourceSub.add(() => {\n          isSubscribed = false\n          sourceSub = null\n        })\n      }\n\n      let isRecovering = false\n      const blockSub = blocks$.subscribe({\n        next: (v) => {\n          const block = v.blocks.get(hash)\n          if (!block) {\n            // This branch conflicts with BlockPrunedError, as the block might disappear when it gets pruned\n            // We can avoid this conflict by checking that we're actually recovering.\n            if (isRecovering) {\n              observer.error(new BlockNotPinnedError())\n            }\n          } else if (block.recovering) {\n            // Pause while it's recovering, as we don't know if the block is there\n            sourceSub?.unsubscribe()\n          } else {\n            performSourceSub()\n          }\n          isRecovering = v.recovering\n        },\n        error: (e) => observer.error(e),\n      })\n\n      return () => {\n        blockSub.unsubscribe()\n        sourceSub?.unsubscribe()\n      }\n    })\n  }\n}\n","import { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\nimport { Observable, catchError, concatMap, throwError, timer } from \"rxjs\"\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const withOperationInaccessibleRecovery =\n  <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n  (...args: Args): Observable<T> =>\n    operable(fn(...args))\n","import {\n  FollowResponse,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, mergeAll } from \"rxjs\"\nimport { getWithRecovery } from \"./enhancers\"\n\nexport const getRecoveralStorage$ = (\n  getFollower: () => FollowResponse,\n  withRecovery: ReturnType<typeof getWithRecovery>[\"withRecovery\"],\n) => {\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            if (nDiscarded === 0) return\n\n            observer.next(\n              recoveralStorage$(\n                hash,\n                queries.slice(-nDiscarded),\n                childTrie,\n                true,\n              ),\n            )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  return recoveralStorage$\n}\n","import {\n  Observable,\n  distinct,\n  filter,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeUntil,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./streams\"\nimport { HexString } from \"@polkadot-api/substrate-bindings\"\n\nexport type AnalyzedBlock = {\n  hash: HexString\n  found:\n    | {\n        type: true\n        index: number\n        events: any\n      }\n    | {\n        type: false\n        isValid: boolean\n      }\n}\n\nexport const getTrackTx = (\n  blocks$: Observable<PinnedBlocks>,\n  getBody: (block: string) => Observable<string[]>, // Returns an observable that should emit just once and complete\n  getIsValid: (block: string, tx: string) => Observable<boolean>, // Returns an observable that should emit just once and complete\n  getEvents: (block: string) => Observable<any>, // Returns an observable that should emit just once and complete\n) => {\n  const whileBlockPresent = <TT>(\n    hash: string,\n  ): (<T = TT>(base: Observable<T>) => Observable<T>) =>\n    takeUntil(blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))))\n\n  const analyzeBlock = (\n    hash: string,\n    tx: string,\n    alreadyPresent: boolean,\n  ): Observable<AnalyzedBlock> => {\n    if (alreadyPresent)\n      return of({ hash, found: { type: false, isValid: true } })\n\n    const whilePresent = whileBlockPresent(hash)\n    return getBody(hash).pipe(\n      mergeMap((txs) => {\n        const index = txs.indexOf(tx)\n        return index > -1\n          ? whilePresent(getEvents(hash)).pipe(\n              map((events) => ({\n                hash,\n                found: {\n                  type: true as true,\n                  index,\n                  events,\n                },\n              })),\n            )\n          : getIsValid(hash, tx).pipe(\n              map((isValid) => ({\n                hash,\n                found: { type: false as false, isValid },\n              })),\n            )\n      }),\n      whilePresent,\n    )\n  }\n\n  const findInBranch = (\n    hash: string,\n    tx: string,\n    alreadyPresent: Set<string>,\n  ): Observable<AnalyzedBlock> =>\n    analyzeBlock(hash, tx, alreadyPresent.has(hash)).pipe(\n      mergeMap((analyzed) => {\n        const { found } = analyzed\n        return found.type || !found.isValid\n          ? of(analyzed)\n          : blocks$.pipe(\n              whileBlockPresent(hash),\n              mergeMap((x) => x.blocks.get(hash)!.children),\n              distinct(),\n              mergeMap((hash) => findInBranch(hash, tx, alreadyPresent)),\n            )\n      }),\n    )\n\n  return (tx: string): Observable<AnalyzedBlock> =>\n    blocks$.pipe(\n      take(1),\n      mergeMap((x) => findInBranch(x.finalized, tx, new Set(x.blocks.keys()))),\n    )\n}\n","import { Observable, map } from \"rxjs\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\n\nconst external = new Uint8Array([2])\n\nconst getValidateTxArgs = (tx: string, hash: string) =>\n  toHex(mergeUint8(external, fromHex(tx), fromHex(hash)))\n\nexport const getValidateTx =\n  (\n    call$: (\n      hash: string | null,\n      fnName: string,\n      parameters: string,\n    ) => Observable<string>,\n  ) =>\n  (blockHash: string, tx: string) =>\n    call$(\n      blockHash,\n      \"TaggedTransactionQueue_validate_transaction\",\n      getValidateTxArgs(tx, blockHash),\n    ).pipe(map((x) => x.startsWith(\"0x00\")))\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<never>((observer) =>\n      baseTransaction(transaction, (e) => {\n        observer.error(e)\n      }),\n    )\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nexport type * from \"./chainHead\"\n\nimport { getChainHead$ } from \"./chainHead\"\nimport getBroadcastTx$ from \"./tx\"\n\nexport const getObservableClient = ({\n  chainHead,\n  transaction,\n  destroy,\n}: SubstrateClient) => ({\n  chainHead$: () => getChainHead$(chainHead),\n  broadcastTx$: getBroadcastTx$(transaction),\n  destroy,\n})\n"],"mappings":"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","names":["import_rxjs","import_rxjs","import_substrate_bindings","import_substrate_client","import_rxjs","import_rxjs","import_rxjs","import_rxjs","import_rxjs","import_substrate_client","import_rxjs","import_rxjs","hash","metadataCodec","import_rxjs","import_rxjs","import_rxjs","import_substrate_client","import_rxjs","import_rxjs","import_rxjs","hash","import_rxjs","import_utils","withCanonicalChain","import_rxjs"]}