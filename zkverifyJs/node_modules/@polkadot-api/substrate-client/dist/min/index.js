"use strict";var k=Object.defineProperty;var te=Object.getOwnPropertyDescriptor;var oe=Object.getOwnPropertyNames;var ne=Object.prototype.hasOwnProperty;var ie=(r,e,t)=>e in r?k(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var se=(r,e)=>{for(var t in e)k(r,t,{get:e[t],enumerable:!0})},ae=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of oe(e))!ne.call(r,o)&&o!==t&&k(r,o,{get:()=>e[o],enumerable:!(n=te(e,o))||n.enumerable});return r};var ce=r=>ae(k({},"__esModule",{value:!0}),r);var B=(r,e,t)=>ie(r,typeof e!="symbol"?e+"":e,t);var de={};se(de,{AbortError:()=>ee.AbortError,DestroyedError:()=>S,DisjointError:()=>w,OperationError:()=>x,OperationInaccessibleError:()=>O,OperationLimitError:()=>C,RpcError:()=>I,StopError:()=>P,createClient:()=>me});module.exports=ce(de);var H=require("@polkadot-api/utils"),v=r=>(...e)=>new Promise((t,n)=>{let o=H.noop,[s,m]=e[e.length-1]instanceof AbortSignal?[e.slice(0,e.length-1),e[e.length-1]]:[e],u=()=>{o(),n(new H.AbortError)};m?.addEventListener("abort",u,{once:!0});let R=f=>p=>{o=H.noop,m?.removeEventListener("abort",u),f(p)};o=r(R(t),R(n),...s)});function z(){let r=()=>{},e=()=>{};return{promise:new Promise((n,o)=>{r=n,e=o}),res:r,rej:e}}var y=()=>{};var W=()=>{let r=new Map;return{has:r.has.bind(r),subscribe(e,t){r.set(e,t)},unsubscribe(e){r.delete(e)},next(e,t){r.get(e)?.next(t)},error(e,t){let n=r.get(e);n&&(r.delete(e),n.error(t))},errorAll(e){let t=[...r.values()];r.clear(),t.forEach(n=>{n.error(e)})}}};var b={body:"",call:"",continue:"",follow:"",header:"",stopOperation:"",storage:"",unfollow:"",unpin:"",followEvent:""},F={chainName:"",genesisHash:"",properties:""},A={broadcast:"",stop:""},pe={submitAndWatch:"",unwatch:""};Object.entries({chainHead:b,chainSpec:F,transaction:A,transactionWatch:pe}).forEach(([r,e])=>{Object.keys(e).forEach(t=>{e[t]=`${r}_v1_${t}`})});var M=r=>(e,t)=>{let n=r(A.broadcast,[e],{onSuccess:o=>{n=o===null?y:()=>{r(A.stop,[o])},o===null&&t(new Error("Max # of broadcasted transactions has been reached"))},onError:t});return()=>{n()}};var P=class extends Error{constructor(){super("ChainHead stopped"),this.name="StopError"}},w=class extends Error{constructor(){super("ChainHead disjointed"),this.name="DisjointError"}},C=class extends Error{constructor(){super("ChainHead operations limit reached"),this.name="OperationLimitError"}},x=class extends Error{constructor(e){super(e),this.name="OperationError"}},O=class extends Error{constructor(){super("ChainHead operation inaccessible"),this.name="OperationInaccessibleError"}};var j=(r,e)=>t=>v((n,o,...s)=>{let m=!0,u=()=>{m=!1},[R,f]=e(...s);return t(r,R,{onSuccess:(p,l)=>{if(p.result==="limitReached")return o(new C);let{operationId:a}=p,c=()=>{t(b.stopOperation,[a])};if(!m)return c();let i=y,g=d=>{m=!1,i(),n(d)},h=d=>{m=!1,i(),o(d)};i=l(a,{next:d=>{let E=d;E.event==="operationError"?o(new x(E.error)):E.event==="operationInaccessible"?o(new O):f(d,g,h)},error:h}),u=()=>{m&&(i(),c())}},onError:o}),()=>{u()}});var N=j(b.body,r=>[[r],(e,t)=>{t(e.value)}]);var G=j(b.call,(r,e,t)=>[[r,e,t],(n,o)=>{o(n.output)}]);var K=r=>e=>new Promise((t,n)=>{r(b.header,[e],{onSuccess:t,onError:n})});var U=require("@polkadot-api/utils");var L=r=>(e,t,n,o,s,m,u)=>{if(t.length===0)return m(),U.noop;let R=!0,f=()=>{R=!1};return r(b.storage,[e,t,n],{onSuccess:(p,l)=>{if(p.result==="limitReached"||p.discardedItems===t.length)return s(new C);let{operationId:a}=p,c=()=>{r(b.stopOperation,[a])};if(!R)return c();let i=l(p.operationId,{next:d=>{switch(d.event){case"operationStorageItems":{o(d.items);break}case"operationStorageDone":{h();break}case"operationError":{g(new x(d.error));break}case"operationInaccessible":{g(new O);break}default:r(b.continue,[d.operationId])}},error:s});f=()=>{i(),r(b.stopOperation,[p.operationId])};let g=d=>{f=U.noop,i(),s(d)},h=()=>{f=U.noop,i(),m()};u(p.discardedItems)},onError:s}),()=>{f()}};var Q=r=>{let e=L(r);return v((t,n,o,s,m,u)=>{let R=s.startsWith("descendants"),f=R?[]:null,l=e(o,[{key:m,type:s}],u??null,R?a=>{f.push(a)}:a=>{f=a[0]?.[s]},n,()=>{try{t(R?f.flat():f)}catch(a){n(a)}},a=>{a>0&&(l(),n(new C))});return l})};var V=r=>e=>e.length>0?new Promise((t,n)=>{r(b.unpin,[e],{onSuccess(){t()},onError:n})}):Promise.resolve();var S=class extends Error{constructor(){super("Client destroyed"),this.name="DestroyedError"}};function le(r){return r.operationId!==void 0}function $(r){return(e,t,n)=>{let o=W(),s=new Set,m=z(),u=m.promise,R=i=>{if(le(i))return o.has(i.operationId)||console.warn("Uknown operationId on",i),o.next(i.operationId,i);if(i.event!=="stop"){if(i.event==="initialized")return t({type:i.event,finalizedBlockHashes:"finalizedBlockHash"in i?[i.finalizedBlockHash]:i.finalizedBlockHashes,finalizedBlockRuntime:i.finalizedBlockRuntime});let{event:g,...h}=i;return t({type:g,...h})}n(new P),a(!1)},f=i=>{n(i),a(!(i instanceof S))},p=(i,g)=>{let h=g(i,{next:R,error:f});a=(d=!0)=>{u=null,a=y,h(),d&&r(b.unfollow,[i]),o.errorAll(new w),s.forEach(E=>{E()}),s.clear()},u=i,m.res(i)},l=i=>{i instanceof S?a(!1):n(i),u=null,m.res(i)},a=r(b.follow,[e],{onSuccess:p,onError:l}),c=(i,g,h)=>{let d=()=>{h?.onError(new w)};if(u===null)return d(),y;let E=T=>{if(!h)return r(i,[T,...g]);s.add(d);let _=(q,J)=>u===null?(J.error(new w),y):(o.subscribe(q,J),()=>{o.unsubscribe(q)}),re=r(i,[T,...g],{onSuccess:q=>{s.delete(d),h.onSuccess(q,_)},onError:q=>{s.delete(d),h.onError(q)}});return()=>{s.delete(d),re()}};if(typeof u=="string")return E(u);let D=y;return u.then(T=>{if(T instanceof Error)return d();u&&(D=E(T))}),()=>{D()}};return{unfollow(){a(),u=null},body:N(c),call:G(c),header:K(c),storage:Q(c),storageSubscription:L(c),unpin:V(c),_request:c}}}var I=class extends Error{constructor(t){super(t.message);B(this,"code");B(this,"data");this.code=t.code,this.data=t.data,this.name="RpcError"}};var ue=1,X=r=>{let e=ue++,t=new Map,n=W(),o=null,s=(p,l,a)=>{o.send(JSON.stringify({jsonrpc:"2.0",id:p,method:l,params:a}))};function m(p){try{let l,a,c,i,g;if({id:l,result:a,error:c,params:i}=JSON.parse(p),l){let E=t.get(l);return E?(t.delete(l),c?E.onError(new I(c)):E.onSuccess(a,(D,T)=>{let _=D;return n.subscribe(_,T),()=>{n.unsubscribe(_)}})):void 0}if({subscription:g,result:a,error:c}=i,!g||!c&&!Object.hasOwn(i,"result"))throw 0;let d=g;c?n.error(d,new I(c)):n.next(d,a)}catch(l){console.warn("Error parsing incomming message: "+p),console.error(l)}}o=r(m);let u=()=>{o?.disconnect(),o=null,n.errorAll(new S),t.forEach(p=>p.onError(new S)),t.clear()},R=1;return{request:(p,l,a)=>{if(!o)throw new Error("Not connected");let c=`${e}-${R++}`;return a&&t.set(c,a),s(c,p,l),()=>{t.delete(c)}},disconnect:u}};var Y=r=>{let e=v((n,o,s,m)=>r(s,m,{onSuccess:n,onError:o})),t=null;return async()=>t||(t=Promise.all([e(F.chainName,[]),e(F.genesisHash,[]),e(F.properties,[])]).then(([n,o,s])=>({name:n,genesisHash:o,properties:s})))};var Z=(r,e)=>t=>{let n={},o=null;return(s,...m)=>{if(o)return o(s,...m);let u=!0,R=()=>{u=!1};return r.then(f=>{if(o=(l,...a)=>{let c=n[l]??l;return f.has(c)?e(c,...a):(a[1]?.onError(new Error(`Unsupported method ${c}`)),y)},f.has(s))return;let p=s.split("_");if(p[1]==="v1"){if(p[1]="unstable",f.has(p.join("_")))Object.values(t).forEach(l=>{n[l]=l.replace("_v1_","_unstable_")});else if(p[0]==="transaction"){let l,a,c=["transactionWatch","transaction"].find(i=>(a=["v1","unstable"].find(g=>f.has(l=`${i}_${g}_unwatch`)),!!a));c&&(n[t.broadcast]=`${c}_${a}_submitAndWatch`,n[t.stop]=l)}}}).then(()=>{u&&(R=o(s,...m))}),()=>{R()}}};var ee=require("@polkadot-api/utils"),me=r=>{let e=X(r),t=v((s,m,u,R)=>e.request(u,R,{onSuccess:s,onError:m})),n=t("rpc_methods",[]).then(s=>new Set(Array.isArray(s)?s:s.methods),()=>new Set),o=Z(n,e.request);return{chainHead:$(o(b)),transaction:M(o(A)),getChainSpecData:Y(o(F)),destroy:()=>{e.disconnect()},request:t,_request:e.request}};
//# sourceMappingURL=index.js.map