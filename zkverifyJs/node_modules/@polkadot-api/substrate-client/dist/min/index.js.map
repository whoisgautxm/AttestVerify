{"version":3,"sources":["../../src/index.ts","../../src/internal-utils/abortablePromiseFn.ts","../../src/internal-utils/deferred-promise.ts","../../src/internal-utils/noop.ts","../../src/internal-utils/subscriptions-manager.ts","../../src/methods.ts","../../src/transaction/transaction.ts","../../src/chainhead/errors.ts","../../src/chainhead/operation-promise.ts","../../src/chainhead/body.ts","../../src/chainhead/call.ts","../../src/chainhead/header.ts","../../src/chainhead/storage-subscription.ts","../../src/chainhead/storage.ts","../../src/chainhead/unpin.ts","../../src/client/DestroyedError.ts","../../src/chainhead/chainhead.ts","../../src/client/RpcError.ts","../../src/client/createClient.ts","../../src/chainspec.ts","../../src/request-compatibility-enhancer.ts"],"sourcesContent":["import type { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport { getTransaction } from \"./transaction/transaction\"\nimport { getChainHead } from \"./chainhead\"\nimport {\n  ClientRequest,\n  ClientRequestCb,\n  createClient as createRawClient,\n} from \"./client\"\nimport type { ChainHead } from \"./chainhead\"\nimport type { Transaction } from \"./transaction\"\nimport { UnsubscribeFn } from \"./common-types\"\nimport { abortablePromiseFn } from \"./internal-utils\"\nimport { ChainSpecData, createGetChainSpec } from \"./chainspec\"\nimport { getCompatibilityEnhancer } from \"./request-compatibility-enhancer\"\nimport { chainHead, chainSpec, transaction } from \"./methods\"\n\nexport { AbortError } from \"@polkadot-api/utils\"\nexport type * from \"@polkadot-api/json-rpc-provider\"\n\nexport type * from \"./common-types\"\nexport type * from \"./client\"\nexport type * from \"./transaction\"\nexport type * from \"./chainhead\"\nexport type * from \"./chainspec\"\n\nexport { RpcError, DestroyedError } from \"./client\"\nexport {\n  StopError,\n  DisjointError,\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./chainhead\"\n\nexport interface SubstrateClient {\n  chainHead: ChainHead\n  transaction: Transaction\n  destroy: UnsubscribeFn\n  getChainSpecData: () => Promise<ChainSpecData>\n  request: <T>(\n    method: string,\n    params: any[],\n    abortSignal?: AbortSignal,\n  ) => Promise<T>\n  _request: <Reply, Notification>(\n    method: string,\n    params: any[],\n    cb?: ClientRequestCb<Reply, Notification>,\n  ) => UnsubscribeFn\n}\n\nexport const createClient = (provider: JsonRpcProvider): SubstrateClient => {\n  const client = createRawClient(provider)\n\n  const request = abortablePromiseFn(\n    <T>(\n      onSuccess: (value: T) => void,\n      onError: (e: any) => void,\n      method: string,\n      params: any[],\n    ) => client.request(method, params, { onSuccess, onError }),\n  )\n\n  const rpcMethods: Promise<Set<string>> = request<\n    { methods: Array<string> } | Array<string>\n  >(\"rpc_methods\", []).then(\n    (x) => new Set(Array.isArray(x) ? x : x.methods),\n    () => new Set(),\n  )\n\n  const compatibilityEnhancer = getCompatibilityEnhancer(\n    rpcMethods,\n    client.request,\n  )\n\n  return {\n    chainHead: getChainHead(\n      compatibilityEnhancer(chainHead) as ClientRequest<any, any>,\n    ),\n    transaction: getTransaction(\n      compatibilityEnhancer(transaction) as ClientRequest<string, any>,\n    ),\n    getChainSpecData: createGetChainSpec(\n      compatibilityEnhancer(chainSpec) as ClientRequest<any, any>,\n    ),\n    destroy: () => {\n      client.disconnect()\n    },\n    request,\n    _request: client.request,\n  }\n}\n","import { AbortError, noop } from \"@polkadot-api/utils\"\nimport { AbortablePromiseFn } from \"../common-types\"\n\nexport const abortablePromiseFn =\n  <T, A extends Array<any>>(\n    fn: (\n      ...args: [...[res: (x: T) => void, rej: (e: any) => void], ...A]\n    ) => () => void,\n  ): AbortablePromiseFn<A, T> =>\n  (...args): Promise<T> =>\n    new Promise((res, rej) => {\n      let cancel = noop\n\n      const [actualArgs, abortSignal] =\n        args[args.length - 1] instanceof AbortSignal\n          ? ([args.slice(0, args.length - 1), args[args.length - 1]] as [\n              A,\n              AbortSignal,\n            ])\n          : ([args] as unknown as [A])\n\n      const onAbort = () => {\n        cancel()\n        rej(new AbortError())\n      }\n\n      abortSignal?.addEventListener(\"abort\", onAbort, { once: true })\n\n      const withCleanup =\n        <T>(fn: (x: T) => void): ((x: T) => void) =>\n        (x) => {\n          cancel = noop\n          abortSignal?.removeEventListener(\"abort\", onAbort)\n          fn(x)\n        }\n\n      cancel = fn(...[withCleanup(res), withCleanup(rej), ...actualArgs])\n    })\n","export interface DeferredPromise<T> {\n  promise: Promise<T>\n  res: (value: T) => void\n  rej: (err: Error) => void\n}\n\nexport function deferred<T>(): DeferredPromise<T> {\n  let res: (value: T) => void = () => {}\n  let rej: (err: Error) => void = () => {}\n\n  const promise = new Promise<T>((_res, _rej) => {\n    res = _res\n    rej = _rej\n  })\n\n  return { promise, res, rej }\n}\n","export const noop = (): void => {}\n","export interface Subscriber<T> {\n  next: (data: T) => void\n  error: (e: Error) => void\n}\n\nexport const getSubscriptionsManager = <T>() => {\n  const subscriptions = new Map<string, Subscriber<T>>()\n\n  return {\n    has: subscriptions.has.bind(subscriptions),\n    subscribe(id: string, subscriber: Subscriber<T>) {\n      subscriptions.set(id, subscriber)\n    },\n    unsubscribe(id: string) {\n      subscriptions.delete(id)\n    },\n    next(id: string, data: T) {\n      subscriptions.get(id)?.next(data)\n    },\n    error(id: string, e: Error) {\n      const subscriber = subscriptions.get(id)\n      if (subscriber) {\n        subscriptions.delete(id)\n        subscriber.error(e)\n      }\n    },\n    errorAll(e: Error) {\n      const subscribers = [...subscriptions.values()]\n      subscriptions.clear()\n      subscribers.forEach((s) => {\n        s.error(e)\n      })\n    },\n  }\n}\n\nexport type SubscriptionManager<T> = ReturnType<\n  typeof getSubscriptionsManager<T>\n>\n","export const chainHead = {\n  body: \"\",\n  call: \"\",\n  continue: \"\",\n  follow: \"\",\n  header: \"\",\n  stopOperation: \"\",\n  storage: \"\",\n  unfollow: \"\",\n  unpin: \"\",\n  followEvent: \"\",\n}\n\nexport const chainSpec = {\n  chainName: \"\",\n  genesisHash: \"\",\n  properties: \"\",\n}\n\nexport const transaction = {\n  broadcast: \"\",\n  stop: \"\",\n}\n\nexport const transactionWatch = {\n  submitAndWatch: \"\",\n  unwatch: \"\",\n}\n\nObject.entries({ chainHead, chainSpec, transaction, transactionWatch }).forEach(\n  ([fnGroupName, methods]) => {\n    Object.keys(methods).forEach((methodName) => {\n      ;(methods as any)[methodName] = `${fnGroupName}_v1_${methodName}`\n    })\n  },\n)\n","import { noop } from \"@/internal-utils\"\nimport { type ClientRequest } from \"../client\"\nimport { transaction } from \"@/methods\"\n\nexport const getTransaction =\n  (request: ClientRequest<string, any>) =>\n  (tx: string, error: (e: Error) => void) => {\n    let cancel = request(transaction.broadcast, [tx], {\n      onSuccess: (subscriptionId) => {\n        cancel =\n          subscriptionId === null\n            ? noop\n            : () => {\n                request(transaction.stop, [subscriptionId])\n              }\n\n        if (subscriptionId === null) {\n          error(new Error(\"Max # of broadcasted transactions has been reached\"))\n        }\n      },\n      onError: error,\n    })\n\n    return () => {\n      cancel()\n    }\n  }\n","export class StopError extends Error {\n  constructor() {\n    super(\"ChainHead stopped\")\n    this.name = \"StopError\"\n  }\n}\n\nexport class DisjointError extends Error {\n  constructor() {\n    super(\"ChainHead disjointed\")\n    this.name = \"DisjointError\"\n  }\n}\n\nexport class OperationLimitError extends Error {\n  constructor() {\n    super(\"ChainHead operations limit reached\")\n    this.name = \"OperationLimitError\"\n  }\n}\n\nexport class OperationError extends Error {\n  constructor(error: string) {\n    super(error)\n    this.name = \"OperationError\"\n  }\n}\n\nexport class OperationInaccessibleError extends Error {\n  constructor() {\n    super(\"ChainHead operation inaccessible\")\n    this.name = \"OperationInaccessibleError\"\n  }\n}\n","import { abortablePromiseFn, noop } from \"@/internal-utils\"\nimport {\n  CommonOperationEventsRpc,\n  OperationResponseRpc,\n} from \"./json-rpc-types\"\nimport {\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./errors\"\nimport { ClientInnerRequest } from \"./public-types\"\nimport { chainHead } from \"@/methods\"\n\nexport const createOperationPromise =\n  <I extends { operationId: string; event: string }, O, A extends Array<any>>(\n    operationName: string,\n    factory: (\n      ...args: A\n    ) => [\n      Array<any>,\n      (e: I, res: (x: O) => void, rej: (e: Error) => void) => void,\n    ],\n  ) =>\n  (\n    request: ClientInnerRequest<\n      OperationResponseRpc,\n      I | CommonOperationEventsRpc\n    >,\n  ) =>\n    abortablePromiseFn<O, A>((res, rej, ...args) => {\n      let isRunning = true\n      let cancel = () => {\n        isRunning = false\n      }\n\n      const [requestArgs, logicCb] = factory(...args)\n      request(operationName, requestArgs, {\n        onSuccess: (response, followSubscription) => {\n          if (response.result === \"limitReached\")\n            return rej(new OperationLimitError())\n\n          const { operationId } = response\n          const stopOperation = () => {\n            request(chainHead.stopOperation, [operationId])\n          }\n\n          if (!isRunning) return stopOperation()\n\n          let done = noop\n          const _res = (x: O) => {\n            isRunning = false\n            done()\n            res(x)\n          }\n          const _rej = (x: Error) => {\n            isRunning = false\n            done()\n            rej(x)\n          }\n\n          done = followSubscription(operationId, {\n            next: (e) => {\n              const _e = e as CommonOperationEventsRpc\n              if (_e.event === \"operationError\")\n                rej(new OperationError(_e.error))\n              else if (_e.event === \"operationInaccessible\")\n                rej(new OperationInaccessibleError())\n              else logicCb(e as I, _res, _rej)\n            },\n            error: _rej,\n          })\n\n          cancel = () => {\n            if (isRunning) {\n              done()\n              stopOperation()\n            }\n          }\n        },\n        onError: rej,\n      })\n\n      return () => {\n        cancel()\n      }\n    })\n","import { chainHead } from \"@/methods\"\nimport type { OperationBodyDoneRpc } from \"./json-rpc-types\"\nimport { createOperationPromise } from \"./operation-promise\"\n\nexport const createBodyFn = createOperationPromise(\n  chainHead.body,\n  (hash: string) => [\n    [hash],\n    (e: OperationBodyDoneRpc, res: (x: Array<string>) => void) => {\n      res(e.value)\n    },\n  ],\n)\n","import { chainHead } from \"@/methods\"\nimport type { OperationCallDoneRpc } from \"./json-rpc-types\"\nimport { createOperationPromise } from \"./operation-promise\"\n\nexport const createCallFn = createOperationPromise(\n  chainHead.call,\n  (hash: string, fnName: string, callParameters: string) => [\n    [hash, fnName, callParameters],\n    (e: OperationCallDoneRpc, res: (output: string) => void) => {\n      res(e.output)\n    },\n  ],\n)\n","import { chainHead } from \"@/methods\"\nimport { ClientInnerRequest } from \"./public-types\"\n\nexport const createHeaderFn =\n  (request: ClientInnerRequest<string, unknown>) => (hash: string) =>\n    new Promise<string>((res, rej) => {\n      request(chainHead.header, [hash], {\n        onSuccess: res,\n        onError: rej,\n      })\n    })\n","import { noop } from \"@polkadot-api/utils\"\nimport {\n  ClientInnerRequest,\n  FollowResponse,\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"..\"\nimport {\n  CommonOperationEventsRpc,\n  LimitReachedRpc,\n  OperationStorageDoneRpc,\n  OperationStorageItemsRpc,\n  OperationWaitingForContinueRpc,\n  OperationStorageStartedRpc,\n} from \"./json-rpc-types\"\nimport { chainHead } from \"@/methods\"\n\nexport const createStorageCb =\n  (\n    request: ClientInnerRequest<\n      OperationStorageStartedRpc | LimitReachedRpc,\n      | CommonOperationEventsRpc\n      | OperationStorageItemsRpc\n      | OperationStorageDoneRpc\n      | OperationWaitingForContinueRpc\n    >,\n  ): FollowResponse[\"storageSubscription\"] =>\n  (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {\n    if (inputs.length === 0) {\n      onDone()\n      return noop\n    }\n\n    let isRunning = true\n    let cancel = () => {\n      isRunning = false\n    }\n\n    request(chainHead.storage, [hash, inputs, childTrie], {\n      onSuccess: (response, followSubscription) => {\n        if (\n          response.result === \"limitReached\" ||\n          response.discardedItems === inputs.length\n        )\n          return onError(new OperationLimitError())\n\n        const { operationId } = response\n        const stopOperation = () => {\n          request(chainHead.stopOperation, [operationId])\n        }\n\n        if (!isRunning) return stopOperation()\n\n        const doneListening = followSubscription(response.operationId, {\n          next: (event) => {\n            switch (event.event) {\n              case \"operationStorageItems\": {\n                onItems(event.items)\n                break\n              }\n              case \"operationStorageDone\": {\n                _onDone()\n                break\n              }\n              case \"operationError\": {\n                _onError(new OperationError(event.error))\n                break\n              }\n              case \"operationInaccessible\": {\n                _onError(new OperationInaccessibleError())\n                break\n              }\n              default:\n                request(chainHead.continue, [event.operationId])\n            }\n          },\n          error: onError,\n        })\n\n        cancel = () => {\n          doneListening()\n          request(chainHead.stopOperation, [response.operationId])\n        }\n\n        const _onError = (e: Error) => {\n          cancel = noop\n          doneListening()\n          onError(e)\n        }\n\n        const _onDone = () => {\n          cancel = noop\n          doneListening()\n          onDone()\n        }\n\n        onDiscardedItems(response.discardedItems)\n      },\n      onError,\n    })\n\n    return () => {\n      cancel()\n    }\n  }\n","import { ClientInnerRequest, FollowResponse, OperationLimitError } from \"..\"\nimport type {\n  CommonOperationEventsRpc,\n  LimitReachedRpc,\n  OperationStorageDoneRpc,\n  OperationStorageItemsRpc,\n  OperationWaitingForContinueRpc,\n  OperationStorageStartedRpc,\n} from \"./json-rpc-types\"\nimport { abortablePromiseFn } from \"@/internal-utils\"\nimport { createStorageCb } from \"./storage-subscription\"\n\nexport const createStorageFn = (\n  request: ClientInnerRequest<\n    OperationStorageStartedRpc | LimitReachedRpc,\n    | CommonOperationEventsRpc\n    | OperationStorageItemsRpc\n    | OperationStorageDoneRpc\n    | OperationWaitingForContinueRpc\n  >,\n): FollowResponse[\"storage\"] => {\n  const cbStore = createStorageCb(request)\n  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {\n    const isDescendants = type.startsWith(\"descendants\")\n    let result: any = isDescendants ? [] : null\n\n    const onItems: Parameters<typeof cbStore>[3] = isDescendants\n      ? (items) => {\n          result.push(items)\n        }\n      : (items) => {\n          result = items[0]?.[type as \"value\"]\n        }\n\n    const cancel = cbStore(\n      hash,\n      [{ key, type }],\n      childTrie ?? null,\n      onItems,\n      reject,\n      () => {\n        try {\n          resolve(isDescendants ? result.flat() : result)\n        } catch (e) {\n          reject(e)\n        }\n      },\n      (nDiscarded) => {\n        if (nDiscarded > 0) {\n          cancel()\n          reject(new OperationLimitError())\n        }\n      },\n    )\n    return cancel\n  })\n}\n","import { chainHead } from \"@/methods\"\nimport { ClientInnerRequest } from \"./public-types\"\n\nexport const createUnpinFn =\n  (request: ClientInnerRequest<null, unknown>) => (hashes: string[]) =>\n    hashes.length > 0\n      ? new Promise<void>((res, rej) => {\n          request(chainHead.unpin, [hashes], {\n            onSuccess() {\n              res()\n            },\n            onError: rej,\n          })\n        })\n      : Promise.resolve()\n","export class DestroyedError extends Error {\n  constructor() {\n    super(\"Client destroyed\")\n    this.name = \"DestroyedError\"\n  }\n}\n","import type { ClientRequest, FollowSubscriptionCb } from \"@/client\"\nimport type {\n  FollowEventWithRuntimeRpc,\n  FollowEventWithoutRuntimeRpc,\n  OperationEventsRpc,\n  StopRpc,\n} from \"./json-rpc-types\"\nimport type {\n  ChainHead,\n  ClientInnerRequest,\n  FollowEventWithoutRuntime,\n  FollowEventWithRuntime,\n  FollowResponse,\n} from \"./public-types\"\nimport {\n  Subscriber,\n  getSubscriptionsManager,\n  noop,\n  deferred,\n} from \"@/internal-utils\"\nimport { createBodyFn } from \"./body\"\nimport { createCallFn } from \"./call\"\nimport { createHeaderFn } from \"./header\"\nimport { createStorageFn } from \"./storage\"\nimport { createUnpinFn } from \"./unpin\"\nimport { DisjointError, StopError } from \"./errors\"\nimport { createStorageCb } from \"./storage-subscription\"\nimport { DestroyedError } from \"@/client/DestroyedError\"\nimport { chainHead } from \"@/methods\"\n\ntype FollowEventRpc =\n  | FollowEventWithRuntimeRpc\n  | FollowEventWithoutRuntimeRpc\n  | OperationEventsRpc\n  | StopRpc\n\nfunction isOperationEvent(event: FollowEventRpc): event is OperationEventsRpc {\n  return (event as OperationEventsRpc).operationId !== undefined\n}\n\nexport function getChainHead(\n  request: ClientRequest<string, FollowEventRpc>,\n): ChainHead {\n  return (\n    withRuntime: boolean,\n    onFollowEvent:\n      | ((event: FollowEventWithoutRuntime) => void)\n      | ((event: FollowEventWithRuntime) => void),\n    onFollowError: (e: Error) => void,\n  ): FollowResponse => {\n    const subscriptions = getSubscriptionsManager<OperationEventsRpc>()\n\n    const ongoingRequests = new Set<() => void>()\n    const deferredFollow = deferred<string | Error>()\n    let followSubscription: Promise<string | Error> | string | null =\n      deferredFollow.promise\n\n    const onAllFollowEventsNext = (event: FollowEventRpc) => {\n      if (isOperationEvent(event)) {\n        if (!subscriptions.has(event.operationId))\n          console.warn(\"Uknown operationId on\", event)\n\n        return subscriptions.next(event.operationId, event)\n      }\n\n      if (event.event !== \"stop\") {\n        if (event.event === \"initialized\") {\n          return onFollowEvent({\n            type: event.event,\n            finalizedBlockHashes:\n              \"finalizedBlockHash\" in event\n                ? [event.finalizedBlockHash]\n                : event.finalizedBlockHashes,\n            finalizedBlockRuntime: (event as any).finalizedBlockRuntime,\n          })\n        }\n\n        const { event: type, ...rest } = event\n        // This is kinda dangerous, but YOLO\n        return onFollowEvent({ type, ...rest } as any)\n      }\n\n      onFollowError(new StopError())\n      unfollow(false)\n    }\n\n    const onAllFollowEventsError = (error: Error) => {\n      onFollowError(error)\n      unfollow(!(error instanceof DestroyedError))\n    }\n\n    const onFollowRequestSuccess = (\n      subscriptionId: string,\n      follow: FollowSubscriptionCb<FollowEventRpc>,\n    ) => {\n      const done = follow(subscriptionId, {\n        next: onAllFollowEventsNext,\n        error: onAllFollowEventsError,\n      })\n\n      unfollow = (sendUnfollow = true) => {\n        followSubscription = null\n        unfollow = noop\n        done()\n        sendUnfollow && request(chainHead.unfollow, [subscriptionId])\n        subscriptions.errorAll(new DisjointError())\n        ongoingRequests.forEach((cb) => {\n          cb()\n        })\n        ongoingRequests.clear()\n      }\n\n      followSubscription = subscriptionId\n      deferredFollow.res(subscriptionId)\n    }\n\n    const onFollowRequestError = (e: Error) => {\n      if (e instanceof DestroyedError) {\n        unfollow(false)\n      } else {\n        onFollowError(e)\n      }\n      followSubscription = null\n      deferredFollow.res(e)\n    }\n\n    let unfollow: (internal?: boolean) => void = request(\n      chainHead.follow,\n      [withRuntime],\n      { onSuccess: onFollowRequestSuccess, onError: onFollowRequestError },\n    )\n\n    const fRequest: ClientInnerRequest<any, any> = (method, params, cb) => {\n      const disjoint = () => {\n        cb?.onError(new DisjointError())\n      }\n\n      if (followSubscription === null) {\n        disjoint()\n        return noop\n      }\n\n      const onSubscription = (subscription: string) => {\n        if (!cb) return request(method, [subscription, ...params])\n\n        ongoingRequests.add(disjoint)\n\n        const onSubscribeOperation = (\n          operationId: string,\n          subscriber: Subscriber<any>,\n        ) => {\n          if (followSubscription === null) {\n            subscriber.error(new DisjointError())\n            return noop\n          }\n\n          subscriptions.subscribe(operationId, subscriber)\n\n          return () => {\n            subscriptions.unsubscribe(operationId)\n          }\n        }\n\n        const cleanup = request(method, [subscription, ...params], {\n          onSuccess: (response) => {\n            ongoingRequests.delete(disjoint)\n            cb.onSuccess(response, onSubscribeOperation)\n          },\n          onError: (e) => {\n            ongoingRequests.delete(disjoint)\n            cb.onError(e)\n          },\n        })\n\n        return () => {\n          ongoingRequests.delete(disjoint)\n          cleanup()\n        }\n      }\n\n      if (typeof followSubscription === \"string\")\n        return onSubscription(followSubscription)\n\n      let onCancel = noop\n      followSubscription.then((x) => {\n        if (x instanceof Error) return disjoint()\n        if (followSubscription) onCancel = onSubscription(x)\n      })\n\n      return () => {\n        onCancel()\n      }\n    }\n\n    return {\n      unfollow() {\n        unfollow()\n        followSubscription = null\n      },\n      body: createBodyFn(fRequest),\n      call: createCallFn(fRequest),\n      header: createHeaderFn(fRequest),\n      storage: createStorageFn(fRequest),\n      storageSubscription: createStorageCb(fRequest),\n      unpin: createUnpinFn(fRequest),\n      _request: fRequest,\n    }\n  }\n}\n","export interface IRpcError {\n  code: number\n  message: string\n  data?: any\n}\n\nexport class RpcError extends Error implements IRpcError {\n  code\n  data\n  constructor(e: IRpcError) {\n    super(e.message)\n    this.code = e.code\n    this.data = e.data\n    this.name = \"RpcError\"\n  }\n}\n","import type {\n  JsonRpcConnection,\n  JsonRpcProvider,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { UnsubscribeFn } from \"../common-types\"\nimport { RpcError, IRpcError } from \"./RpcError\"\nimport { getSubscriptionsManager, Subscriber } from \"@/internal-utils\"\nimport { DestroyedError } from \"./DestroyedError\"\n\nexport type FollowSubscriptionCb<T> = (\n  subscriptionId: string,\n  cb: Subscriber<T>,\n) => UnsubscribeFn\n\nexport type ClientRequestCb<T, TT> = {\n  onSuccess: (result: T, followSubscription: FollowSubscriptionCb<TT>) => void\n  onError: (e: Error) => void\n}\n\nexport type ClientRequest<T, TT> = (\n  method: string,\n  params: Array<any>,\n  cb?: ClientRequestCb<T, TT>,\n) => UnsubscribeFn\n\nexport interface Client {\n  disconnect: () => void\n  request: ClientRequest<any, any>\n}\n\nlet nextClientId = 1\nexport const createClient = (gProvider: JsonRpcProvider): Client => {\n  let clientId = nextClientId++\n  const responses = new Map<string, ClientRequestCb<any, any>>()\n  const subscriptions = getSubscriptionsManager()\n\n  let connection: JsonRpcConnection | null = null\n\n  const send = (\n    id: string,\n    method: string,\n    params: Array<boolean | string | number | null>,\n  ) => {\n    connection!.send(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method,\n        params,\n      }),\n    )\n  }\n\n  function onMessage(message: string): void {\n    try {\n      let id: string,\n        result,\n        error: IRpcError | undefined,\n        params: { subscription: any; result: any; error?: IRpcError },\n        subscription: string\n\n      const parsed = JSON.parse(message)\n      ;({ id, result, error, params } = parsed)\n\n      if (id) {\n        const cb = responses.get(id)\n        if (!cb) return\n\n        responses.delete(id)\n\n        return error\n          ? cb.onError(new RpcError(error))\n          : cb.onSuccess(result, (opaqueId, subscriber) => {\n              const subscriptionId = opaqueId\n              subscriptions.subscribe(subscriptionId, subscriber)\n              return () => {\n                subscriptions.unsubscribe(subscriptionId)\n              }\n            })\n      }\n\n      // at this point, it means that it should be a notification\n      ;({ subscription, result, error } = params)\n      if (!subscription || (!error && !Object.hasOwn(params, \"result\"))) throw 0\n\n      const subscriptionId = subscription\n\n      if (error) {\n        subscriptions.error(subscriptionId, new RpcError(error!))\n      } else {\n        subscriptions.next(subscriptionId, result)\n      }\n    } catch (e) {\n      console.warn(\"Error parsing incomming message: \" + message)\n      console.error(e)\n    }\n  }\n  connection = gProvider(onMessage)\n\n  const disconnect = () => {\n    connection?.disconnect()\n    connection = null\n    subscriptions.errorAll(new DestroyedError())\n    responses.forEach((r) => r.onError(new DestroyedError()))\n    responses.clear()\n  }\n\n  let nextId = 1\n  const request = <T, TT>(\n    method: string,\n    params: Array<any>,\n    cb?: ClientRequestCb<T, TT>,\n  ): UnsubscribeFn => {\n    if (!connection) throw new Error(\"Not connected\")\n    const id = `${clientId}-${nextId++}`\n\n    if (cb) responses.set(id, cb)\n    send(id, method, params)\n\n    return (): void => {\n      responses.delete(id)\n    }\n  }\n\n  return {\n    request,\n    disconnect,\n  }\n}\n","import { ClientRequest } from \"./client\"\nimport { abortablePromiseFn } from \"./internal-utils\"\nimport { chainSpec } from \"./methods\"\n\nexport interface ChainSpecData {\n  name: string\n  genesisHash: string\n  properties: any\n}\n\nexport const createGetChainSpec = (clientRequest: ClientRequest<any, any>) => {\n  const request = abortablePromiseFn(\n    <T>(\n      onSuccess: (value: T) => void,\n      onError: (e: any) => void,\n      method: string,\n      params: any[],\n    ) => clientRequest(method, params, { onSuccess, onError }),\n  )\n  let cachedPromise: null | Promise<ChainSpecData> = null\n\n  return async (): Promise<ChainSpecData> => {\n    if (cachedPromise) return cachedPromise\n    return (cachedPromise = Promise.all([\n      request<string>(chainSpec.chainName, []),\n      request<string>(chainSpec.genesisHash, []),\n      request<any>(chainSpec.properties, []),\n    ]).then(([name, genesisHash, properties]) => ({\n      name,\n      genesisHash,\n      properties,\n    })))\n  }\n}\n","import type { ClientRequest } from \"@/client\"\nimport { UnsubscribeFn } from \"./common-types\"\nimport { noop } from \"./internal-utils\"\n\nexport const getCompatibilityEnhancer =\n  <T, E>(rpcMethodsP: Promise<Set<string>>, request: ClientRequest<T, E>) =>\n  (methods: Record<string, string>): ClientRequest<T, E> => {\n    let translations: Record<string, string> = {}\n    let enhancedRequest: ClientRequest<T, E> | null = null\n\n    return ((method, ...rest) => {\n      if (enhancedRequest) return enhancedRequest(method, ...rest)\n\n      let isRunning = true\n      let cleanup: UnsubscribeFn = () => {\n        isRunning = false\n      }\n\n      rpcMethodsP\n        .then((rpcMethods) => {\n          enhancedRequest = (method_, ...iRest) => {\n            const method = translations[method_] ?? method_\n            if (rpcMethods.has(method)) return request(method, ...iRest)\n            iRest[1]?.onError(new Error(`Unsupported method ${method}`))\n            return noop\n          }\n\n          if (rpcMethods.has(method)) return\n\n          const parts = method.split(\"_\")\n          if (parts[1] !== \"v1\") return\n\n          parts[1] = \"unstable\"\n\n          if (rpcMethods.has(parts.join(\"_\")))\n            Object.values(methods).forEach((value) => {\n              translations[value] = value.replace(\"_v1_\", \"_unstable_\")\n            })\n          else if (parts[0] === \"transaction\") {\n            // old versions of smoldot and Polkadot-SDK don't support transaction_xx_broadcast\n            // some old versions have `transactions_unstable_submitAndWatch` while others have `transaction_xx_submitAndWatch`\n            // if we find any of this options, then we will can use them as if they were broadast/stop\n            let unwatch: string | undefined\n            let version: string | undefined\n\n            const txGroup = [\"transactionWatch\", \"transaction\"].find(\n              (group) => {\n                version = [\"v1\", \"unstable\"].find((v) =>\n                  rpcMethods.has((unwatch = `${group}_${v}_unwatch`)),\n                )\n                return !!version\n              },\n            )\n\n            if (txGroup) {\n              translations[methods.broadcast] =\n                `${txGroup}_${version}_submitAndWatch`\n              translations[methods.stop] = unwatch!\n            }\n          }\n        })\n        .then(() => {\n          if (isRunning) cleanup = enhancedRequest!(method, ...rest)\n        })\n\n      return () => {\n        cleanup()\n      }\n    }) as ClientRequest<T, E>\n  }\n"],"mappings":"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","names":["src_exports","__export","DestroyedError","DisjointError","OperationError","OperationInaccessibleError","OperationLimitError","RpcError","StopError","createClient","__toCommonJS","import_utils","abortablePromiseFn","fn","args","res","rej","cancel","actualArgs","abortSignal","onAbort","withCleanup","x","deferred","res","rej","_res","_rej","noop","getSubscriptionsManager","subscriptions","id","subscriber","data","e","subscribers","s","chainHead","chainSpec","transaction","transactionWatch","fnGroupName","methods","methodName","getTransaction","request","tx","error","cancel","transaction","subscriptionId","noop","StopError","DisjointError","OperationLimitError","OperationError","error","OperationInaccessibleError","createOperationPromise","operationName","factory","request","abortablePromiseFn","res","rej","args","isRunning","cancel","requestArgs","logicCb","response","followSubscription","OperationLimitError","operationId","stopOperation","chainHead","done","noop","_res","x","_rej","e","_e","OperationError","OperationInaccessibleError","createBodyFn","createOperationPromise","chainHead","hash","res","createCallFn","createOperationPromise","chainHead","hash","fnName","callParameters","e","res","createHeaderFn","request","hash","res","rej","chainHead","import_utils","createStorageCb","request","hash","inputs","childTrie","onItems","onError","onDone","onDiscardedItems","isRunning","cancel","chainHead","response","followSubscription","OperationLimitError","operationId","stopOperation","doneListening","event","_onDone","_onError","OperationError","OperationInaccessibleError","e","createStorageFn","request","cbStore","createStorageCb","abortablePromiseFn","resolve","reject","hash","type","key","childTrie","isDescendants","result","cancel","items","e","nDiscarded","OperationLimitError","createUnpinFn","request","hashes","res","rej","chainHead","DestroyedError","isOperationEvent","event","getChainHead","request","withRuntime","onFollowEvent","onFollowError","subscriptions","getSubscriptionsManager","ongoingRequests","deferredFollow","deferred","followSubscription","onAllFollowEventsNext","type","rest","StopError","unfollow","onAllFollowEventsError","error","DestroyedError","onFollowRequestSuccess","subscriptionId","follow","done","sendUnfollow","noop","chainHead","DisjointError","cb","onFollowRequestError","e","fRequest","method","params","disjoint","onSubscription","subscription","onSubscribeOperation","operationId","subscriber","cleanup","response","onCancel","x","createBodyFn","createCallFn","createHeaderFn","createStorageFn","createStorageCb","createUnpinFn","RpcError","e","__publicField","nextClientId","createClient","gProvider","clientId","responses","subscriptions","getSubscriptionsManager","connection","send","id","method","params","onMessage","message","result","error","subscription","cb","RpcError","opaqueId","subscriber","subscriptionId","e","disconnect","DestroyedError","r","nextId","createGetChainSpec","clientRequest","request","abortablePromiseFn","onSuccess","onError","method","params","cachedPromise","chainSpec","name","genesisHash","properties","getCompatibilityEnhancer","rpcMethodsP","request","methods","translations","enhancedRequest","method","rest","isRunning","cleanup","rpcMethods","method_","iRest","noop","parts","value","unwatch","version","txGroup","group","v","import_utils","createClient","provider","client","request","abortablePromiseFn","onSuccess","onError","method","params","rpcMethods","x","compatibilityEnhancer","getCompatibilityEnhancer","getChainHead","chainHead","getTransaction","transaction","createGetChainSpec","chainSpec"]}