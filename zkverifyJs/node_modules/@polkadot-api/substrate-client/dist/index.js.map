{"version":3,"sources":["../src/index.ts","../src/internal-utils/abortablePromiseFn.ts","../src/internal-utils/deferred-promise.ts","../src/internal-utils/noop.ts","../src/internal-utils/subscriptions-manager.ts","../src/methods.ts","../src/transaction/transaction.ts","../src/chainhead/errors.ts","../src/chainhead/operation-promise.ts","../src/chainhead/body.ts","../src/chainhead/call.ts","../src/chainhead/header.ts","../src/chainhead/storage-subscription.ts","../src/chainhead/storage.ts","../src/chainhead/unpin.ts","../src/client/DestroyedError.ts","../src/chainhead/chainhead.ts","../src/client/RpcError.ts","../src/client/createClient.ts","../src/chainspec.ts","../src/request-compatibility-enhancer.ts"],"sourcesContent":["import type { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport { getTransaction } from \"./transaction/transaction\"\nimport { getChainHead } from \"./chainhead\"\nimport {\n  ClientRequest,\n  ClientRequestCb,\n  createClient as createRawClient,\n} from \"./client\"\nimport type { ChainHead } from \"./chainhead\"\nimport type { Transaction } from \"./transaction\"\nimport { UnsubscribeFn } from \"./common-types\"\nimport { abortablePromiseFn } from \"./internal-utils\"\nimport { ChainSpecData, createGetChainSpec } from \"./chainspec\"\nimport { getCompatibilityEnhancer } from \"./request-compatibility-enhancer\"\nimport { chainHead, chainSpec, transaction } from \"./methods\"\n\nexport { AbortError } from \"@polkadot-api/utils\"\nexport type * from \"@polkadot-api/json-rpc-provider\"\n\nexport type * from \"./common-types\"\nexport type * from \"./client\"\nexport type * from \"./transaction\"\nexport type * from \"./chainhead\"\nexport type * from \"./chainspec\"\n\nexport { RpcError, DestroyedError } from \"./client\"\nexport {\n  StopError,\n  DisjointError,\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./chainhead\"\n\nexport interface SubstrateClient {\n  chainHead: ChainHead\n  transaction: Transaction\n  destroy: UnsubscribeFn\n  getChainSpecData: () => Promise<ChainSpecData>\n  request: <T>(\n    method: string,\n    params: any[],\n    abortSignal?: AbortSignal,\n  ) => Promise<T>\n  _request: <Reply, Notification>(\n    method: string,\n    params: any[],\n    cb?: ClientRequestCb<Reply, Notification>,\n  ) => UnsubscribeFn\n}\n\nexport const createClient = (provider: JsonRpcProvider): SubstrateClient => {\n  const client = createRawClient(provider)\n\n  const request = abortablePromiseFn(\n    <T>(\n      onSuccess: (value: T) => void,\n      onError: (e: any) => void,\n      method: string,\n      params: any[],\n    ) => client.request(method, params, { onSuccess, onError }),\n  )\n\n  const rpcMethods: Promise<Set<string>> = request<\n    { methods: Array<string> } | Array<string>\n  >(\"rpc_methods\", []).then(\n    (x) => new Set(Array.isArray(x) ? x : x.methods),\n    () => new Set(),\n  )\n\n  const compatibilityEnhancer = getCompatibilityEnhancer(\n    rpcMethods,\n    client.request,\n  )\n\n  return {\n    chainHead: getChainHead(\n      compatibilityEnhancer(chainHead) as ClientRequest<any, any>,\n    ),\n    transaction: getTransaction(\n      compatibilityEnhancer(transaction) as ClientRequest<string, any>,\n    ),\n    getChainSpecData: createGetChainSpec(\n      compatibilityEnhancer(chainSpec) as ClientRequest<any, any>,\n    ),\n    destroy: () => {\n      client.disconnect()\n    },\n    request,\n    _request: client.request,\n  }\n}\n","import { AbortError, noop } from \"@polkadot-api/utils\"\nimport { AbortablePromiseFn } from \"../common-types\"\n\nexport const abortablePromiseFn =\n  <T, A extends Array<any>>(\n    fn: (\n      ...args: [...[res: (x: T) => void, rej: (e: any) => void], ...A]\n    ) => () => void,\n  ): AbortablePromiseFn<A, T> =>\n  (...args): Promise<T> =>\n    new Promise((res, rej) => {\n      let cancel = noop\n\n      const [actualArgs, abortSignal] =\n        args[args.length - 1] instanceof AbortSignal\n          ? ([args.slice(0, args.length - 1), args[args.length - 1]] as [\n              A,\n              AbortSignal,\n            ])\n          : ([args] as unknown as [A])\n\n      const onAbort = () => {\n        cancel()\n        rej(new AbortError())\n      }\n\n      abortSignal?.addEventListener(\"abort\", onAbort, { once: true })\n\n      const withCleanup =\n        <T>(fn: (x: T) => void): ((x: T) => void) =>\n        (x) => {\n          cancel = noop\n          abortSignal?.removeEventListener(\"abort\", onAbort)\n          fn(x)\n        }\n\n      cancel = fn(...[withCleanup(res), withCleanup(rej), ...actualArgs])\n    })\n","export interface DeferredPromise<T> {\n  promise: Promise<T>\n  res: (value: T) => void\n  rej: (err: Error) => void\n}\n\nexport function deferred<T>(): DeferredPromise<T> {\n  let res: (value: T) => void = () => {}\n  let rej: (err: Error) => void = () => {}\n\n  const promise = new Promise<T>((_res, _rej) => {\n    res = _res\n    rej = _rej\n  })\n\n  return { promise, res, rej }\n}\n","export const noop = (): void => {}\n","export interface Subscriber<T> {\n  next: (data: T) => void\n  error: (e: Error) => void\n}\n\nexport const getSubscriptionsManager = <T>() => {\n  const subscriptions = new Map<string, Subscriber<T>>()\n\n  return {\n    has: subscriptions.has.bind(subscriptions),\n    subscribe(id: string, subscriber: Subscriber<T>) {\n      subscriptions.set(id, subscriber)\n    },\n    unsubscribe(id: string) {\n      subscriptions.delete(id)\n    },\n    next(id: string, data: T) {\n      subscriptions.get(id)?.next(data)\n    },\n    error(id: string, e: Error) {\n      const subscriber = subscriptions.get(id)\n      if (subscriber) {\n        subscriptions.delete(id)\n        subscriber.error(e)\n      }\n    },\n    errorAll(e: Error) {\n      const subscribers = [...subscriptions.values()]\n      subscriptions.clear()\n      subscribers.forEach((s) => {\n        s.error(e)\n      })\n    },\n  }\n}\n\nexport type SubscriptionManager<T> = ReturnType<\n  typeof getSubscriptionsManager<T>\n>\n","export const chainHead = {\n  body: \"\",\n  call: \"\",\n  continue: \"\",\n  follow: \"\",\n  header: \"\",\n  stopOperation: \"\",\n  storage: \"\",\n  unfollow: \"\",\n  unpin: \"\",\n  followEvent: \"\",\n}\n\nexport const chainSpec = {\n  chainName: \"\",\n  genesisHash: \"\",\n  properties: \"\",\n}\n\nexport const transaction = {\n  broadcast: \"\",\n  stop: \"\",\n}\n\nexport const transactionWatch = {\n  submitAndWatch: \"\",\n  unwatch: \"\",\n}\n\nObject.entries({ chainHead, chainSpec, transaction, transactionWatch }).forEach(\n  ([fnGroupName, methods]) => {\n    Object.keys(methods).forEach((methodName) => {\n      ;(methods as any)[methodName] = `${fnGroupName}_v1_${methodName}`\n    })\n  },\n)\n","import { noop } from \"@/internal-utils\"\nimport { type ClientRequest } from \"../client\"\nimport { transaction } from \"@/methods\"\n\nexport const getTransaction =\n  (request: ClientRequest<string, any>) =>\n  (tx: string, error: (e: Error) => void) => {\n    let cancel = request(transaction.broadcast, [tx], {\n      onSuccess: (subscriptionId) => {\n        cancel =\n          subscriptionId === null\n            ? noop\n            : () => {\n                request(transaction.stop, [subscriptionId])\n              }\n\n        if (subscriptionId === null) {\n          error(new Error(\"Max # of broadcasted transactions has been reached\"))\n        }\n      },\n      onError: error,\n    })\n\n    return () => {\n      cancel()\n    }\n  }\n","export class StopError extends Error {\n  constructor() {\n    super(\"ChainHead stopped\")\n    this.name = \"StopError\"\n  }\n}\n\nexport class DisjointError extends Error {\n  constructor() {\n    super(\"ChainHead disjointed\")\n    this.name = \"DisjointError\"\n  }\n}\n\nexport class OperationLimitError extends Error {\n  constructor() {\n    super(\"ChainHead operations limit reached\")\n    this.name = \"OperationLimitError\"\n  }\n}\n\nexport class OperationError extends Error {\n  constructor(error: string) {\n    super(error)\n    this.name = \"OperationError\"\n  }\n}\n\nexport class OperationInaccessibleError extends Error {\n  constructor() {\n    super(\"ChainHead operation inaccessible\")\n    this.name = \"OperationInaccessibleError\"\n  }\n}\n","import { abortablePromiseFn, noop } from \"@/internal-utils\"\nimport {\n  CommonOperationEventsRpc,\n  OperationResponseRpc,\n} from \"./json-rpc-types\"\nimport {\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./errors\"\nimport { ClientInnerRequest } from \"./public-types\"\nimport { chainHead } from \"@/methods\"\n\nexport const createOperationPromise =\n  <I extends { operationId: string; event: string }, O, A extends Array<any>>(\n    operationName: string,\n    factory: (\n      ...args: A\n    ) => [\n      Array<any>,\n      (e: I, res: (x: O) => void, rej: (e: Error) => void) => void,\n    ],\n  ) =>\n  (\n    request: ClientInnerRequest<\n      OperationResponseRpc,\n      I | CommonOperationEventsRpc\n    >,\n  ) =>\n    abortablePromiseFn<O, A>((res, rej, ...args) => {\n      let isRunning = true\n      let cancel = () => {\n        isRunning = false\n      }\n\n      const [requestArgs, logicCb] = factory(...args)\n      request(operationName, requestArgs, {\n        onSuccess: (response, followSubscription) => {\n          if (response.result === \"limitReached\")\n            return rej(new OperationLimitError())\n\n          const { operationId } = response\n          const stopOperation = () => {\n            request(chainHead.stopOperation, [operationId])\n          }\n\n          if (!isRunning) return stopOperation()\n\n          let done = noop\n          const _res = (x: O) => {\n            isRunning = false\n            done()\n            res(x)\n          }\n          const _rej = (x: Error) => {\n            isRunning = false\n            done()\n            rej(x)\n          }\n\n          done = followSubscription(operationId, {\n            next: (e) => {\n              const _e = e as CommonOperationEventsRpc\n              if (_e.event === \"operationError\")\n                rej(new OperationError(_e.error))\n              else if (_e.event === \"operationInaccessible\")\n                rej(new OperationInaccessibleError())\n              else logicCb(e as I, _res, _rej)\n            },\n            error: _rej,\n          })\n\n          cancel = () => {\n            if (isRunning) {\n              done()\n              stopOperation()\n            }\n          }\n        },\n        onError: rej,\n      })\n\n      return () => {\n        cancel()\n      }\n    })\n","import { chainHead } from \"@/methods\"\nimport type { OperationBodyDoneRpc } from \"./json-rpc-types\"\nimport { createOperationPromise } from \"./operation-promise\"\n\nexport const createBodyFn = createOperationPromise(\n  chainHead.body,\n  (hash: string) => [\n    [hash],\n    (e: OperationBodyDoneRpc, res: (x: Array<string>) => void) => {\n      res(e.value)\n    },\n  ],\n)\n","import { chainHead } from \"@/methods\"\nimport type { OperationCallDoneRpc } from \"./json-rpc-types\"\nimport { createOperationPromise } from \"./operation-promise\"\n\nexport const createCallFn = createOperationPromise(\n  chainHead.call,\n  (hash: string, fnName: string, callParameters: string) => [\n    [hash, fnName, callParameters],\n    (e: OperationCallDoneRpc, res: (output: string) => void) => {\n      res(e.output)\n    },\n  ],\n)\n","import { chainHead } from \"@/methods\"\nimport { ClientInnerRequest } from \"./public-types\"\n\nexport const createHeaderFn =\n  (request: ClientInnerRequest<string, unknown>) => (hash: string) =>\n    new Promise<string>((res, rej) => {\n      request(chainHead.header, [hash], {\n        onSuccess: res,\n        onError: rej,\n      })\n    })\n","import { noop } from \"@polkadot-api/utils\"\nimport {\n  ClientInnerRequest,\n  FollowResponse,\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"..\"\nimport {\n  CommonOperationEventsRpc,\n  LimitReachedRpc,\n  OperationStorageDoneRpc,\n  OperationStorageItemsRpc,\n  OperationWaitingForContinueRpc,\n  OperationStorageStartedRpc,\n} from \"./json-rpc-types\"\nimport { chainHead } from \"@/methods\"\n\nexport const createStorageCb =\n  (\n    request: ClientInnerRequest<\n      OperationStorageStartedRpc | LimitReachedRpc,\n      | CommonOperationEventsRpc\n      | OperationStorageItemsRpc\n      | OperationStorageDoneRpc\n      | OperationWaitingForContinueRpc\n    >,\n  ): FollowResponse[\"storageSubscription\"] =>\n  (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {\n    if (inputs.length === 0) {\n      onDone()\n      return noop\n    }\n\n    let isRunning = true\n    let cancel = () => {\n      isRunning = false\n    }\n\n    request(chainHead.storage, [hash, inputs, childTrie], {\n      onSuccess: (response, followSubscription) => {\n        if (\n          response.result === \"limitReached\" ||\n          response.discardedItems === inputs.length\n        )\n          return onError(new OperationLimitError())\n\n        const { operationId } = response\n        const stopOperation = () => {\n          request(chainHead.stopOperation, [operationId])\n        }\n\n        if (!isRunning) return stopOperation()\n\n        const doneListening = followSubscription(response.operationId, {\n          next: (event) => {\n            switch (event.event) {\n              case \"operationStorageItems\": {\n                onItems(event.items)\n                break\n              }\n              case \"operationStorageDone\": {\n                _onDone()\n                break\n              }\n              case \"operationError\": {\n                _onError(new OperationError(event.error))\n                break\n              }\n              case \"operationInaccessible\": {\n                _onError(new OperationInaccessibleError())\n                break\n              }\n              default:\n                request(chainHead.continue, [event.operationId])\n            }\n          },\n          error: onError,\n        })\n\n        cancel = () => {\n          doneListening()\n          request(chainHead.stopOperation, [response.operationId])\n        }\n\n        const _onError = (e: Error) => {\n          cancel = noop\n          doneListening()\n          onError(e)\n        }\n\n        const _onDone = () => {\n          cancel = noop\n          doneListening()\n          onDone()\n        }\n\n        onDiscardedItems(response.discardedItems)\n      },\n      onError,\n    })\n\n    return () => {\n      cancel()\n    }\n  }\n","import { ClientInnerRequest, FollowResponse, OperationLimitError } from \"..\"\nimport type {\n  CommonOperationEventsRpc,\n  LimitReachedRpc,\n  OperationStorageDoneRpc,\n  OperationStorageItemsRpc,\n  OperationWaitingForContinueRpc,\n  OperationStorageStartedRpc,\n} from \"./json-rpc-types\"\nimport { abortablePromiseFn } from \"@/internal-utils\"\nimport { createStorageCb } from \"./storage-subscription\"\n\nexport const createStorageFn = (\n  request: ClientInnerRequest<\n    OperationStorageStartedRpc | LimitReachedRpc,\n    | CommonOperationEventsRpc\n    | OperationStorageItemsRpc\n    | OperationStorageDoneRpc\n    | OperationWaitingForContinueRpc\n  >,\n): FollowResponse[\"storage\"] => {\n  const cbStore = createStorageCb(request)\n  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {\n    const isDescendants = type.startsWith(\"descendants\")\n    let result: any = isDescendants ? [] : null\n\n    const onItems: Parameters<typeof cbStore>[3] = isDescendants\n      ? (items) => {\n          result.push(items)\n        }\n      : (items) => {\n          result = items[0]?.[type as \"value\"]\n        }\n\n    const cancel = cbStore(\n      hash,\n      [{ key, type }],\n      childTrie ?? null,\n      onItems,\n      reject,\n      () => {\n        try {\n          resolve(isDescendants ? result.flat() : result)\n        } catch (e) {\n          reject(e)\n        }\n      },\n      (nDiscarded) => {\n        if (nDiscarded > 0) {\n          cancel()\n          reject(new OperationLimitError())\n        }\n      },\n    )\n    return cancel\n  })\n}\n","import { chainHead } from \"@/methods\"\nimport { ClientInnerRequest } from \"./public-types\"\n\nexport const createUnpinFn =\n  (request: ClientInnerRequest<null, unknown>) => (hashes: string[]) =>\n    hashes.length > 0\n      ? new Promise<void>((res, rej) => {\n          request(chainHead.unpin, [hashes], {\n            onSuccess() {\n              res()\n            },\n            onError: rej,\n          })\n        })\n      : Promise.resolve()\n","export class DestroyedError extends Error {\n  constructor() {\n    super(\"Client destroyed\")\n    this.name = \"DestroyedError\"\n  }\n}\n","import type { ClientRequest, FollowSubscriptionCb } from \"@/client\"\nimport type {\n  FollowEventWithRuntimeRpc,\n  FollowEventWithoutRuntimeRpc,\n  OperationEventsRpc,\n  StopRpc,\n} from \"./json-rpc-types\"\nimport type {\n  ChainHead,\n  ClientInnerRequest,\n  FollowEventWithoutRuntime,\n  FollowEventWithRuntime,\n  FollowResponse,\n} from \"./public-types\"\nimport {\n  Subscriber,\n  getSubscriptionsManager,\n  noop,\n  deferred,\n} from \"@/internal-utils\"\nimport { createBodyFn } from \"./body\"\nimport { createCallFn } from \"./call\"\nimport { createHeaderFn } from \"./header\"\nimport { createStorageFn } from \"./storage\"\nimport { createUnpinFn } from \"./unpin\"\nimport { DisjointError, StopError } from \"./errors\"\nimport { createStorageCb } from \"./storage-subscription\"\nimport { DestroyedError } from \"@/client/DestroyedError\"\nimport { chainHead } from \"@/methods\"\n\ntype FollowEventRpc =\n  | FollowEventWithRuntimeRpc\n  | FollowEventWithoutRuntimeRpc\n  | OperationEventsRpc\n  | StopRpc\n\nfunction isOperationEvent(event: FollowEventRpc): event is OperationEventsRpc {\n  return (event as OperationEventsRpc).operationId !== undefined\n}\n\nexport function getChainHead(\n  request: ClientRequest<string, FollowEventRpc>,\n): ChainHead {\n  return (\n    withRuntime: boolean,\n    onFollowEvent:\n      | ((event: FollowEventWithoutRuntime) => void)\n      | ((event: FollowEventWithRuntime) => void),\n    onFollowError: (e: Error) => void,\n  ): FollowResponse => {\n    const subscriptions = getSubscriptionsManager<OperationEventsRpc>()\n\n    const ongoingRequests = new Set<() => void>()\n    const deferredFollow = deferred<string | Error>()\n    let followSubscription: Promise<string | Error> | string | null =\n      deferredFollow.promise\n\n    const onAllFollowEventsNext = (event: FollowEventRpc) => {\n      if (isOperationEvent(event)) {\n        if (!subscriptions.has(event.operationId))\n          console.warn(\"Uknown operationId on\", event)\n\n        return subscriptions.next(event.operationId, event)\n      }\n\n      if (event.event !== \"stop\") {\n        if (event.event === \"initialized\") {\n          return onFollowEvent({\n            type: event.event,\n            finalizedBlockHashes:\n              \"finalizedBlockHash\" in event\n                ? [event.finalizedBlockHash]\n                : event.finalizedBlockHashes,\n            finalizedBlockRuntime: (event as any).finalizedBlockRuntime,\n          })\n        }\n\n        const { event: type, ...rest } = event\n        // This is kinda dangerous, but YOLO\n        return onFollowEvent({ type, ...rest } as any)\n      }\n\n      onFollowError(new StopError())\n      unfollow(false)\n    }\n\n    const onAllFollowEventsError = (error: Error) => {\n      onFollowError(error)\n      unfollow(!(error instanceof DestroyedError))\n    }\n\n    const onFollowRequestSuccess = (\n      subscriptionId: string,\n      follow: FollowSubscriptionCb<FollowEventRpc>,\n    ) => {\n      const done = follow(subscriptionId, {\n        next: onAllFollowEventsNext,\n        error: onAllFollowEventsError,\n      })\n\n      unfollow = (sendUnfollow = true) => {\n        followSubscription = null\n        unfollow = noop\n        done()\n        sendUnfollow && request(chainHead.unfollow, [subscriptionId])\n        subscriptions.errorAll(new DisjointError())\n        ongoingRequests.forEach((cb) => {\n          cb()\n        })\n        ongoingRequests.clear()\n      }\n\n      followSubscription = subscriptionId\n      deferredFollow.res(subscriptionId)\n    }\n\n    const onFollowRequestError = (e: Error) => {\n      if (e instanceof DestroyedError) {\n        unfollow(false)\n      } else {\n        onFollowError(e)\n      }\n      followSubscription = null\n      deferredFollow.res(e)\n    }\n\n    let unfollow: (internal?: boolean) => void = request(\n      chainHead.follow,\n      [withRuntime],\n      { onSuccess: onFollowRequestSuccess, onError: onFollowRequestError },\n    )\n\n    const fRequest: ClientInnerRequest<any, any> = (method, params, cb) => {\n      const disjoint = () => {\n        cb?.onError(new DisjointError())\n      }\n\n      if (followSubscription === null) {\n        disjoint()\n        return noop\n      }\n\n      const onSubscription = (subscription: string) => {\n        if (!cb) return request(method, [subscription, ...params])\n\n        ongoingRequests.add(disjoint)\n\n        const onSubscribeOperation = (\n          operationId: string,\n          subscriber: Subscriber<any>,\n        ) => {\n          if (followSubscription === null) {\n            subscriber.error(new DisjointError())\n            return noop\n          }\n\n          subscriptions.subscribe(operationId, subscriber)\n\n          return () => {\n            subscriptions.unsubscribe(operationId)\n          }\n        }\n\n        const cleanup = request(method, [subscription, ...params], {\n          onSuccess: (response) => {\n            ongoingRequests.delete(disjoint)\n            cb.onSuccess(response, onSubscribeOperation)\n          },\n          onError: (e) => {\n            ongoingRequests.delete(disjoint)\n            cb.onError(e)\n          },\n        })\n\n        return () => {\n          ongoingRequests.delete(disjoint)\n          cleanup()\n        }\n      }\n\n      if (typeof followSubscription === \"string\")\n        return onSubscription(followSubscription)\n\n      let onCancel = noop\n      followSubscription.then((x) => {\n        if (x instanceof Error) return disjoint()\n        if (followSubscription) onCancel = onSubscription(x)\n      })\n\n      return () => {\n        onCancel()\n      }\n    }\n\n    return {\n      unfollow() {\n        unfollow()\n        followSubscription = null\n      },\n      body: createBodyFn(fRequest),\n      call: createCallFn(fRequest),\n      header: createHeaderFn(fRequest),\n      storage: createStorageFn(fRequest),\n      storageSubscription: createStorageCb(fRequest),\n      unpin: createUnpinFn(fRequest),\n      _request: fRequest,\n    }\n  }\n}\n","export interface IRpcError {\n  code: number\n  message: string\n  data?: any\n}\n\nexport class RpcError extends Error implements IRpcError {\n  code\n  data\n  constructor(e: IRpcError) {\n    super(e.message)\n    this.code = e.code\n    this.data = e.data\n    this.name = \"RpcError\"\n  }\n}\n","import type {\n  JsonRpcConnection,\n  JsonRpcProvider,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { UnsubscribeFn } from \"../common-types\"\nimport { RpcError, IRpcError } from \"./RpcError\"\nimport { getSubscriptionsManager, Subscriber } from \"@/internal-utils\"\nimport { DestroyedError } from \"./DestroyedError\"\n\nexport type FollowSubscriptionCb<T> = (\n  subscriptionId: string,\n  cb: Subscriber<T>,\n) => UnsubscribeFn\n\nexport type ClientRequestCb<T, TT> = {\n  onSuccess: (result: T, followSubscription: FollowSubscriptionCb<TT>) => void\n  onError: (e: Error) => void\n}\n\nexport type ClientRequest<T, TT> = (\n  method: string,\n  params: Array<any>,\n  cb?: ClientRequestCb<T, TT>,\n) => UnsubscribeFn\n\nexport interface Client {\n  disconnect: () => void\n  request: ClientRequest<any, any>\n}\n\nlet nextClientId = 1\nexport const createClient = (gProvider: JsonRpcProvider): Client => {\n  let clientId = nextClientId++\n  const responses = new Map<string, ClientRequestCb<any, any>>()\n  const subscriptions = getSubscriptionsManager()\n\n  let connection: JsonRpcConnection | null = null\n\n  const send = (\n    id: string,\n    method: string,\n    params: Array<boolean | string | number | null>,\n  ) => {\n    connection!.send(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method,\n        params,\n      }),\n    )\n  }\n\n  function onMessage(message: string): void {\n    try {\n      let id: string,\n        result,\n        error: IRpcError | undefined,\n        params: { subscription: any; result: any; error?: IRpcError },\n        subscription: string\n\n      const parsed = JSON.parse(message)\n      ;({ id, result, error, params } = parsed)\n\n      if (id) {\n        const cb = responses.get(id)\n        if (!cb) return\n\n        responses.delete(id)\n\n        return error\n          ? cb.onError(new RpcError(error))\n          : cb.onSuccess(result, (opaqueId, subscriber) => {\n              const subscriptionId = opaqueId\n              subscriptions.subscribe(subscriptionId, subscriber)\n              return () => {\n                subscriptions.unsubscribe(subscriptionId)\n              }\n            })\n      }\n\n      // at this point, it means that it should be a notification\n      ;({ subscription, result, error } = params)\n      if (!subscription || (!error && !Object.hasOwn(params, \"result\"))) throw 0\n\n      const subscriptionId = subscription\n\n      if (error) {\n        subscriptions.error(subscriptionId, new RpcError(error!))\n      } else {\n        subscriptions.next(subscriptionId, result)\n      }\n    } catch (e) {\n      console.warn(\"Error parsing incomming message: \" + message)\n      console.error(e)\n    }\n  }\n  connection = gProvider(onMessage)\n\n  const disconnect = () => {\n    connection?.disconnect()\n    connection = null\n    subscriptions.errorAll(new DestroyedError())\n    responses.forEach((r) => r.onError(new DestroyedError()))\n    responses.clear()\n  }\n\n  let nextId = 1\n  const request = <T, TT>(\n    method: string,\n    params: Array<any>,\n    cb?: ClientRequestCb<T, TT>,\n  ): UnsubscribeFn => {\n    if (!connection) throw new Error(\"Not connected\")\n    const id = `${clientId}-${nextId++}`\n\n    if (cb) responses.set(id, cb)\n    send(id, method, params)\n\n    return (): void => {\n      responses.delete(id)\n    }\n  }\n\n  return {\n    request,\n    disconnect,\n  }\n}\n","import { ClientRequest } from \"./client\"\nimport { abortablePromiseFn } from \"./internal-utils\"\nimport { chainSpec } from \"./methods\"\n\nexport interface ChainSpecData {\n  name: string\n  genesisHash: string\n  properties: any\n}\n\nexport const createGetChainSpec = (clientRequest: ClientRequest<any, any>) => {\n  const request = abortablePromiseFn(\n    <T>(\n      onSuccess: (value: T) => void,\n      onError: (e: any) => void,\n      method: string,\n      params: any[],\n    ) => clientRequest(method, params, { onSuccess, onError }),\n  )\n  let cachedPromise: null | Promise<ChainSpecData> = null\n\n  return async (): Promise<ChainSpecData> => {\n    if (cachedPromise) return cachedPromise\n    return (cachedPromise = Promise.all([\n      request<string>(chainSpec.chainName, []),\n      request<string>(chainSpec.genesisHash, []),\n      request<any>(chainSpec.properties, []),\n    ]).then(([name, genesisHash, properties]) => ({\n      name,\n      genesisHash,\n      properties,\n    })))\n  }\n}\n","import type { ClientRequest } from \"@/client\"\nimport { UnsubscribeFn } from \"./common-types\"\nimport { noop } from \"./internal-utils\"\n\nexport const getCompatibilityEnhancer =\n  <T, E>(rpcMethodsP: Promise<Set<string>>, request: ClientRequest<T, E>) =>\n  (methods: Record<string, string>): ClientRequest<T, E> => {\n    let translations: Record<string, string> = {}\n    let enhancedRequest: ClientRequest<T, E> | null = null\n\n    return ((method, ...rest) => {\n      if (enhancedRequest) return enhancedRequest(method, ...rest)\n\n      let isRunning = true\n      let cleanup: UnsubscribeFn = () => {\n        isRunning = false\n      }\n\n      rpcMethodsP\n        .then((rpcMethods) => {\n          enhancedRequest = (method_, ...iRest) => {\n            const method = translations[method_] ?? method_\n            if (rpcMethods.has(method)) return request(method, ...iRest)\n            iRest[1]?.onError(new Error(`Unsupported method ${method}`))\n            return noop\n          }\n\n          if (rpcMethods.has(method)) return\n\n          const parts = method.split(\"_\")\n          if (parts[1] !== \"v1\") return\n\n          parts[1] = \"unstable\"\n\n          if (rpcMethods.has(parts.join(\"_\")))\n            Object.values(methods).forEach((value) => {\n              translations[value] = value.replace(\"_v1_\", \"_unstable_\")\n            })\n          else if (parts[0] === \"transaction\") {\n            // old versions of smoldot and Polkadot-SDK don't support transaction_xx_broadcast\n            // some old versions have `transactions_unstable_submitAndWatch` while others have `transaction_xx_submitAndWatch`\n            // if we find any of this options, then we will can use them as if they were broadast/stop\n            let unwatch: string | undefined\n            let version: string | undefined\n\n            const txGroup = [\"transactionWatch\", \"transaction\"].find(\n              (group) => {\n                version = [\"v1\", \"unstable\"].find((v) =>\n                  rpcMethods.has((unwatch = `${group}_${v}_unwatch`)),\n                )\n                return !!version\n              },\n            )\n\n            if (txGroup) {\n              translations[methods.broadcast] =\n                `${txGroup}_${version}_submitAndWatch`\n              translations[methods.stop] = unwatch!\n            }\n          }\n        })\n        .then(() => {\n          if (isRunning) cleanup = enhancedRequest!(method, ...rest)\n        })\n\n      return () => {\n        cleanup()\n      }\n    }) as ClientRequest<T, E>\n  }\n"],"mappings":"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","names":["createClient","fn","noop","noop","noop","import_utils","noop","subscriptionId","method","noop","import_utils","createClient"]}