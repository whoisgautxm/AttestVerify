"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  getChecksumBuilder: () => getChecksumBuilder,
  getDynamicBuilder: () => getDynamicBuilder,
  getLookupFn: () => getLookupFn
});
module.exports = __toCommonJS(src_exports);

// src/lookups.ts
var isBytes = (value, nBytes) => value.type === "array" && value.len === nBytes && value.value.type === "primitive" && value.value.value === "u8";
var _void = { type: "void" };
var getLookupFn = (lookupData) => {
  const lookups = /* @__PURE__ */ new Map();
  const from = /* @__PURE__ */ new Set();
  const withCache2 = (fn) => {
    return (id) => {
      let entry = lookups.get(id);
      if (entry) return entry;
      if (from.has(id)) {
        const entry2 = {
          id
        };
        lookups.set(id, entry2);
        return entry2;
      }
      from.add(id);
      const value = fn(id);
      entry = lookups.get(id);
      if (entry) {
        Object.assign(entry, value);
      } else {
        entry = {
          id,
          ...value
        };
        lookups.set(id, entry);
      }
      from.delete(id);
      return entry;
    };
  };
  let isAccountId32SearchOn = true;
  let isAccountId20SearchOn = true;
  const getLookupEntryDef = withCache2((id) => {
    const { def, path, params } = lookupData[id];
    if (def.tag === "composite") {
      if (def.value.length === 0) return _void;
      if (def.value.length === 1) {
        const inner = getLookupEntryDef(def.value[0].type);
        if (isAccountId32SearchOn && path.at(-1) === "AccountId32" && isBytes(inner, 32)) {
          isAccountId32SearchOn = false;
          return { type: "AccountId32" };
        }
        if (isAccountId20SearchOn && path.at(-1) === "AccountId20" && isBytes(inner, 20)) {
          isAccountId20SearchOn = false;
          return { type: "AccountId20" };
        }
        return inner;
      }
      return getComplexVar(def.value);
    }
    if (def.tag === "variant") {
      if (path.length === 1 && path[0] === "Option" && params.length === 1 && params[0].name === "T") {
        const value = getLookupEntryDef(params[0].type);
        return value.type === "void" ? (
          // Option<void> would return a Codec<undefined> which makes no sense
          // Therefore, we better treat it as a bool
          { type: "primitive", value: "bool" }
        ) : {
          type: "option",
          value
        };
      }
      if (path.length === 1 && path[0] === "Result" && params.length === 2 && params[0].name === "T" && params[1].name === "E") {
        return {
          type: "result",
          value: {
            ok: getLookupEntryDef(params[0].type),
            ko: getLookupEntryDef(params[1].type)
          }
        };
      }
      if (def.value.length === 0) return _void;
      const enumValue = {};
      const enumDocs = {};
      def.value.forEach((x) => {
        const key = x.name;
        enumDocs[key] = x.docs;
        if (x.fields.length === 0) {
          enumValue[key] = { ..._void, idx: x.index };
          return;
        }
        if (x.fields.length === 1 && !x.fields[0].name) {
          enumValue[key] = {
            type: "lookupEntry",
            value: getLookupEntryDef(x.fields[0].type),
            idx: x.index
          };
          return;
        }
        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index };
      });
      return {
        type: "enum",
        value: enumValue,
        innerDocs: enumDocs
      };
    }
    if (def.tag === "sequence")
      return {
        type: "sequence",
        value: getLookupEntryDef(def.value)
      };
    if (def.tag === "array") {
      const { len } = def.value;
      const value = getLookupEntryDef(def.value.type);
      return !len || value.type === "void" ? _void : len > 0 ? {
        type: "array",
        value,
        len: def.value.len
      } : value;
    }
    if (def.tag === "tuple") {
      if (def.value.length === 0) return _void;
      return def.value.length > 1 ? getArrayOrTuple(
        def.value.map((x) => getLookupEntryDef(x)),
        def.value.map((x) => lookupData[x].docs)
      ) : getLookupEntryDef(def.value[0]);
    }
    if (def.tag === "primitive") {
      return {
        type: "primitive",
        value: def.value.tag
      };
    }
    if (def.tag === "compact") {
      const translated = getLookupEntryDef(def.value);
      if (translated.type === "void") return { type: "compact", isBig: null };
      const isBig = Number(translated.value.slice(1)) > 32;
      return {
        type: "compact",
        isBig
      };
    }
    return {
      type: def.tag
    };
  });
  const getComplexVar = (input) => {
    let allKey = true;
    const values = {};
    const innerDocs = {};
    input.forEach((x, idx) => {
      allKey = allKey && !!x.name;
      const key = x.name || idx;
      const value = getLookupEntryDef(x.type);
      if (value.type !== "void") {
        values[key] = value;
        innerDocs[key] = x.docs;
      }
    });
    return allKey ? {
      type: "struct",
      value: values,
      innerDocs
    } : getArrayOrTuple(Object.values(values), Object.values(innerDocs));
  };
  const getArrayOrTuple = (values, innerDocs) => {
    if (values.every((v) => v.id === values[0].id) && innerDocs.every((doc) => !doc.length)) {
      const [value] = values;
      return value.type === "void" ? _void : {
        type: "array",
        value: values[0],
        len: values.length
      };
    }
    return {
      type: "tuple",
      value: values,
      innerDocs
    };
  };
  return getLookupEntryDef;
};

// src/dynamic-builder.ts
var scale = __toESM(require("@polkadot-api/substrate-bindings"));

// src/with-cache.ts
var withCache = (fn, onEnterCircular, onExitCircular) => (input, cache, stack, ...rest) => {
  const { id } = input;
  if (cache.has(id)) return cache.get(id);
  if (stack.has(id)) {
    const res = onEnterCircular(() => cache.get(id), input, ...rest);
    cache.set(id, res);
    return res;
  }
  stack.add(id);
  let result = fn(input, cache, stack, ...rest);
  stack.delete(id);
  if (cache.has(id))
    result = onExitCircular(result, cache.get(id), input, ...rest);
  cache.set(id, result);
  return result;
};

// src/dynamic-builder.ts
var import_utils = require("@polkadot-api/utils");
var _bytes = scale.Bin();
var bigCompact = scale.createCodec(
  scale.compact[0],
  scale.enhanceDecoder(scale.compact[1], BigInt)
);
var _buildCodec = (input, cache, stack, _accountId) => {
  if (input.type === "primitive") return scale[input.value];
  if (input.type === "void") return scale._void;
  if (input.type === "AccountId32") return _accountId;
  if (input.type === "AccountId20") return scale.ethAccount;
  if (input.type === "compact") return input.isBig ? bigCompact : scale.compact;
  if (input.type === "bitSequence") return scale.bitSequence;
  const buildNextCodec = (nextInput) => buildCodec(nextInput, cache, stack, _accountId);
  const buildVector = (inner2, len) => {
    const innerCodec = buildNextCodec(inner2);
    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec);
  };
  const buildTuple = (value) => scale.Tuple(...value.map(buildNextCodec));
  const buildStruct = (value) => {
    const inner2 = Object.fromEntries(
      Object.entries(value).map(([key, value2]) => [key, buildNextCodec(value2)])
    );
    return scale.Struct(inner2);
  };
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return _bytes;
  }
  if (input.type === "array") {
    if (input.value.type === "primitive" && input.value.value === "u8")
      return scale.Bin(input.len);
    return buildVector(input.value, input.len);
  }
  if (input.type === "sequence") return buildVector(input.value);
  if (input.type === "tuple") return buildTuple(input.value);
  if (input.type === "struct") return buildStruct(input.value);
  if (input.type === "option") return scale.Option(buildNextCodec(input.value));
  if (input.type === "result")
    return scale.Result(
      buildNextCodec(input.value.ok),
      buildNextCodec(input.value.ko)
    );
  const dependencies = Object.values(input.value).map((v) => {
    switch (v.type) {
      case "void":
        return scale._void;
      case "lookupEntry":
        return buildNextCodec(v.value);
      case "tuple":
        return buildTuple(v.value);
      case "struct":
        return buildStruct(v.value);
      case "array":
        return buildVector(v.value, v.len);
    }
  });
  const inner = Object.fromEntries(
    Object.keys(input.value).map((key, idx) => {
      return [key, dependencies[idx]];
    })
  );
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  return areIndexesSorted ? scale.Variant(inner) : scale.Variant(inner, indexes);
};
var buildCodec = withCache(_buildCodec, scale.Self, (res) => res);
var getDynamicBuilder = (metadata) => {
  const lookupData = metadata.lookup;
  const getLookupEntryDef = getLookupFn(lookupData);
  let _accountId = scale.AccountId();
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildCodec(getLookupEntryDef(id), cache, /* @__PURE__ */ new Set(), _accountId);
  const prefix = metadata.pallets.find((x) => x.name === "System")?.constants.find((x) => x.name === "SS58Prefix");
  let ss58Prefix;
  if (prefix) {
    try {
      const prefixVal = buildDefinition(prefix.type).dec(prefix.value);
      if (typeof prefixVal === "number") {
        ss58Prefix = prefixVal;
        _accountId = scale.AccountId(prefixVal);
      }
    } catch (_) {
    }
  }
  const storagePallets = /* @__PURE__ */ new Map();
  const buildStorage = (pallet, entry) => {
    let storagePallet = storagePallets.get(pallet);
    if (!storagePallet)
      storagePallets.set(pallet, storagePallet = scale.Storage(pallet));
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
    const storageWithFallback = (len, ...args) => {
      const result = storagePallet(...args);
      return {
        ...result,
        len,
        fallback: storageEntry.modifier === 1 ? result.dec(storageEntry.fallback) : void 0
      };
    };
    if (storageEntry.type.tag === "plain")
      return storageWithFallback(
        0,
        entry,
        buildDefinition(storageEntry.type.value).dec
      );
    const { key, value, hashers } = storageEntry.type.value;
    const val = buildDefinition(value);
    const hashes = hashers.map((x) => scale[x.tag]);
    const hashArgs = (() => {
      if (hashes.length === 1) {
        return [[buildDefinition(key), hashes[0]]];
      }
      const keyDef = getLookupEntryDef(key);
      switch (keyDef.type) {
        case "array":
          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash]);
        case "tuple":
          return keyDef.value.map((x, idx) => [
            buildDefinition(x.id),
            hashes[idx]
          ]);
        default:
          throw new Error("Invalid key type");
      }
    })();
    return storageWithFallback(hashes.length, entry, val.dec, ...hashArgs);
  };
  const buildEnumEntry = (entry) => {
    switch (entry.type) {
      case "void":
        return scale._void;
      case "lookupEntry":
        return buildDefinition(entry.value.id);
      case "tuple":
        return scale.Tuple(
          ...Object.values(entry.value).map((l) => buildDefinition(l.id))
        );
      case "struct":
        return scale.Struct(
          (0, import_utils.mapObject)(entry.value, (x) => buildDefinition(x.id))
        );
      case "array":
        return scale.Vector(buildDefinition(entry.value.id), entry.len);
    }
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildDefinition(storageEntry.type);
  };
  const buildVariant = (type) => (pallet, name) => {
    const palletEntry = metadata.pallets.find((x) => x.name === pallet);
    const lookup = getLookupEntryDef(palletEntry[type]);
    if (lookup.type !== "enum") throw null;
    const entry = lookup.value[name];
    return {
      location: [palletEntry.index, entry.idx],
      codec: buildEnumEntry(lookup.value[name])
    };
  };
  const buildRuntimeCall = (api, method) => {
    const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
    if (!entry) throw null;
    return {
      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),
      value: buildDefinition(entry.output)
    };
  };
  return {
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildRuntimeCall,
    buildCall: buildVariant("calls"),
    buildConstant,
    ss58Prefix
  };
};

// src/checksum-builder.ts
var import_substrate_bindings = require("@polkadot-api/substrate-bindings");

// src/lookup-graph.ts
function buildLookupGraph(lookupFn, lookupLength) {
  const result = /* @__PURE__ */ new Map();
  const visited = /* @__PURE__ */ new Set();
  const addEdge = (from, to) => {
    if (!result.has(from))
      result.set(from, {
        entry: lookupFn(from),
        backRefs: /* @__PURE__ */ new Set(),
        refs: /* @__PURE__ */ new Set()
      });
    if (!result.has(to))
      result.set(to, {
        entry: lookupFn(to),
        backRefs: /* @__PURE__ */ new Set(),
        refs: /* @__PURE__ */ new Set()
      });
    result.get(from).refs.add(to);
    result.get(to).backRefs.add(from);
  };
  for (let i = 0; i < lookupLength; i++) {
    const entry = lookupFn(i);
    if (i !== entry.id) {
      addEdge(i, entry.id);
    }
    if (visited.has(entry.id)) continue;
    visited.add(entry.id);
    switch (entry.type) {
      case "array":
      case "option":
      case "sequence":
        addEdge(entry.id, entry.value.id);
        break;
      case "enum":
        Object.values(entry.value).forEach((enumEntry) => {
          switch (enumEntry.type) {
            case "array":
            case "lookupEntry":
              addEdge(entry.id, enumEntry.value.id);
              break;
            case "struct":
            case "tuple":
              Object.values(enumEntry.value).forEach(
                (v) => addEdge(entry.id, v.id)
              );
              break;
          }
        });
        break;
      case "result":
        addEdge(entry.id, entry.value.ok.id);
        addEdge(entry.id, entry.value.ko.id);
        break;
      case "struct":
      case "tuple":
        Object.values(entry.value).forEach((v) => addEdge(entry.id, v.id));
        break;
    }
    if (!result.has(entry.id)) {
      result.set(entry.id, {
        backRefs: /* @__PURE__ */ new Set(),
        refs: /* @__PURE__ */ new Set(),
        entry
      });
    }
  }
  return result;
}
var subgraphCache = /* @__PURE__ */ new WeakMap();
function _getSubgraph(id, graph, result, cache) {
  if (result.has(id)) return;
  const node = graph.get(id);
  result.set(id, node);
  cache.set(id, result);
  node.refs.forEach((ref) => _getSubgraph(ref, graph, result, cache));
  node.backRefs.forEach((ref) => _getSubgraph(ref, graph, result, cache));
}
function getSubgraph(id, graph) {
  if (!subgraphCache.has(graph)) {
    subgraphCache.set(graph, /* @__PURE__ */ new Map());
  }
  const cache = subgraphCache.get(graph);
  if (cache.has(id)) return cache.get(id);
  const result = /* @__PURE__ */ new Map();
  _getSubgraph(id, graph, result, cache);
  return result;
}
function getStronglyConnectedComponents(graph) {
  const tarjanState = /* @__PURE__ */ new Map();
  let index = 0;
  const stack = [];
  const result = [];
  function strongConnect(v) {
    const state = {
      index,
      lowLink: index,
      onStack: true
    };
    tarjanState.set(v, state);
    index++;
    stack.push(v);
    const edges = graph.get(v).refs;
    for (let w of edges) {
      const edgeState = tarjanState.get(w);
      if (!edgeState) {
        strongConnect(w);
        state.lowLink = Math.min(state.lowLink, tarjanState.get(w).lowLink);
      } else if (edgeState.onStack) {
        state.lowLink = Math.min(state.lowLink, edgeState.index);
      }
    }
    if (state.lowLink === state.index) {
      const component = /* @__PURE__ */ new Set();
      let poppedNode = -1;
      do {
        poppedNode = stack.pop();
        tarjanState.get(poppedNode).onStack = false;
        component.add(poppedNode);
      } while (poppedNode !== v);
      if (component.size > 1) result.push(component);
    }
  }
  for (const node of graph.keys()) {
    if (!tarjanState.has(node)) {
      strongConnect(node);
    }
  }
  return result;
}
function mergeSCCsWithCommonNodes(stronglyConnectedComponents) {
  const scc = stronglyConnectedComponents;
  const ungroupedCycles = new Set(scc.map((_, i) => i));
  const edges = new Map(scc.map((_, i) => [i, /* @__PURE__ */ new Set()]));
  scc.forEach((cycle, i) => {
    scc.slice(i + 1).forEach((otherCycle, _j) => {
      const j = _j + i + 1;
      const combined = /* @__PURE__ */ new Set([...cycle, ...otherCycle]);
      if (combined.size !== cycle.size + otherCycle.size) {
        edges.get(i).add(j);
        edges.get(j).add(i);
      }
    });
  });
  const groups = [];
  while (ungroupedCycles.size) {
    const group = /* @__PURE__ */ new Set();
    const toVisit = [ungroupedCycles.values().next().value];
    while (toVisit.length) {
      const idx = toVisit.pop();
      if (!ungroupedCycles.has(idx)) continue;
      ungroupedCycles.delete(idx);
      const cycle = scc[idx];
      cycle.forEach((v) => group.add(Number(v)));
      edges.get(idx).forEach((n) => toVisit.push(n));
    }
    groups.push(group);
  }
  return groups;
}

// src/checksum-builder.ts
var textEncoder = new TextEncoder();
var encodeText = textEncoder.encode.bind(textEncoder);
var getChecksum = (values) => {
  const res = new Uint8Array(values.length * 8);
  const dv = new DataView(res.buffer);
  for (let i = 0; i < values.length; i++) dv.setBigUint64(i * 8, values[i]);
  return (0, import_substrate_bindings.h64)(res);
};
var getStringChecksum = (values) => getChecksum(values.map((v) => (0, import_substrate_bindings.h64)(encodeText(v))));
var shapeIds = {
  primitive: 0n,
  vector: 1n,
  tuple: 2n,
  struct: 3n,
  option: 4n,
  result: 5n,
  enum: 6n,
  void: 7n
};
var runtimePrimitiveIds = {
  undefined: 0n,
  number: 1n,
  string: 2n,
  bigint: 3n,
  boolean: 4n,
  bitSequence: 5n,
  // {bitsLen: number, bytes: Uint8Array}
  byteSequence: 6n,
  // Binary
  accountId32: 7n,
  // SS58String
  accountId20: 8n
  // EthAccount
};
var metadataPrimitiveIds = {
  bool: runtimePrimitiveIds.boolean,
  char: runtimePrimitiveIds.string,
  str: runtimePrimitiveIds.string,
  u8: runtimePrimitiveIds.number,
  u16: runtimePrimitiveIds.number,
  u32: runtimePrimitiveIds.number,
  u64: runtimePrimitiveIds.bigint,
  u128: runtimePrimitiveIds.bigint,
  u256: runtimePrimitiveIds.bigint,
  i8: runtimePrimitiveIds.number,
  i16: runtimePrimitiveIds.number,
  i32: runtimePrimitiveIds.number,
  i64: runtimePrimitiveIds.bigint,
  i128: runtimePrimitiveIds.bigint,
  i256: runtimePrimitiveIds.bigint
};
var structLikeBuilder = (shapeId, input, innerChecksum) => {
  const sortedEntries = Object.entries(input).sort(
    ([a], [b]) => a.localeCompare(b)
  );
  const keysChecksum = getStringChecksum(sortedEntries.map(([key]) => key));
  const valuesChecksum = getChecksum(
    sortedEntries.map(([, entry]) => innerChecksum(entry))
  );
  return getChecksum([shapeId, keysChecksum, valuesChecksum]);
};
var _buildChecksum = (input, buildNextChecksum) => {
  if (input.type === "primitive")
    return getChecksum([shapeIds.primitive, metadataPrimitiveIds[input.value]]);
  if (input.type === "void") return getChecksum([shapeIds.void]);
  if (input.type === "compact")
    return getChecksum([
      shapeIds.primitive,
      runtimePrimitiveIds[input.isBig || input.isBig === null ? "bigint" : "number"]
    ]);
  if (input.type === "bitSequence")
    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.bitSequence]);
  if (input.type === "AccountId32") {
    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId32]);
  }
  if (input.type === "AccountId20") {
    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId20]);
  }
  const buildVector = (entry, length) => {
    const innerChecksum = buildNextChecksum(entry);
    return getChecksum(
      length !== void 0 ? [shapeIds.vector, innerChecksum, BigInt(length)] : [shapeIds.vector, innerChecksum]
    );
  };
  if (input.type === "array") {
    const innerValue = input.value;
    if (innerValue.type === "primitive" && innerValue.value === "u8") {
      return getChecksum([
        shapeIds.primitive,
        runtimePrimitiveIds.byteSequence,
        BigInt(input.len)
      ]);
    }
    return buildVector(innerValue, input.len);
  }
  if (input.type === "sequence") {
    const innerValue = input.value;
    if (innerValue.type === "primitive" && innerValue.value === "u8") {
      return getChecksum([shapeIds.primitive, runtimePrimitiveIds.byteSequence]);
    }
    return buildVector(innerValue);
  }
  const buildTuple = (entries) => getChecksum([shapeIds.tuple, ...entries.map(buildNextChecksum)]);
  const buildStruct = (entries) => structLikeBuilder(shapeIds.struct, entries, buildNextChecksum);
  if (input.type === "tuple") return buildTuple(input.value);
  if (input.type === "struct") return buildStruct(input.value);
  if (input.type === "option")
    return getChecksum([shapeIds.option, buildNextChecksum(input.value)]);
  if (input.type === "result")
    return getChecksum([
      shapeIds.result,
      buildNextChecksum(input.value.ok),
      buildNextChecksum(input.value.ko)
    ]);
  return structLikeBuilder(shapeIds.enum, input.value, (entry) => {
    if (entry.type === "lookupEntry") return buildNextChecksum(entry.value);
    switch (entry.type) {
      case "void":
        return getChecksum([shapeIds.void]);
      case "tuple":
        return buildTuple(entry.value);
      case "struct":
        return buildStruct(entry.value);
      case "array":
        return buildVector(entry.value, entry.len);
    }
  });
};
var sortCyclicGroups = (groups, graph) => {
  const getReachableNodes = (group) => {
    const result2 = /* @__PURE__ */ new Set();
    const toVisit = Array.from(group);
    while (toVisit.length) {
      const id = toVisit.pop();
      if (result2.has(id)) continue;
      result2.add(id);
      graph.get(id)?.refs.forEach((id2) => toVisit.push(id2));
    }
    return Array.from(result2);
  };
  const result = new Array();
  function dependentsFirst(group) {
    if (result.includes(group)) return;
    const dependents = groups.filter(
      (candidate) => candidate !== group && getReachableNodes(group).some((node) => candidate.has(node))
    );
    dependents.forEach((group2) => dependentsFirst(group2));
    if (result.includes(group)) return;
    result.push(group);
  }
  groups.forEach((group) => dependentsFirst(group));
  return result;
};
function iterateChecksums(group, iterations, cache, graph) {
  const groupReadCache = new Map([...group].map((id) => [id, 0n]));
  const groupWriteCache = /* @__PURE__ */ new Map();
  const recursiveBuildChecksum = (entry, skipCache = true) => {
    if (!skipCache && (groupReadCache.has(entry.id) || cache.has(entry.id))) {
      return groupReadCache.get(entry.id) ?? cache.get(entry.id);
    }
    const result = _buildChecksum(
      entry,
      (nextEntry) => recursiveBuildChecksum(nextEntry, false)
    );
    if (group.has(entry.id)) {
      groupWriteCache.set(entry.id, result);
    } else {
      cache.set(entry.id, result);
    }
    return result;
  };
  for (let i = 0; i < iterations; i++) {
    group.forEach((id) => recursiveBuildChecksum(graph.get(id).entry));
    group.forEach((id) => groupReadCache.set(id, groupWriteCache.get(id)));
  }
  return groupReadCache;
}
function getMirroredNodes(cyclicGroups, graph) {
  const maxSize = cyclicGroups.reduce(
    (acc, group) => Math.max(acc, group.size),
    0
  );
  const allEntries = new Set([...graph.values()].map((v) => v.entry.id));
  const resultingChecksums = iterateChecksums(
    allEntries,
    maxSize,
    // Cache won't be used, since it's using the internal one for every node.
    /* @__PURE__ */ new Map(),
    graph
  );
  const checksumToNodes = /* @__PURE__ */ new Map();
  for (const id of allEntries) {
    const checksum = resultingChecksums.get(id);
    if (checksum == void 0) throw new Error("Unreachable");
    if (!checksumToNodes.has(checksum)) {
      checksumToNodes.set(checksum, []);
    }
    checksumToNodes.get(checksum).push(id);
  }
  const checksumsWithDuplicates = [...checksumToNodes.entries()].filter(
    ([, nodes]) => nodes.length > 1
  );
  const duplicatesMap = {};
  checksumsWithDuplicates.forEach(([, nodes]) => {
    nodes.forEach((n) => duplicatesMap[n] = nodes);
  });
  return duplicatesMap;
}
var buildChecksum = (entry, cache, graph) => {
  if (cache.has(entry.id)) return cache.get(entry.id);
  const subGraph = getSubgraph(entry.id, graph);
  const cycles = getStronglyConnectedComponents(subGraph);
  const cyclicGroups = mergeSCCsWithCommonNodes(cycles).filter((group) => {
    return !cache.has(group.values().next().value);
  });
  const mirrored = getMirroredNodes(cyclicGroups, subGraph);
  const sortedCyclicGroups = sortCyclicGroups(
    cyclicGroups.filter((group) => group.size > 1),
    subGraph
  );
  sortedCyclicGroups.forEach((group) => {
    if (cache.has(group.values().next().value)) {
      return;
    }
    const result = iterateChecksums(group, group.size, cache, graph);
    group.forEach((id) => {
      const checksum = result.get(id);
      if (id in mirrored) {
        mirrored[id].forEach((id2) => cache.set(id2, checksum));
      } else {
        cache.set(id, checksum);
      }
    });
  });
  const getChecksum2 = (entry2) => {
    if (cache.has(entry2.id)) return cache.get(entry2.id);
    return _buildChecksum(entry2, getChecksum2);
  };
  return getChecksum2(entry);
};
var getChecksumBuilder = (metadata) => {
  const lookupData = metadata.lookup;
  const getLookupEntryDef = getLookupFn(lookupData);
  const graph = buildLookupGraph(getLookupEntryDef, lookupData.length);
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildChecksum(getLookupEntryDef(id), cache, graph);
  const buildStorage = (pallet, entry) => {
    try {
      const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
      if (storageEntry.type.tag === "plain")
        return buildDefinition(storageEntry.type.value);
      const { key, value } = storageEntry.type.value;
      const val = buildDefinition(value);
      const returnKey = buildDefinition(key);
      return getChecksum([val, returnKey]);
    } catch (_) {
      return null;
    }
  };
  const buildRuntimeCall = (api, method) => {
    try {
      const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
      if (!entry) throw null;
      const argNamesChecksum = getStringChecksum(
        entry.inputs.map((x) => x.name)
      );
      const argValuesChecksum = getChecksum(
        entry.inputs.map((x) => buildDefinition(x.type))
      );
      const outputChecksum = buildDefinition(entry.output);
      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum]);
    } catch (_) {
      return null;
    }
  };
  const buildComposite = (input) => {
    if (input.type === "void") return getChecksum([0n]);
    if (input.type === "tuple") {
      const values = Object.values(input.value).map(
        (entry) => buildDefinition(entry.id)
      );
      return getChecksum([shapeIds.tuple, ...values]);
    }
    if (input.type === "array") {
      return getChecksum([
        shapeIds.vector,
        buildDefinition(input.value.id),
        BigInt(input.len)
      ]);
    }
    return structLikeBuilder(
      shapeIds.struct,
      input.value,
      (entry) => buildDefinition(entry.id)
    );
  };
  const buildNamedTuple = (input) => {
    return structLikeBuilder(
      shapeIds.tuple,
      input.value,
      (entry) => buildDefinition(entry.id)
    );
  };
  const buildVariant = (variantType) => (pallet, name) => {
    try {
      const palletEntry = metadata.pallets.find((x) => x.name === pallet);
      const enumLookup = getLookupEntryDef(
        palletEntry[variantType]
      );
      buildDefinition(enumLookup.id);
      if (enumLookup.type !== "enum") throw null;
      const entry = enumLookup.value[name];
      return entry.type === "lookupEntry" ? buildDefinition(entry.value.id) : buildComposite(entry);
    } catch (_) {
      return null;
    }
  };
  const buildConstant = (pallet, constantName) => {
    try {
      const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
      return buildDefinition(storageEntry.type);
    } catch (_) {
      return null;
    }
  };
  const toStringEnhancer = (fn) => (...args) => fn(...args)?.toString(32) ?? null;
  return {
    buildDefinition: toStringEnhancer(buildDefinition),
    buildRuntimeCall: toStringEnhancer(buildRuntimeCall),
    buildStorage: toStringEnhancer(buildStorage),
    buildCall: toStringEnhancer(buildVariant("calls")),
    buildEvent: toStringEnhancer(buildVariant("events")),
    buildError: toStringEnhancer(buildVariant("errors")),
    buildConstant: toStringEnhancer(buildConstant),
    buildComposite: toStringEnhancer(buildComposite),
    buildNamedTuple: toStringEnhancer(buildNamedTuple),
    getAllGeneratedChecksums: () => Array.from(cache.values()).map((v) => v.toString(32))
  };
};
//# sourceMappingURL=index.js.map