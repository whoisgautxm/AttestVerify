{"version":3,"sources":["../src/index.ts","../src/lookups.ts","../src/dynamic-builder.ts","../src/with-cache.ts","../src/checksum-builder.ts","../src/lookup-graph.ts"],"sourcesContent":["export * from \"./lookups\"\nexport * from \"./dynamic-builder\"\nexport * from \"./checksum-builder\"\n","import type { StringRecord, V14Lookup } from \"@polkadot-api/substrate-bindings\"\n\nexport type MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | \"u8\"\n  | \"u16\"\n  | \"u32\"\n  | \"u64\"\n  | \"u128\"\n  | \"u256\"\n  | \"i8\"\n  | \"i16\"\n  | \"i32\"\n  | \"i64\"\n  | \"i128\"\n  | \"i256\"\n\nexport type PrimitiveVar = {\n  type: \"primitive\"\n  value: MetadataPrimitives\n}\n\nexport type VoidVar = { type: \"void\" }\nexport type CompactVar = { type: \"compact\"; isBig: boolean | null }\nexport type BitSequenceVar = { type: \"bitSequence\" }\nexport type AccountId32 = { type: \"AccountId32\" }\nexport type AccountId20 = { type: \"AccountId20\" }\nexport type TerminalVar =\n  | PrimitiveVar\n  | VoidVar\n  | CompactVar\n  | BitSequenceVar\n  | AccountId32\n  | AccountId20\n\n/* Array-like vars:\n * - TupleVar: Mixed types, fixed length\n * - Sequence: One type, arbitrary length\n * - Array: One type, fixed length\n */\nexport type TupleVar = {\n  type: \"tuple\"\n  value: LookupEntry[]\n  innerDocs: Array<string[]>\n}\nexport type StructVar = {\n  type: \"struct\"\n  value: StringRecord<LookupEntry>\n  innerDocs: StringRecord<string[]>\n}\nexport type EnumVar = {\n  type: \"enum\"\n  value: StringRecord<\n    (\n      | { type: \"lookupEntry\"; value: LookupEntry }\n      | VoidVar\n      | TupleVar\n      | StructVar\n      | ArrayVar\n    ) & { idx: number }\n  >\n  innerDocs: StringRecord<string[]>\n}\nexport type OptionVar = {\n  type: \"option\"\n  value: LookupEntry\n}\nexport type ResultVar = {\n  type: \"result\"\n  value: { ok: LookupEntry; ko: LookupEntry }\n}\nexport type SequenceVar = {\n  type: \"sequence\"\n  value: LookupEntry\n}\nexport type ArrayVar = {\n  type: \"array\"\n  value: LookupEntry\n  len: number\n}\n\nexport type ComposedVar =\n  | TupleVar\n  | StructVar\n  | SequenceVar\n  | ArrayVar\n  | OptionVar\n  | ResultVar\n  | EnumVar\n\nexport type Var = TerminalVar | ComposedVar\n\nexport type LookupEntry = {\n  id: number\n} & Var\n\nconst isBytes = (value: LookupEntry, nBytes: number) =>\n  value.type === \"array\" &&\n  value.len === nBytes &&\n  value.value.type === \"primitive\" &&\n  value.value.value === \"u8\"\n\nconst _void: VoidVar = { type: \"void\" }\n\nexport const getLookupFn = (lookupData: V14Lookup) => {\n  const lookups = new Map<number, LookupEntry>()\n  const from = new Set<number>()\n\n  const withCache = (\n    fn: (id: number) => Var,\n  ): ((id: number) => LookupEntry) => {\n    return (id) => {\n      let entry = lookups.get(id)\n\n      if (entry) return entry\n\n      if (from.has(id)) {\n        const entry = {\n          id,\n        } as LookupEntry\n\n        lookups.set(id, entry)\n        return entry\n      }\n\n      from.add(id)\n      const value = fn(id)\n      entry = lookups.get(id)\n\n      if (entry) {\n        Object.assign(entry, value)\n      } else {\n        entry = {\n          id,\n          ...value,\n        }\n        lookups.set(id, entry!)\n      }\n      from.delete(id)\n      return entry\n    }\n  }\n\n  let isAccountId32SearchOn = true\n  let isAccountId20SearchOn = true\n  const getLookupEntryDef = withCache((id): Var => {\n    const { def, path, params } = lookupData[id]\n\n    if (def.tag === \"composite\") {\n      if (def.value.length === 0) return _void\n\n      // used to be a \"pointer\"\n      if (def.value.length === 1) {\n        const inner = getLookupEntryDef(def.value[0].type as number)\n\n        if (\n          isAccountId32SearchOn &&\n          path.at(-1) === \"AccountId32\" &&\n          isBytes(inner, 32)\n        ) {\n          isAccountId32SearchOn = false\n          return { type: \"AccountId32\" }\n        }\n\n        if (\n          isAccountId20SearchOn &&\n          path.at(-1) === \"AccountId20\" &&\n          isBytes(inner, 20)\n        ) {\n          isAccountId20SearchOn = false\n          return { type: \"AccountId20\" }\n        }\n\n        return inner\n      }\n\n      return getComplexVar(def.value)\n    }\n\n    if (def.tag === \"variant\") {\n      if (\n        path.length === 1 &&\n        path[0] === \"Option\" &&\n        params.length === 1 &&\n        params[0].name === \"T\"\n      ) {\n        const value = getLookupEntryDef(params[0].type!)\n        return value.type === \"void\"\n          ? // Option<void> would return a Codec<undefined> which makes no sense\n            // Therefore, we better treat it as a bool\n            { type: \"primitive\", value: \"bool\" }\n          : {\n              type: \"option\",\n              value,\n            }\n      }\n\n      if (\n        path.length === 1 &&\n        path[0] === \"Result\" &&\n        params.length === 2 &&\n        params[0].name === \"T\" &&\n        params[1].name === \"E\"\n      ) {\n        return {\n          type: \"result\",\n          value: {\n            ok: getLookupEntryDef(params[0].type as number),\n            ko: getLookupEntryDef(params[1].type as number),\n          },\n        }\n      }\n      if (def.value.length === 0) return _void\n\n      const enumValue: StringRecord<EnumVar[\"value\"][keyof EnumVar[\"value\"]]> =\n        {}\n      const enumDocs: StringRecord<string[]> = {}\n\n      def.value.forEach((x) => {\n        const key = x.name\n        enumDocs[key] = x.docs\n\n        if (x.fields.length === 0) {\n          enumValue[key] = { ..._void, idx: x.index }\n          return\n        }\n\n        if (x.fields.length === 1 && !x.fields[0].name) {\n          enumValue[key] = {\n            type: \"lookupEntry\",\n            value: getLookupEntryDef(x.fields[0].type),\n            idx: x.index,\n          }\n          return\n        }\n\n        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index }\n      })\n\n      return {\n        type: \"enum\",\n        value: enumValue,\n        innerDocs: enumDocs,\n      }\n    }\n\n    if (def.tag === \"sequence\")\n      return {\n        type: \"sequence\",\n        value: getLookupEntryDef(def.value as number),\n      }\n\n    if (def.tag === \"array\") {\n      const { len } = def.value\n      const value = getLookupEntryDef(def.value.type)\n\n      return !len || value.type === \"void\"\n        ? _void\n        : len > 0\n          ? {\n              type: \"array\",\n              value,\n              len: def.value.len,\n            }\n          : value\n    }\n\n    if (def.tag === \"tuple\") {\n      if (def.value.length === 0) return _void\n\n      return def.value.length > 1\n        ? getArrayOrTuple(\n            def.value.map((x) => getLookupEntryDef(x as number)),\n            def.value.map((x) => lookupData[x].docs),\n          )\n        : getLookupEntryDef(def.value[0] as number) // use to be a \"pointer\"\n    }\n\n    if (def.tag === \"primitive\") {\n      return {\n        type: \"primitive\",\n        value: def.value.tag,\n      }\n    }\n\n    if (def.tag === \"compact\") {\n      const translated = getLookupEntryDef(def.value) as PrimitiveVar | VoidVar\n      if (translated.type === \"void\") return { type: \"compact\", isBig: null }\n\n      const isBig = Number(translated.value.slice(1)) > 32\n\n      return {\n        type: \"compact\",\n        isBig,\n      }\n    }\n\n    // bitSequence\n    return {\n      type: def.tag,\n    }\n  })\n\n  const getComplexVar = (\n    input: Array<{ type: number; name?: string; docs: string[] }>,\n  ): TupleVar | StructVar | ArrayVar | VoidVar => {\n    let allKey = true\n\n    const values: Record<string | number, LookupEntry> = {}\n    const innerDocs: Record<string | number, string[]> = {}\n\n    input.forEach((x, idx) => {\n      allKey = allKey && !!x.name\n      const key = x.name || idx\n      const value = getLookupEntryDef(x.type as number)\n      if (value.type !== \"void\") {\n        values[key] = value\n        innerDocs[key] = x.docs\n      }\n    })\n    return allKey\n      ? {\n          type: \"struct\",\n          value: values as StringRecord<LookupEntry>,\n          innerDocs: innerDocs as StringRecord<string[]>,\n        }\n      : getArrayOrTuple(Object.values(values), Object.values(innerDocs))\n  }\n\n  const getArrayOrTuple = (\n    values: Array<LookupEntry>,\n    innerDocs: Array<string[]>,\n  ): TupleVar | ArrayVar | VoidVar => {\n    if (\n      values.every((v) => v.id === values[0].id) &&\n      innerDocs.every((doc) => !doc.length)\n    ) {\n      const [value] = values\n      return value.type === \"void\"\n        ? _void\n        : {\n            type: \"array\",\n            value: values[0],\n            len: values.length,\n          }\n    }\n    return {\n      type: \"tuple\",\n      value: values,\n      innerDocs: innerDocs,\n    }\n  }\n\n  return getLookupEntryDef\n}\n","import type {\n  Codec,\n  StringRecord,\n  V15,\n  V14,\n} from \"@polkadot-api/substrate-bindings\"\nimport type { EnumVar, LookupEntry } from \"./lookups\"\nimport { getLookupFn } from \"./lookups\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport { withCache } from \"./with-cache\"\nimport { mapObject } from \"@polkadot-api/utils\"\n\nconst _bytes = scale.Bin()\n\nconst bigCompact = scale.createCodec(\n  scale.compact[0],\n  scale.enhanceDecoder(scale.compact[1], BigInt),\n)\n\nconst _buildCodec = (\n  input: LookupEntry,\n  cache: Map<number, Codec<any>>,\n  stack: Set<number>,\n  _accountId: Codec<scale.SS58String>,\n): Codec<any> => {\n  if (input.type === \"primitive\") return scale[input.value]\n  if (input.type === \"void\") return scale._void\n  if (input.type === \"AccountId32\") return _accountId\n  if (input.type === \"AccountId20\") return scale.ethAccount\n  if (input.type === \"compact\") return input.isBig ? bigCompact : scale.compact\n  if (input.type === \"bitSequence\") return scale.bitSequence\n\n  const buildNextCodec = (nextInput: LookupEntry): Codec<any> =>\n    buildCodec(nextInput, cache, stack, _accountId)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const innerCodec = buildNextCodec(inner)\n    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec)\n  }\n\n  const buildTuple = (value: LookupEntry[]) =>\n    scale.Tuple(...value.map(buildNextCodec))\n\n  const buildStruct = (value: StringRecord<LookupEntry>) => {\n    const inner = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, buildNextCodec(value)]),\n    ) as StringRecord<Codec<any>>\n    return scale.Struct(inner)\n  }\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return _bytes\n  }\n\n  if (input.type === \"array\") {\n    // Bytes case\n    if (input.value.type === \"primitive\" && input.value.value === \"u8\")\n      return scale.Bin(input.len)\n\n    return buildVector(input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value)\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\") return scale.Option(buildNextCodec(input.value))\n\n  if (input.type === \"result\")\n    return scale.Result(\n      buildNextCodec(input.value.ok),\n      buildNextCodec(input.value.ko),\n    )\n\n  // it has to be an enum by now\n  const dependencies = Object.values(input.value).map((v) => {\n    switch (v.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildNextCodec(v.value)\n      case \"tuple\":\n        return buildTuple(v.value)\n      case \"struct\":\n        return buildStruct(v.value)\n      case \"array\":\n        return buildVector(v.value, v.len)\n    }\n  })\n\n  const inner = Object.fromEntries(\n    Object.keys(input.value).map((key, idx) => {\n      return [key, dependencies[idx]]\n    }),\n  ) as StringRecord<Codec<any>>\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  return areIndexesSorted\n    ? scale.Variant(inner)\n    : scale.Variant(inner, indexes as any)\n}\nconst buildCodec = withCache(_buildCodec, scale.Self, (res) => res)\n\nexport const getDynamicBuilder = (metadata: V14 | V15) => {\n  const lookupData = metadata.lookup\n  const getLookupEntryDef = getLookupFn(lookupData)\n  let _accountId = scale.AccountId()\n\n  const cache = new Map()\n  const buildDefinition = (id: number): Codec<any> =>\n    buildCodec(getLookupEntryDef(id), cache, new Set(), _accountId)\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n\n  let ss58Prefix: number | undefined\n  if (prefix) {\n    try {\n      const prefixVal = buildDefinition(prefix.type).dec(prefix.value)\n      if (typeof prefixVal === \"number\") {\n        ss58Prefix = prefixVal\n        _accountId = scale.AccountId(prefixVal)\n      }\n    } catch (_) {}\n  }\n\n  const storagePallets = new Map<string, ReturnType<typeof scale.Storage>>()\n\n  const buildStorage = (pallet: string, entry: string) => {\n    let storagePallet = storagePallets.get(pallet)\n    if (!storagePallet)\n      storagePallets.set(pallet, (storagePallet = scale.Storage(pallet)))\n\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    const storageWithFallback = (\n      len: number,\n      ...args: Parameters<ReturnType<typeof scale.Storage>>\n    ) => {\n      const result = storagePallet!(...args)\n      return {\n        ...result,\n        len,\n        fallback:\n          storageEntry.modifier === 1\n            ? result.dec(storageEntry.fallback)\n            : undefined,\n      }\n    }\n\n    if (storageEntry.type.tag === \"plain\")\n      return storageWithFallback(\n        0,\n        entry,\n        buildDefinition(storageEntry.type.value).dec,\n      )\n\n    const { key, value, hashers } = storageEntry.type.value\n    const val = buildDefinition(value)\n    const hashes = hashers.map((x) => scale[x.tag])\n\n    const hashArgs: scale.EncoderWithHash<unknown>[] = (() => {\n      if (hashes.length === 1) {\n        return [[buildDefinition(key), hashes[0]]]\n      }\n\n      const keyDef = getLookupEntryDef(key)\n\n      switch (keyDef.type) {\n        case \"array\":\n          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash])\n        case \"tuple\":\n          return keyDef.value.map((x, idx) => [\n            buildDefinition(x.id),\n            hashes[idx],\n          ])\n        default:\n          throw new Error(\"Invalid key type\")\n      }\n    })()\n\n    return storageWithFallback(hashes.length, entry, val.dec, ...hashArgs)\n  }\n\n  const buildEnumEntry = (\n    entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n  ): Codec<any> => {\n    switch (entry.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildDefinition(entry.value.id)\n      case \"tuple\":\n        return scale.Tuple(\n          ...Object.values(entry.value).map((l) => buildDefinition(l.id)),\n        )\n      case \"struct\":\n        return scale.Struct(\n          mapObject(entry.value, (x) => buildDefinition(x.id)) as StringRecord<\n            Codec<any>\n          >,\n        )\n      case \"array\":\n        return scale.Vector(buildDefinition(entry.value.id), entry.len)\n    }\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      codec: Codec<any>\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const lookup = getLookupEntryDef(palletEntry[type]!)\n      if (lookup.type !== \"enum\") throw null\n      const entry = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, entry.idx],\n        codec: buildEnumEntry(lookup.value[name]),\n      }\n    }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    return {\n      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(entry.output),\n    }\n  }\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildRuntimeCall,\n    buildCall: buildVariant(\"calls\"),\n    buildConstant,\n    ss58Prefix,\n  }\n}\n","import { LookupEntry } from \"./lookups\"\n\ntype FnWithStack<Other extends Array<any>, T> = (\n  input: LookupEntry,\n  cache: Map<number, T>,\n  stack: Set<number>,\n  ...rest: Other\n) => T\n\nexport const withCache =\n  <Other extends Array<any>, T>(\n    fn: FnWithStack<Other, T>,\n    onEnterCircular: (\n      cacheGetter: () => T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n    onExitCircular: (\n      outter: T,\n      inner: T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n  ): FnWithStack<Other, T> =>\n  (input, cache, stack, ...rest) => {\n    const { id } = input\n    if (cache.has(id)) return cache.get(id)!\n\n    if (stack.has(id)) {\n      const res = onEnterCircular(() => cache.get(id)!, input, ...rest)\n      cache.set(id, res)\n      return res\n    }\n\n    stack.add(id)\n    let result = fn(input, cache, stack, ...rest)\n    stack.delete(id)\n\n    if (cache.has(id))\n      result = onExitCircular(result, cache.get(id)!, input, ...rest)\n\n    cache.set(id, result)\n    return result\n  }\n","import type { StringRecord, V14, V15 } from \"@polkadot-api/substrate-bindings\"\nimport { h64 } from \"@polkadot-api/substrate-bindings\"\nimport {\n  ArrayVar,\n  LookupEntry,\n  MetadataPrimitives,\n  StructVar,\n  TupleVar,\n  VoidVar,\n  getLookupFn,\n} from \"./lookups\"\nimport {\n  LookupGraph,\n  buildLookupGraph,\n  getStronglyConnectedComponents,\n  getSubgraph,\n  mergeSCCsWithCommonNodes,\n} from \"./lookup-graph\"\n\nconst textEncoder = new TextEncoder()\nconst encodeText = textEncoder.encode.bind(textEncoder)\n\nconst getChecksum = (values: Array<bigint>) => {\n  const res = new Uint8Array(values.length * 8)\n  const dv = new DataView(res.buffer)\n\n  for (let i = 0; i < values.length; i++) dv.setBigUint64(i * 8, values[i])\n\n  return h64(res)\n}\nconst getStringChecksum = (values: Array<string>) =>\n  getChecksum(values.map((v) => h64(encodeText(v))))\n\ntype Shape =\n  | \"primitive\"\n  | \"void\"\n  | \"vector\"\n  | \"tuple\"\n  | \"struct\"\n  | \"option\"\n  | \"result\"\n  | \"enum\"\nconst shapeIds: Record<Shape, bigint> = {\n  primitive: 0n,\n  vector: 1n,\n  tuple: 2n,\n  struct: 3n,\n  option: 4n,\n  result: 5n,\n  enum: 6n,\n  void: 7n,\n}\n\ntype RuntimePrimitives =\n  | \"undefined\"\n  | \"number\"\n  | \"string\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"bitSequence\"\n  | \"byteSequence\"\n  | \"accountId32\"\n  | \"accountId20\"\n\nconst runtimePrimitiveIds: Record<RuntimePrimitives, bigint> = {\n  undefined: 0n,\n  number: 1n,\n  string: 2n,\n  bigint: 3n,\n  boolean: 4n,\n  bitSequence: 5n, // {bitsLen: number, bytes: Uint8Array}\n  byteSequence: 6n, // Binary\n  accountId32: 7n, // SS58String\n  accountId20: 8n, // EthAccount\n}\n\nconst metadataPrimitiveIds: Record<MetadataPrimitives, bigint> = {\n  bool: runtimePrimitiveIds.boolean,\n  char: runtimePrimitiveIds.string,\n  str: runtimePrimitiveIds.string,\n  u8: runtimePrimitiveIds.number,\n  u16: runtimePrimitiveIds.number,\n  u32: runtimePrimitiveIds.number,\n  u64: runtimePrimitiveIds.bigint,\n  u128: runtimePrimitiveIds.bigint,\n  u256: runtimePrimitiveIds.bigint,\n  i8: runtimePrimitiveIds.number,\n  i16: runtimePrimitiveIds.number,\n  i32: runtimePrimitiveIds.number,\n  i64: runtimePrimitiveIds.bigint,\n  i128: runtimePrimitiveIds.bigint,\n  i256: runtimePrimitiveIds.bigint,\n}\n\nconst structLikeBuilder = <T>(\n  shapeId: bigint,\n  input: StringRecord<T>,\n  innerChecksum: (value: T) => bigint,\n) => {\n  const sortedEntries = Object.entries(input).sort(([a], [b]) =>\n    a.localeCompare(b),\n  )\n  const keysChecksum = getStringChecksum(sortedEntries.map(([key]) => key))\n  const valuesChecksum = getChecksum(\n    sortedEntries.map(([, entry]) => innerChecksum(entry)),\n  )\n\n  return getChecksum([shapeId, keysChecksum, valuesChecksum])\n}\n\nconst _buildChecksum = (\n  input: LookupEntry,\n  buildNextChecksum: (entry: LookupEntry) => bigint,\n): bigint => {\n  if (input.type === \"primitive\")\n    return getChecksum([shapeIds.primitive, metadataPrimitiveIds[input.value]])\n\n  if (input.type === \"void\") return getChecksum([shapeIds.void])\n\n  if (input.type === \"compact\")\n    return getChecksum([\n      shapeIds.primitive,\n      runtimePrimitiveIds[\n        input.isBig || input.isBig === null ? \"bigint\" : \"number\"\n      ],\n    ])\n\n  if (input.type === \"bitSequence\")\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.bitSequence])\n\n  if (input.type === \"AccountId32\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId32])\n  }\n\n  if (input.type === \"AccountId20\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId20])\n  }\n\n  const buildVector = (entry: LookupEntry, length?: number) => {\n    const innerChecksum = buildNextChecksum(entry)\n    return getChecksum(\n      length !== undefined\n        ? [shapeIds.vector, innerChecksum, BigInt(length)]\n        : [shapeIds.vector, innerChecksum],\n    )\n  }\n\n  if (input.type === \"array\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([\n        shapeIds.primitive,\n        runtimePrimitiveIds.byteSequence,\n        BigInt(input.len),\n      ])\n    }\n    return buildVector(innerValue, input.len)\n  }\n\n  if (input.type === \"sequence\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([shapeIds.primitive, runtimePrimitiveIds.byteSequence])\n    }\n    return buildVector(innerValue)\n  }\n\n  const buildTuple = (entries: LookupEntry[]) =>\n    getChecksum([shapeIds.tuple, ...entries.map(buildNextChecksum)])\n\n  const buildStruct = (entries: StringRecord<LookupEntry>) =>\n    structLikeBuilder(shapeIds.struct, entries, buildNextChecksum)\n\n  if (input.type === \"tuple\") return buildTuple(input.value)\n\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\")\n    return getChecksum([shapeIds.option, buildNextChecksum(input.value)])\n\n  if (input.type === \"result\")\n    return getChecksum([\n      shapeIds.result,\n      buildNextChecksum(input.value.ok),\n      buildNextChecksum(input.value.ko),\n    ])\n\n  return structLikeBuilder(shapeIds.enum, input.value, (entry) => {\n    if (entry.type === \"lookupEntry\") return buildNextChecksum(entry.value)\n    switch (entry.type) {\n      case \"void\":\n        return getChecksum([shapeIds.void])\n      case \"tuple\":\n        return buildTuple(entry.value)\n      case \"struct\":\n        return buildStruct(entry.value)\n      case \"array\":\n        return buildVector(entry.value, entry.len)\n    }\n  })\n}\n\nconst sortCyclicGroups = (groups: Array<Set<number>>, graph: LookupGraph) => {\n  const getReachableNodes = (group: Set<number>) => {\n    const result = new Set<number>()\n    const toVisit = Array.from(group)\n    while (toVisit.length) {\n      const id = toVisit.pop()!\n      if (result.has(id)) continue\n      result.add(id)\n\n      graph.get(id)?.refs.forEach((id) => toVisit.push(id))\n    }\n\n    return Array.from(result)\n  }\n\n  const result: Array<Set<number>> = new Array()\n\n  function dependentsFirst(group: Set<number>) {\n    if (result.includes(group)) return\n    const dependents = groups.filter(\n      (candidate) =>\n        candidate !== group &&\n        getReachableNodes(group).some((node) => candidate.has(node)),\n    )\n    dependents.forEach((group) => dependentsFirst(group))\n    if (result.includes(group)) return\n    result.push(group)\n  }\n\n  groups.forEach((group) => dependentsFirst(group))\n  return result\n}\n\nfunction iterateChecksums(\n  group: Set<number>,\n  iterations: number,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) {\n  // Keep the values that are getting changed on each iteration in a separate\n  // cache, because two nodes referencing the same one should read the same\n  // previous iteration checksum for that node.\n  const groupReadCache = new Map([...group].map((id) => [id, 0n]))\n  const groupWriteCache = new Map<number, bigint>()\n\n  const recursiveBuildChecksum = (\n    entry: LookupEntry,\n    // The first call has to skip the cache, otherwise it would return the\n    // previous iteration result.\n    skipCache = true,\n  ): bigint => {\n    if (!skipCache && (groupReadCache.has(entry.id) || cache.has(entry.id))) {\n      return groupReadCache.get(entry.id) ?? cache.get(entry.id)!\n    }\n    const result = _buildChecksum(entry, (nextEntry) =>\n      recursiveBuildChecksum(nextEntry, false),\n    )\n    if (group.has(entry.id)) {\n      groupWriteCache.set(entry.id, result)\n    } else {\n      cache.set(entry.id, result)\n    }\n    return result\n  }\n\n  for (let i = 0; i < iterations; i++) {\n    group.forEach((id) => recursiveBuildChecksum(graph.get(id)!.entry))\n\n    group.forEach((id) => groupReadCache.set(id, groupWriteCache.get(id)!))\n  }\n\n  return groupReadCache\n}\n\nfunction getMirroredNodes(\n  cyclicGroups: Array<Set<number>>,\n  graph: LookupGraph,\n) {\n  const maxSize = cyclicGroups.reduce(\n    (acc, group) => Math.max(acc, group.size),\n    0,\n  )\n  const allEntries = new Set([...graph.values()].map((v) => v.entry.id))\n\n  const resultingChecksums = iterateChecksums(\n    allEntries,\n    maxSize,\n    // Cache won't be used, since it's using the internal one for every node.\n    new Map(),\n    graph,\n  )\n\n  const checksumToNodes = new Map<bigint, number[]>()\n  for (const id of allEntries) {\n    const checksum = resultingChecksums.get(id)\n    if (checksum == undefined) throw new Error(\"Unreachable\")\n    if (!checksumToNodes.has(checksum)) {\n      checksumToNodes.set(checksum, [])\n    }\n    checksumToNodes.get(checksum)!.push(id)\n  }\n\n  const checksumsWithDuplicates = [...checksumToNodes.entries()].filter(\n    ([, nodes]) => nodes.length > 1,\n  )\n\n  const duplicatesMap: Record<number, number[]> = {}\n  checksumsWithDuplicates.forEach(([, nodes]) => {\n    nodes.forEach((n) => (duplicatesMap[n] = nodes))\n  })\n\n  return duplicatesMap\n}\n\nconst buildChecksum = (\n  entry: LookupEntry,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) => {\n  if (cache.has(entry.id)) return cache.get(entry.id)!\n\n  const subGraph = getSubgraph(entry.id, graph)\n\n  const cycles = getStronglyConnectedComponents(subGraph)\n  const cyclicGroups = mergeSCCsWithCommonNodes(cycles).filter((group) => {\n    // Exclude groups that were previously calculated\n    return !cache.has(group.values().next().value)\n  })\n  const mirrored = getMirroredNodes(cyclicGroups, subGraph)\n  const sortedCyclicGroups = sortCyclicGroups(\n    cyclicGroups.filter((group) => group.size > 1),\n    subGraph,\n  )\n\n  sortedCyclicGroups.forEach((group) => {\n    if (cache.has(group.values().next().value)) {\n      // exclude mirrored groups\n      return\n    }\n\n    const result = iterateChecksums(group, group.size, cache, graph)\n    group.forEach((id) => {\n      const checksum = result.get(id)!\n      if (id in mirrored) {\n        mirrored[id].forEach((id) => cache.set(id, checksum))\n      } else {\n        cache.set(id, checksum)\n      }\n    })\n  })\n\n  const getChecksum = (entry: LookupEntry) => {\n    if (cache.has(entry.id)) return cache.get(entry.id)!\n    return _buildChecksum(entry, getChecksum)\n  }\n\n  return getChecksum(entry)\n}\n\nexport const getChecksumBuilder = (metadata: V14 | V15) => {\n  const lookupData = metadata.lookup\n  const getLookupEntryDef = getLookupFn(lookupData)\n  const graph = buildLookupGraph(getLookupEntryDef, lookupData.length)\n\n  const cache = new Map<number, bigint>()\n\n  const buildDefinition = (id: number): bigint =>\n    buildChecksum(getLookupEntryDef(id), cache, graph)\n\n  const buildStorage = (pallet: string, entry: string): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .storage!.items.find((s) => s.name === entry)!\n\n      if (storageEntry.type.tag === \"plain\")\n        return buildDefinition(storageEntry.type.value)\n\n      const { key, value } = storageEntry.type.value\n      const val = buildDefinition(value)\n      const returnKey = buildDefinition(key)\n      return getChecksum([val, returnKey])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string): bigint | null => {\n    try {\n      const entry = metadata.apis\n        .find((x) => x.name === api)\n        ?.methods.find((x) => x.name === method)\n      if (!entry) throw null\n\n      const argNamesChecksum = getStringChecksum(\n        entry.inputs.map((x) => x.name),\n      )\n      const argValuesChecksum = getChecksum(\n        entry.inputs.map((x) => buildDefinition(x.type)),\n      )\n      const outputChecksum = buildDefinition(entry.output)\n\n      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildComposite = (\n    input: TupleVar | StructVar | VoidVar | ArrayVar,\n  ): bigint => {\n    if (input.type === \"void\") return getChecksum([0n])\n\n    if (input.type === \"tuple\") {\n      const values = Object.values(input.value).map((entry) =>\n        buildDefinition(entry.id),\n      )\n\n      return getChecksum([shapeIds.tuple, ...values])\n    }\n\n    if (input.type === \"array\") {\n      return getChecksum([\n        shapeIds.vector,\n        buildDefinition(input.value.id),\n        BigInt(input.len),\n      ])\n    }\n\n    // Otherwise struct\n    return structLikeBuilder(shapeIds.struct, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const buildNamedTuple = (input: StructVar): bigint => {\n    return structLikeBuilder(shapeIds.tuple, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const buildVariant =\n    (variantType: \"errors\" | \"events\" | \"calls\") =>\n    (pallet: string, name: string): bigint | null => {\n      try {\n        const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n        const enumLookup = getLookupEntryDef(\n          palletEntry[variantType]! as number,\n        )\n        buildDefinition(enumLookup.id)\n\n        if (enumLookup.type !== \"enum\") throw null\n        const entry = enumLookup.value[name]\n        return entry.type === \"lookupEntry\"\n          ? buildDefinition(entry.value.id)\n          : buildComposite(entry)\n      } catch (_) {\n        return null\n      }\n    }\n\n  const buildConstant = (\n    pallet: string,\n    constantName: string,\n  ): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .constants!.find((s) => s.name === constantName)!\n\n      return buildDefinition(storageEntry.type)\n    } catch (_) {\n      return null\n    }\n  }\n\n  const toStringEnhancer =\n    <Args extends Array<any>>(\n      fn: (...args: Args) => bigint | null,\n    ): ((...args: Args) => string | null) =>\n    (...args) =>\n      fn(...args)?.toString(32) ?? null\n\n  return {\n    buildDefinition: toStringEnhancer(buildDefinition),\n    buildRuntimeCall: toStringEnhancer(buildRuntimeCall),\n    buildStorage: toStringEnhancer(buildStorage),\n    buildCall: toStringEnhancer(buildVariant(\"calls\")),\n    buildEvent: toStringEnhancer(buildVariant(\"events\")),\n    buildError: toStringEnhancer(buildVariant(\"errors\")),\n    buildConstant: toStringEnhancer(buildConstant),\n    buildComposite: toStringEnhancer(buildComposite),\n    buildNamedTuple: toStringEnhancer(buildNamedTuple),\n    getAllGeneratedChecksums: () =>\n      Array.from(cache.values()).map((v) => v.toString(32)),\n  }\n}\n","import { LookupEntry } from \"./lookups\"\n\nexport type LookupGraph = Map<\n  number,\n  { entry: LookupEntry; backRefs: Set<number>; refs: Set<number> }\n>\n\nexport function buildLookupGraph(\n  lookupFn: (id: number) => LookupEntry,\n  lookupLength: number,\n): LookupGraph {\n  const result: LookupGraph = new Map()\n  const visited = new Set<number>()\n\n  const addEdge = (from: number, to: number) => {\n    if (!result.has(from))\n      result.set(from, {\n        entry: lookupFn(from),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    if (!result.has(to))\n      result.set(to, {\n        entry: lookupFn(to),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    result.get(from)!.refs.add(to)\n    result.get(to)!.backRefs.add(from)\n  }\n\n  for (let i = 0; i < lookupLength; i++) {\n    const entry = lookupFn(i)\n    if (i !== entry.id) {\n      // Lookup solved a pointer, but we still need to add that node into our\n      // graph in case someone access it from there.\n      addEdge(i, entry.id)\n    }\n    if (visited.has(entry.id)) continue\n    visited.add(entry.id)\n\n    switch (entry.type) {\n      case \"array\":\n      case \"option\":\n      case \"sequence\":\n        addEdge(entry.id, entry.value.id)\n        break\n      case \"enum\":\n        Object.values(entry.value).forEach((enumEntry) => {\n          switch (enumEntry.type) {\n            case \"array\":\n            case \"lookupEntry\":\n              addEdge(entry.id, enumEntry.value.id)\n              break\n            case \"struct\":\n            case \"tuple\":\n              Object.values(enumEntry.value).forEach((v) =>\n                addEdge(entry.id, v.id),\n              )\n              break\n          }\n        })\n        break\n      case \"result\":\n        addEdge(entry.id, entry.value.ok.id)\n        addEdge(entry.id, entry.value.ko.id)\n        break\n      case \"struct\":\n      case \"tuple\":\n        Object.values(entry.value).forEach((v) => addEdge(entry.id, v.id))\n        break\n    }\n\n    // It could be that this node is not being referenced by any other type\n    // nor it references anything. We still have to add it into the graph.\n    if (!result.has(entry.id)) {\n      result.set(entry.id, {\n        backRefs: new Set(),\n        refs: new Set(),\n        entry,\n      })\n    }\n  }\n\n  return result\n}\n\nconst subgraphCache = new WeakMap<LookupGraph, Map<number, LookupGraph>>()\nfunction _getSubgraph(\n  id: number,\n  graph: LookupGraph,\n  result: LookupGraph,\n  cache: Map<number, LookupGraph>,\n) {\n  if (result.has(id)) return\n  const node = graph.get(id)!\n  result.set(id, node)\n  cache.set(id, result)\n\n  node.refs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n  node.backRefs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n}\n\nexport function getSubgraph(id: number, graph: LookupGraph) {\n  if (!subgraphCache.has(graph)) {\n    subgraphCache.set(graph, new Map())\n  }\n  const cache = subgraphCache.get(graph)!\n  if (cache.has(id)) return cache.get(id)!\n\n  const result: LookupGraph = new Map()\n  _getSubgraph(id, graph, result, cache)\n  return result\n}\n\nexport function getStronglyConnectedComponents(graph: LookupGraph) {\n  // Tarjan's strongly connected components\n  const tarjanState = new Map<\n    number,\n    {\n      index: number\n      lowLink: number\n      onStack: boolean\n    }\n  >()\n  let index = 0\n  const stack: number[] = []\n  const result: Array<Set<number>> = []\n\n  function strongConnect(v: number): void {\n    const state = {\n      index: index,\n      lowLink: index,\n      onStack: true,\n    }\n    tarjanState.set(v, state)\n    index++\n    stack.push(v)\n\n    const edges = graph.get(v)!.refs\n    for (let w of edges) {\n      const edgeState = tarjanState.get(w)\n      if (!edgeState) {\n        strongConnect(w)\n        state.lowLink = Math.min(state.lowLink, tarjanState.get(w)!.lowLink)\n      } else if (edgeState.onStack) {\n        state.lowLink = Math.min(state.lowLink, edgeState.index)\n      }\n    }\n\n    if (state.lowLink === state.index) {\n      const component = new Set<number>()\n\n      let poppedNode = -1\n      do {\n        poppedNode = stack.pop()!\n        tarjanState.get(poppedNode)!.onStack = false\n        component.add(poppedNode)\n      } while (poppedNode !== v)\n\n      if (component.size > 1) result.push(component)\n    }\n  }\n\n  for (const node of graph.keys()) {\n    if (!tarjanState.has(node)) {\n      strongConnect(node)\n    }\n  }\n\n  return result\n}\n\nexport function mergeSCCsWithCommonNodes(\n  stronglyConnectedComponents: Array<Set<number>>,\n) {\n  /**\n   * For Nodes that are shared between two sets of SCCs, we need to calculate\n   * the checksum for the both of them, which wouldn't work (it would give\n   * different checksums).\n   * So we merge the SCCs that are using shared nodes into one group.\n   */\n  const scc = stronglyConnectedComponents\n  const ungroupedCycles = new Set(scc.map((_, i) => i))\n  const edges = new Map(scc.map((_, i) => [i, new Set<number>()]))\n  scc.forEach((cycle, i) => {\n    scc.slice(i + 1).forEach((otherCycle, _j) => {\n      const j = _j + i + 1\n      const combined = new Set([...cycle, ...otherCycle])\n      if (combined.size !== cycle.size + otherCycle.size) {\n        edges.get(i)!.add(j)\n        edges.get(j)!.add(i)\n      }\n    })\n  })\n  const groups: Array<Set<number>> = []\n\n  while (ungroupedCycles.size) {\n    const group = new Set<number>()\n    const toVisit = [ungroupedCycles.values().next().value]\n    while (toVisit.length) {\n      const idx = toVisit.pop()\n      if (!ungroupedCycles.has(idx)) continue\n      ungroupedCycles.delete(idx)\n\n      const cycle = scc[idx]\n      cycle.forEach((v) => group.add(Number(v)))\n      edges.get(idx)!.forEach((n) => toVisit.push(n))\n    }\n    groups.push(group)\n  }\n\n  return groups\n}\n"],"mappings":"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","names":["withCache","entry","inner","value","result","id","group","getChecksum","entry"]}