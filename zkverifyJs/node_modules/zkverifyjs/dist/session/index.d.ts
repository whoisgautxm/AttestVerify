import '@polkadot/api-augment';
import { ProofOptions } from './types';
import { AccountInfo, AttestationEvent, MerkleProof } from '../types';
import { EventEmitter } from 'events';
import { AccountConnection, EstablishedConnection, WalletConnection } from '../api/connection/types';
import { ApiPromise, WsProvider } from '@polkadot/api';
import { KeyringPair } from '@polkadot/keyring/types';
import { ProofType } from '../config';
import { ProofMethodMap } from './builders/verify';
import { RegisterKeyMethodMap } from './builders/register';
import { SupportedNetworkMap } from './builders/network';
import { SubmittableExtrinsic } from '@polkadot/api/types';
import { FormattedProofData } from '../api/format/types';
import { ExtrinsicCostEstimate } from '../api/estimate/types';
/**
 * zkVerifySession class provides an interface to zkVerify, direct access to the Polkadot.js API.
 */
export declare class zkVerifySession {
    /**
     * The connection object that includes API, provider, and account.
     * @type {AccountConnection | WalletConnection | EstablishedConnection}
     */
    private connection;
    /**
     * Indicates whether the session is in read-only mode (no account available).
     * @type {boolean}
     */
    readOnly: boolean;
    /**
     * An EventEmitter instance used to handle the subscription to NewAttestation events.
     * This emitter is created when the user subscribes to NewAttestation events via
     * `subscribeToNewAttestations` and is cleared when the user unsubscribes or when
     * the subscription ends automatically after receiving a specific attestation.
     *
     * @private
     * @type {EventEmitter | undefined}
     */
    private newAttestationEmitter?;
    /**
     * Creates an instance of zkVerifySession.
     * @param {AccountConnection | WalletConnection | EstablishedConnection} connection - The connection object that includes API, provider, and optionally an account or injected wallet.
     */
    constructor(connection: AccountConnection | WalletConnection | EstablishedConnection);
    /**
     * Starts a new zkVerifySession with network selection.
     * Returns a map of network methods for each supported network.
     * @returns {Record<keyof typeof SupportedNetwork, (customWsUrl?: string) => Promise<zkVerifySession>>}
     */
    static start(): SupportedNetworkMap;
    /**
     * Creates a builder map for different proof types that can be used for verification.
     * Each proof type returns a `VerificationBuilder` that allows you to chain methods for setting options
     * and finally executing the verification process.
     *
     * @returns {ProofMethodMap} A map of proof types to their corresponding builder methods.
     */
    verify(): ProofMethodMap;
    /**
     * Creates a builder map for different proof types that can be used for registering verification keys.
     * Each proof type returns a `RegisterKeyBuilder` that allows you to chain methods for setting options
     * and finally executing the registration process.
     *
     * @returns {RegisterKeyMethodMap} A map of proof types to their corresponding builder methods.
     */
    registerVerificationKey(): RegisterKeyMethodMap;
    /**
     * Factory method to create a `VerificationBuilder` for the given proof type.
     * The builder allows for chaining options and finally executing the verification process.
     *
     * @param {ProofType} proofType - The type of proof to be used.
     * @param {Library} [library] - The optional library to be used, if required by the proof type.
     * @param {CurveType} [curve] - The optional curve to be used, if required by the proof type.
     * @returns {VerificationBuilder} A new instance of `VerificationBuilder`.
     * @private
     */
    private createVerifyBuilder;
    /**
     * Factory method to create a `RegisterKeyBuilder` for the given proof type.
     * The builder allows for chaining options and finally executing the key registration process.
     *
     * @param {ProofType} proofType - The type of proof to be used.
     * @returns {RegisterKeyBuilder} A new instance of `RegisterKeyBuilder`.
     * @private
     */
    private createRegisterKeyBuilder;
    /**
     * Private method to start a zkVerifySession with the provided options.
     * @param {zkVerifySessionOptions} options - The options for starting the session.
     * @returns {Promise<zkVerifySession>} A promise that resolves to a zkVerifySession instance.
     * @private
     */
    private static _startSession;
    /**
     * Executes the verification process with the provided options and proof data or pre-built extrinsic.
     * This method is intended to be called by the `VerificationBuilder`.
     *
     * @param {VerifyOptions} options - The options for the verification process, including proof type and other optional settings.
     * @param {VerifyInput} input - The verification input, which can be provided as either:
     *   - `proofData`: An array of proof parameters (proof, public signals, and verification key).
     *   - `extrinsic`: A pre-built `SubmittableExtrinsic`.
     *   Ensure only one of these options is provided within the `VerifyInput`.
     *
     * @returns {Promise<{events: EventEmitter, transactionResult: Promise<VerifyTransactionInfo>}>}
     * A promise that resolves with an object containing:
     *   - `events`: An `EventEmitter` instance for real-time verification events.
     *   - `transactionResult`: A promise that resolves to the final transaction information once verification is complete.
     * @private
     */
    private executeVerify;
    /**
     * Executes the verification key registration process with the provided options and verification key.
     * This method is intended to be called by the `RegisterKeyBuilder`.
     *
     * @param {VerifyOptions} options - The options for the key registration process, including proof type and other optional settings.
     * @param {unknown} verificationKey - The verification key to be registered.
     * @returns {Promise<{events: EventEmitter, transactionResult: Promise<VKRegistrationTransactionInfo>}>}
     * A promise that resolves with an object containing an `EventEmitter` for real-time events and the final transaction result.
     * @private
     */
    private executeRegisterVerificationKey;
    /**
     * Proof Of Existence: Retrieve existing verified proof details.
     *
     * @param {number} attestationId - The attestation ID for which the proof path is to be retrieved.
     * @param {string} leafDigest - The leaf digest to be used in the proof path retrieval.
     * @param {string} [blockHash] - Optional block hash to retrieve the proof at a specific block.
     * @returns {Promise<MerkleProof>} An object containing the proof path details.
     */
    poe(attestationId: number, leafDigest: string, blockHash?: string): Promise<MerkleProof>;
    /**
     * Creates a SubmittableExtrinsic using formatted proof details to enable submitting a proof.
     *
     * @param {ProofType} proofType - The type of proof, to decide which pallet to use.
     * @param {FormattedProofData} params - Formatted Proof Parameters required by the extrinsic.
     * @returns {SubmittableExtrinsic<'promise'>} The generated SubmittableExtrinsic for submission.
     * @throws {Error} - Throws an error if the extrinsic creation fails.
     */
    createSubmitProofExtrinsic(proofType: ProofType, params: FormattedProofData): Promise<SubmittableExtrinsic<'promise'>>;
    /**
     * Generates the hex representation of a SubmittableExtrinsic using formatted proof details.
     *
     * @param {ProofType} proofType - The type of supported proof, used to select the correct pallet.
     * @param {FormattedProofData} params - Formatted Proof Parameters required by the extrinsic.
     * @returns {string} Hex-encoded string of the SubmittableExtrinsic.
     * @throws {Error} - Throws an error if the hex generation fails.
     */
    createExtrinsicHex(proofType: ProofType, params: FormattedProofData): Promise<string>;
    /**
     * Recreates an extrinsic from its hex-encoded representation.
     *
     * @param {string} extrinsicHex - Hex-encoded string of the SubmittableExtrinsic.
     * @returns {SubmittableExtrinsic<'promise'>} The reconstructed SubmittableExtrinsic.
     * @throws {Error} - Throws an error if the reconstruction from hex fails.
     */
    createExtrinsicFromHex(extrinsicHex: string): Promise<SubmittableExtrinsic<'promise'>>;
    /**
     * Estimates the cost of a given extrinsic.
     *
     * @param {SubmittableExtrinsic<'promise'>} extrinsic - The extrinsic to estimate.
     * @returns {Promise<ExtrinsicCostEstimate>} A promise that resolves to an object containing the estimated fee and extrinsic details.
     * @throws {Error} - Throws an error if the session is in read-only mode or account information is missing.
     */
    estimateCost(extrinsic: SubmittableExtrinsic<'promise'>): Promise<ExtrinsicCostEstimate>;
    /**
     * Formats proof details for the specified proof type.
     *
     * @param {ProofType} proofType - The type of proof to format.
     * @param {unknown} proof - The proof data to format.
     * @param {unknown} publicSignals - The public signals to format.
     * @param {unknown} vk - The verification key to format.
     * @param {boolean} [registeredVk] - Optional flag indicating if the verification key is registered.
     * @returns {Promise<FormattedProofData>} A promise that resolves to an object containing formatted verification key, proof, and public signals.
     * @throws {Error} - Throws an error if formatting fails.
     */
    format(proofOptions: ProofOptions, proof: unknown, publicSignals: unknown, vk: unknown, registeredVk?: boolean): Promise<FormattedProofData>;
    /**
     * Retrieves account information for the active account in the session.
     * @returns {Promise<AccountInfo>} A promise that resolves to the account information.
     * @throws Will throw an error if the session is in read-only mode.
     */
    accountInfo(): Promise<AccountInfo>;
    /**
     * Allows the user to add an account to the session if one is not already active.
     * @param {string} seedPhrase - The seed phrase for the account to add.
     * @returns {void}
     * @throws Will throw an error if an account is already active in the session.
     */
    addAccount(seedPhrase: string): void;
    /**
     * Allows the user to remove the active account from the session, making it read-only.
     * If no account is active, the method simply ensures the session is in read-only mode.
     * @returns {void}
     */
    removeAccount(): void;
    /**
     * Subscribes to NewAttestation events.
     * @param {Function} callback - The function to call with the event data when a NewAttestation event occurs.
     * @param {string} [attestationId] - Optional attestation ID to filter events by and unsubscribe after.
     */
    subscribeToNewAttestations(callback: (data: AttestationEvent) => void, attestationId?: number): EventEmitter;
    /**
     * Unsubscribes from NewAttestation events.
     * Emits the 'unsubscribe' event which causes removeAllListeners() on the newAttestationEmitter
     */
    unsubscribe(): void;
    /**
     * Closes the current session, disconnecting from the provider and cleaning up resources.
     * @returns {Promise<void>} A promise that resolves when the session is closed.
     */
    close(): Promise<void>;
    /**
     * Getter for the API instance.
     * @returns {ApiPromise} The Polkadot.js API instance.
     */
    get api(): ApiPromise;
    /**
     * Getter for the provider.
     * @returns {WsProvider} The WebSocket provider.
     */
    get provider(): WsProvider;
    /**
     * Getter for the account, if available.
     * @returns {KeyringPair | undefined} The active account, or undefined if in read-only mode.
     */
    get account(): KeyringPair | undefined;
}
//# sourceMappingURL=index.d.ts.map