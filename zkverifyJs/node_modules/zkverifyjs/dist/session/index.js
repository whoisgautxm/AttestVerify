"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zkVerifySession = void 0;
require("@polkadot/api-augment"); // Required for api.query.system.account responses
const verify_1 = require("../api/verify");
const accountInfo_1 = require("../api/accountInfo");
const start_1 = require("../api/start");
const close_1 = require("../api/close");
const estimate_1 = require("../api/estimate");
const attestation_1 = require("../api/attestation");
const poe_1 = require("../api/poe");
const extrinsic_1 = require("../api/extrinsic");
const events_1 = require("events");
const helpers_1 = require("../utils/helpers");
const account_1 = require("../api/account");
const register_1 = require("../api/register");
const config_1 = require("../config");
const verify_2 = require("./builders/verify");
const register_2 = require("./builders/register");
const network_1 = require("./builders/network");
const format_1 = require("../api/format");
const validator_1 = require("./validator");
/**
 * zkVerifySession class provides an interface to zkVerify, direct access to the Polkadot.js API.
 */
class zkVerifySession {
    /**
     * Creates an instance of zkVerifySession.
     * @param {AccountConnection | WalletConnection | EstablishedConnection} connection - The connection object that includes API, provider, and optionally an account or injected wallet.
     */
    constructor(connection) {
        this.connection = connection;
        this.readOnly = !('account' in connection) && !('injector' in connection);
    }
    /**
     * Starts a new zkVerifySession with network selection.
     * Returns a map of network methods for each supported network.
     * @returns {Record<keyof typeof SupportedNetwork, (customWsUrl?: string) => Promise<zkVerifySession>>}
     */
    static start() {
        const builderMethods = {};
        for (const network in config_1.SupportedNetwork) {
            if (Object.prototype.hasOwnProperty.call(config_1.SupportedNetwork, network)) {
                builderMethods[network] = (customWsUrl) => {
                    return new network_1.NetworkBuilder(zkVerifySession._startSession.bind(zkVerifySession), config_1.SupportedNetwork[network], customWsUrl);
                };
            }
        }
        return builderMethods;
    }
    /**
     * Creates a builder map for different proof types that can be used for verification.
     * Each proof type returns a `VerificationBuilder` that allows you to chain methods for setting options
     * and finally executing the verification process.
     *
     * @returns {ProofMethodMap} A map of proof types to their corresponding builder methods.
     */
    verify() {
        const builderMethods = {};
        for (const proofType in config_1.ProofType) {
            if (Object.prototype.hasOwnProperty.call(config_1.ProofType, proofType)) {
                builderMethods[proofType] = (library, curve) => {
                    const proofOptions = {
                        proofType: proofType,
                        library,
                        curve,
                    };
                    (0, validator_1.validateProofTypeOptions)(proofOptions);
                    return this.createVerifyBuilder(proofOptions);
                };
            }
        }
        return builderMethods;
    }
    /**
     * Creates a builder map for different proof types that can be used for registering verification keys.
     * Each proof type returns a `RegisterKeyBuilder` that allows you to chain methods for setting options
     * and finally executing the registration process.
     *
     * @returns {RegisterKeyMethodMap} A map of proof types to their corresponding builder methods.
     */
    registerVerificationKey() {
        const builderMethods = {};
        for (const proofType in config_1.ProofType) {
            if (Object.prototype.hasOwnProperty.call(config_1.ProofType, proofType)) {
                builderMethods[proofType] = (library, curve) => {
                    const proofOptions = {
                        proofType: proofType,
                        library,
                        curve,
                    };
                    return this.createRegisterKeyBuilder(proofOptions);
                };
            }
        }
        return builderMethods;
    }
    /**
     * Factory method to create a `VerificationBuilder` for the given proof type.
     * The builder allows for chaining options and finally executing the verification process.
     *
     * @param {ProofType} proofType - The type of proof to be used.
     * @param {Library} [library] - The optional library to be used, if required by the proof type.
     * @param {CurveType} [curve] - The optional curve to be used, if required by the proof type.
     * @returns {VerificationBuilder} A new instance of `VerificationBuilder`.
     * @private
     */
    createVerifyBuilder(proofOptions) {
        return new verify_2.VerificationBuilder(this.executeVerify.bind(this), proofOptions);
    }
    /**
     * Factory method to create a `RegisterKeyBuilder` for the given proof type.
     * The builder allows for chaining options and finally executing the key registration process.
     *
     * @param {ProofType} proofType - The type of proof to be used.
     * @returns {RegisterKeyBuilder} A new instance of `RegisterKeyBuilder`.
     * @private
     */
    createRegisterKeyBuilder(proofOptions) {
        return new register_2.RegisterKeyBuilder(this.executeRegisterVerificationKey.bind(this), proofOptions);
    }
    /**
     * Private method to start a zkVerifySession with the provided options.
     * @param {zkVerifySessionOptions} options - The options for starting the session.
     * @returns {Promise<zkVerifySession>} A promise that resolves to a zkVerifySession instance.
     * @private
     */
    static async _startSession(options) {
        if (options.wallet) {
            if (typeof window === 'undefined') {
                throw new Error('zkVerifySession with wallet can only be used in a browser environment.');
            }
            const connection = await (0, start_1.startWalletSession)(options);
            return new zkVerifySession(connection);
        }
        else {
            const connection = await (0, start_1.startSession)(options);
            return new zkVerifySession(connection);
        }
    }
    /**
     * Executes the verification process with the provided options and proof data or pre-built extrinsic.
     * This method is intended to be called by the `VerificationBuilder`.
     *
     * @param {VerifyOptions} options - The options for the verification process, including proof type and other optional settings.
     * @param {VerifyInput} input - The verification input, which can be provided as either:
     *   - `proofData`: An array of proof parameters (proof, public signals, and verification key).
     *   - `extrinsic`: A pre-built `SubmittableExtrinsic`.
     *   Ensure only one of these options is provided within the `VerifyInput`.
     *
     * @returns {Promise<{events: EventEmitter, transactionResult: Promise<VerifyTransactionInfo>}>}
     * A promise that resolves with an object containing:
     *   - `events`: An `EventEmitter` instance for real-time verification events.
     *   - `transactionResult`: A promise that resolves to the final transaction information once verification is complete.
     * @private
     */
    async executeVerify(options, input) {
        (0, helpers_1.checkReadOnly)(this.readOnly);
        const events = new events_1.EventEmitter();
        const transactionResult = (0, verify_1.verify)(this.connection, options, events, input);
        return { events, transactionResult };
    }
    /**
     * Executes the verification key registration process with the provided options and verification key.
     * This method is intended to be called by the `RegisterKeyBuilder`.
     *
     * @param {VerifyOptions} options - The options for the key registration process, including proof type and other optional settings.
     * @param {unknown} verificationKey - The verification key to be registered.
     * @returns {Promise<{events: EventEmitter, transactionResult: Promise<VKRegistrationTransactionInfo>}>}
     * A promise that resolves with an object containing an `EventEmitter` for real-time events and the final transaction result.
     * @private
     */
    async executeRegisterVerificationKey(options, verificationKey) {
        (0, helpers_1.checkReadOnly)(this.readOnly);
        return (0, register_1.registerVk)(this.connection, options, verificationKey);
    }
    /**
     * Proof Of Existence: Retrieve existing verified proof details.
     *
     * @param {number} attestationId - The attestation ID for which the proof path is to be retrieved.
     * @param {string} leafDigest - The leaf digest to be used in the proof path retrieval.
     * @param {string} [blockHash] - Optional block hash to retrieve the proof at a specific block.
     * @returns {Promise<MerkleProof>} An object containing the proof path details.
     */
    async poe(attestationId, leafDigest, blockHash) {
        return (0, poe_1.getProofDetails)(this.connection.api, attestationId, leafDigest, blockHash);
    }
    /**
     * Creates a SubmittableExtrinsic using formatted proof details to enable submitting a proof.
     *
     * @param {ProofType} proofType - The type of proof, to decide which pallet to use.
     * @param {FormattedProofData} params - Formatted Proof Parameters required by the extrinsic.
     * @returns {SubmittableExtrinsic<'promise'>} The generated SubmittableExtrinsic for submission.
     * @throws {Error} - Throws an error if the extrinsic creation fails.
     */
    async createSubmitProofExtrinsic(proofType, params) {
        return (0, extrinsic_1.createSubmitProofExtrinsic)(this.connection.api, proofType, params);
    }
    /**
     * Generates the hex representation of a SubmittableExtrinsic using formatted proof details.
     *
     * @param {ProofType} proofType - The type of supported proof, used to select the correct pallet.
     * @param {FormattedProofData} params - Formatted Proof Parameters required by the extrinsic.
     * @returns {string} Hex-encoded string of the SubmittableExtrinsic.
     * @throws {Error} - Throws an error if the hex generation fails.
     */
    async createExtrinsicHex(proofType, params) {
        return (0, extrinsic_1.createExtrinsicHex)(this.connection.api, proofType, params);
    }
    /**
     * Recreates an extrinsic from its hex-encoded representation.
     *
     * @param {string} extrinsicHex - Hex-encoded string of the SubmittableExtrinsic.
     * @returns {SubmittableExtrinsic<'promise'>} The reconstructed SubmittableExtrinsic.
     * @throws {Error} - Throws an error if the reconstruction from hex fails.
     */
    async createExtrinsicFromHex(extrinsicHex) {
        return (0, extrinsic_1.createExtrinsicFromHex)(this.connection.api, extrinsicHex);
    }
    /**
     * Estimates the cost of a given extrinsic.
     *
     * @param {SubmittableExtrinsic<'promise'>} extrinsic - The extrinsic to estimate.
     * @returns {Promise<ExtrinsicCostEstimate>} A promise that resolves to an object containing the estimated fee and extrinsic details.
     * @throws {Error} - Throws an error if the session is in read-only mode or account information is missing.
     */
    async estimateCost(extrinsic) {
        (0, helpers_1.checkReadOnly)(this.readOnly);
        return (0, estimate_1.estimateCost)(this.connection.api, extrinsic, this.connection);
    }
    /**
     * Formats proof details for the specified proof type.
     *
     * @param {ProofType} proofType - The type of proof to format.
     * @param {unknown} proof - The proof data to format.
     * @param {unknown} publicSignals - The public signals to format.
     * @param {unknown} vk - The verification key to format.
     * @param {boolean} [registeredVk] - Optional flag indicating if the verification key is registered.
     * @returns {Promise<FormattedProofData>} A promise that resolves to an object containing formatted verification key, proof, and public signals.
     * @throws {Error} - Throws an error if formatting fails.
     */
    async format(proofOptions, proof, publicSignals, vk, registeredVk) {
        return (0, format_1.format)(proofOptions, proof, publicSignals, vk, registeredVk);
    }
    /**
     * Retrieves account information for the active account in the session.
     * @returns {Promise<AccountInfo>} A promise that resolves to the account information.
     * @throws Will throw an error if the session is in read-only mode.
     */
    async accountInfo() {
        (0, helpers_1.checkReadOnly)(this.readOnly);
        return (0, accountInfo_1.accountInfo)(this.connection.api, this.connection.account);
    }
    /**
     * Allows the user to add an account to the session if one is not already active.
     * @param {string} seedPhrase - The seed phrase for the account to add.
     * @returns {void}
     * @throws Will throw an error if an account is already active in the session.
     */
    addAccount(seedPhrase) {
        if ('account' in this.connection) {
            throw new Error('An account is already active in this session.');
        }
        this.connection = {
            api: this.connection.api,
            provider: this.connection.provider,
            account: (0, account_1.setupAccount)(seedPhrase),
        };
        this.readOnly = false;
    }
    /**
     * Allows the user to remove the active account from the session, making it read-only.
     * If no account is active, the method simply ensures the session is in read-only mode.
     * @returns {void}
     */
    removeAccount() {
        if ('account' in this.connection) {
            this.connection = {
                api: this.connection.api,
                provider: this.connection.provider,
            };
            this.readOnly = true;
        }
    }
    /**
     * Subscribes to NewAttestation events.
     * @param {Function} callback - The function to call with the event data when a NewAttestation event occurs.
     * @param {string} [attestationId] - Optional attestation ID to filter events by and unsubscribe after.
     */
    subscribeToNewAttestations(callback, attestationId) {
        this.newAttestationEmitter = (0, attestation_1.subscribeToNewAttestations)(this.connection.api, callback, attestationId);
        return this.newAttestationEmitter;
    }
    /**
     * Unsubscribes from NewAttestation events.
     * Emits the 'unsubscribe' event which causes removeAllListeners() on the newAttestationEmitter
     */
    unsubscribe() {
        if (this.newAttestationEmitter) {
            (0, attestation_1.unsubscribeFromNewAttestations)(this.newAttestationEmitter);
        }
    }
    /**
     * Closes the current session, disconnecting from the provider and cleaning up resources.
     * @returns {Promise<void>} A promise that resolves when the session is closed.
     */
    async close() {
        return (0, close_1.closeSession)(this.connection.provider);
    }
    /**
     * Getter for the API instance.
     * @returns {ApiPromise} The Polkadot.js API instance.
     */
    get api() {
        return this.connection.api;
    }
    /**
     * Getter for the provider.
     * @returns {WsProvider} The WebSocket provider.
     */
    get provider() {
        return this.connection.provider;
    }
    /**
     * Getter for the account, if available.
     * @returns {KeyringPair | undefined} The active account, or undefined if in read-only mode.
     */
    get account() {
        return 'account' in this.connection ? this.connection.account : undefined;
    }
}
exports.zkVerifySession = zkVerifySession;
//# sourceMappingURL=index.js.map