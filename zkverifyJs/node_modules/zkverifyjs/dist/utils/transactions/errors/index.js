"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleError = exports.decodeDispatchError = void 0;
const enums_1 = require("../../../enums");
const decodeDispatchError = (api, dispatchError) => {
    if (dispatchError.isModule) {
        try {
            const decoded = api.registry.findMetaError(dispatchError.asModule);
            const { docs, name, section } = decoded;
            return `${section}.${name}: ${docs.join(' ')}`;
        }
        catch {
            return `Unknown module error: ${dispatchError.toString()}`;
        }
    }
    else if (dispatchError.isToken) {
        return `Token error: ${dispatchError.asToken.type}`;
    }
    else if (dispatchError.isArithmetic) {
        return `Arithmetic error: ${dispatchError.asArithmetic.type}`;
    }
    else {
        return dispatchError.toString();
    }
};
exports.decodeDispatchError = decodeDispatchError;
const handleError = (emitter, api, transactionInfo, error, shouldThrow = true, status) => {
    let decodedError;
    if (error instanceof Error) {
        try {
            const parsedError = JSON.parse(error.message);
            if (parsedError.module && parsedError.module.index !== undefined) {
                const dispatchError = api.registry.createType('DispatchError', parsedError);
                decodedError = (0, exports.decodeDispatchError)(api, dispatchError);
            }
            else {
                decodedError = error.message;
            }
        }
        catch {
            decodedError = error.message;
        }
    }
    else {
        decodedError = (0, exports.decodeDispatchError)(api, error);
    }
    if (status &&
        status.isInvalid &&
        transactionInfo.status !== enums_1.TransactionStatus.Finalized) {
        transactionInfo.status = enums_1.TransactionStatus.Invalid;
        decodedError = 'Transaction was marked as invalid.';
    }
    else {
        transactionInfo.status = enums_1.TransactionStatus.Error;
    }
    if (emitter.listenerCount(enums_1.ZkVerifyEvents.ErrorEvent) > 0) {
        emitter.emit(enums_1.ZkVerifyEvents.ErrorEvent, {
            proofType: transactionInfo.proofType,
            error: decodedError,
        });
    }
    if (shouldThrow) {
        throw new Error(decodedError);
    }
};
exports.handleError = handleError;
//# sourceMappingURL=index.js.map