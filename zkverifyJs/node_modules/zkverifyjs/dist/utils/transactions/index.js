"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleTransaction = void 0;
const helpers_1 = require("../helpers");
const events_1 = require("./events");
const enums_1 = require("../../enums");
const errors_1 = require("./errors");
const safeEmit = (emitter, event, data) => {
    try {
        emitter.emit(event, data);
    }
    catch (error) {
        console.debug(`Failed to emit event ${event}:`, error);
    }
};
const handleInBlock = async (api, events, transactionInfo, setAttestationId, emitter, transactionType) => {
    if (transactionInfo.status === enums_1.TransactionStatus.Error) {
        return;
    }
    transactionInfo.status = enums_1.TransactionStatus.InBlock;
    const updatedTransactionInfo = (0, events_1.handleTransactionEvents)(api, events, transactionInfo, emitter, setAttestationId, transactionType);
    Object.assign(transactionInfo, updatedTransactionInfo);
    safeEmit(emitter, enums_1.ZkVerifyEvents.IncludedInBlock, transactionInfo);
};
const handleFinalized = async (api, transactionInfo, dispatchError, emitter, transactionType) => {
    if (transactionInfo.status === enums_1.TransactionStatus.Error) {
        return;
    }
    if (dispatchError) {
        (0, errors_1.handleError)(emitter, api, transactionInfo, dispatchError);
        return;
    }
    transactionInfo.status = enums_1.TransactionStatus.Finalized;
    if (transactionType === enums_1.TransactionType.Verify) {
        const verifyTransactionInfo = transactionInfo;
        if (verifyTransactionInfo.attestationId) {
            safeEmit(emitter, enums_1.ZkVerifyEvents.Finalized, verifyTransactionInfo);
        }
        else {
            const errorMsg = 'Finalized but no attestation ID found.';
            safeEmit(emitter, enums_1.ZkVerifyEvents.ErrorEvent, {
                ...verifyTransactionInfo,
                error: errorMsg,
            });
        }
    }
    else if (transactionType === enums_1.TransactionType.VKRegistration) {
        const vkRegistrationInfo = transactionInfo;
        if (vkRegistrationInfo.statementHash) {
            safeEmit(emitter, enums_1.ZkVerifyEvents.Finalized, vkRegistrationInfo);
        }
        else {
            const errorMsg = 'Finalized but no statement hash found.';
            safeEmit(emitter, enums_1.ZkVerifyEvents.ErrorEvent, {
                ...vkRegistrationInfo,
                error: errorMsg,
            });
        }
    }
};
const handleTransaction = async (api, submitExtrinsic, account, signer, emitter, options, transactionType) => {
    const { proofOptions: { proofType }, waitForNewAttestationEvent: shouldWaitForAttestation = false, nonce, } = options;
    const transactionInfo = {
        blockHash: '',
        proofType,
        status: enums_1.TransactionStatus.Pending,
        txHash: undefined,
        extrinsicIndex: undefined,
        feeInfo: undefined,
        weightInfo: undefined,
        txClass: undefined,
    };
    const setAttestationId = (id) => {
        transactionInfo.attestationId = id;
    };
    return new Promise((resolve, reject) => {
        const cancelTransaction = (error) => {
            if (transactionInfo.status !== enums_1.TransactionStatus.Error) {
                transactionInfo.status = enums_1.TransactionStatus.Error;
                try {
                    if (error instanceof Error) {
                        (0, errors_1.handleError)(emitter, api, transactionInfo, error, true);
                    }
                    else {
                        (0, errors_1.handleError)(emitter, api, transactionInfo, new Error(String(error)), true);
                    }
                }
                catch (err) {
                    reject(err);
                    return;
                }
            }
        };
        const finalizeTransaction = async (result) => {
            if (transactionInfo.status === enums_1.TransactionStatus.Error) {
                return;
            }
            try {
                await handleFinalized(api, transactionInfo, result.dispatchError, emitter, transactionType);
                if (transactionType === enums_1.TransactionType.Verify &&
                    shouldWaitForAttestation &&
                    transactionInfo.attestationId) {
                    try {
                        transactionInfo.attestationEvent =
                            await (0, helpers_1.waitForNewAttestationEvent)(api, transactionInfo.attestationId, emitter);
                        transactionInfo.attestationConfirmed =
                            true;
                    }
                    catch (error) {
                        cancelTransaction(error);
                        return;
                    }
                }
                resolve(transactionInfo);
            }
            catch (error) {
                cancelTransaction(error);
            }
        };
        performSignAndSend(submitExtrinsic, account, signer ? { signer, nonce } : { nonce }, async (result) => {
            if (transactionInfo.status === enums_1.TransactionStatus.Error) {
                return;
            }
            try {
                if (result.status.isBroadcast) {
                    safeEmit(emitter, enums_1.ZkVerifyEvents.Broadcast, {
                        txHash: result.txHash.toString(),
                    });
                }
                if (result.status.isInBlock) {
                    transactionInfo.txHash = result.txHash.toString();
                    transactionInfo.blockHash = result.status.asInBlock.toString();
                    await handleInBlock(api, result.events, transactionInfo, setAttestationId, emitter, transactionType);
                }
                if (result.status.isFinalized) {
                    await finalizeTransaction(result);
                }
                else if (result.status.isInvalid) {
                    throw new Error('Transaction is invalid.');
                }
            }
            catch (error) {
                cancelTransaction(error);
            }
        }).catch((error) => {
            cancelTransaction(error);
        });
    });
};
exports.handleTransaction = handleTransaction;
function performSignAndSend(submitExtrinsic, account, options, callback) {
    if (typeof account === 'string' && options?.signer) {
        return submitExtrinsic.signAndSend(account, options, callback);
    }
    else if (typeof account !== 'string') {
        if (options) {
            return submitExtrinsic.signAndSend(account, options, callback);
        }
        else {
            return submitExtrinsic.signAndSend(account, callback);
        }
    }
    else {
        throw new Error('Unsupported account or signer type.');
    }
}
//# sourceMappingURL=index.js.map