"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForNewAttestationEvent = waitForNewAttestationEvent;
exports.waitForNodeToSync = waitForNodeToSync;
exports.getProofProcessor = getProofProcessor;
exports.getProofPallet = getProofPallet;
exports.checkReadOnly = checkReadOnly;
require("dotenv/config");
const enums_1 = require("../../enums");
const config_1 = require("../../config");
const attestation_1 = require("../../api/attestation");
/**
 * Waits for a specific `NewAttestation` event and returns the associated data.
 *
 * @param {ApiPromise} api - The Polkadot.js API instance.
 * @param {number | undefined} attestationId - The attestation ID to wait for.
 * @param {EventEmitter} emitter - The EventEmitter instance for emitting events.
 *
 * @returns {Promise<AttestationEvent>} Resolves with the attestation event data if confirmed, or rejects with an error.
 *
 * @throws {Error} If the attestation ID is undefined or an error occurs during event subscription.
 *
 * @emits ZkVerifyEvents.AttestationConfirmed - When the specified attestation is confirmed.
 * @emits ZkVerifyEvents.AttestationMissed - If a later attestation ID is received.
 * @emits ZkVerifyEvents.BeforeExpected - If the attestation ID from the event is less than expected.
 * @emits ZkVerifyEvents.ErrorEvent - If an error occurs.
 */
async function waitForNewAttestationEvent(api, attestationId, emitter) {
    if (!attestationId) {
        const error = new Error('No attestation ID found.');
        emitter.emit(enums_1.ZkVerifyEvents.ErrorEvent, error);
        throw error;
    }
    return new Promise((resolve, reject) => {
        const internalEmitter = (0, attestation_1.subscribeToNewAttestations)(api, () => { }, attestationId);
        internalEmitter.on(enums_1.ZkVerifyEvents.AttestationConfirmed, (event) => {
            emitter.emit(enums_1.ZkVerifyEvents.AttestationConfirmed, event);
            resolve(event);
        });
        internalEmitter.on(enums_1.ZkVerifyEvents.AttestationMissed, (event) => {
            emitter.emit(enums_1.ZkVerifyEvents.AttestationMissed, event);
            reject(new Error(`Missed the attestation ID ${attestationId}.`));
        });
        internalEmitter.on(enums_1.ZkVerifyEvents.AttestationBeforeExpected, (event) => {
            emitter.emit(enums_1.ZkVerifyEvents.AttestationBeforeExpected, event);
        });
        internalEmitter.on(enums_1.ZkVerifyEvents.ErrorEvent, (error) => {
            emitter.emit(enums_1.ZkVerifyEvents.ErrorEvent, error);
            reject(error);
        });
    });
}
/**
 * Waits for the zkVerify node to sync.
 * @param api - The ApiPromise instance.
 * @returns A promise that resolves when the node is synced.
 */
async function waitForNodeToSync(api) {
    let isSyncing = true;
    while (isSyncing) {
        const health = await api.rpc.system.health();
        isSyncing = health.isSyncing.isTrue;
        if (isSyncing) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
        }
    }
}
function getProofProcessor(proofType) {
    const config = config_1.proofConfigurations[proofType];
    if (!config) {
        throw new Error(`No config found for Proof Processor: ${proofType}`);
    }
    return config.processor;
}
function getProofPallet(proofType) {
    const config = config_1.proofConfigurations[proofType];
    if (!config) {
        throw new Error(`No config found for Proof Pallet: ${proofType}`);
    }
    return config.pallet;
}
function checkReadOnly(readOnly) {
    if (readOnly) {
        throw new Error('This action requires an active account. The session is currently in read-only mode because no account is associated with it. Please provide an account at session start, or add one to the current session using `addAccount`.');
    }
}
//# sourceMappingURL=index.js.map