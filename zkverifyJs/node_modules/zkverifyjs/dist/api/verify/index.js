"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = void 0;
const transactions_1 = require("../../utils/transactions");
const enums_1 = require("../../enums");
const format_1 = require("../format");
const extrinsic_1 = require("../extrinsic");
const verify = async (connection, options, emitter, input) => {
    try {
        const { api } = connection;
        let transaction;
        if ('proofData' in input && input.proofData) {
            const { proof, publicSignals, vk } = input.proofData;
            const formattedProofData = (0, format_1.format)(options.proofOptions, proof, publicSignals, vk, options.registeredVk);
            transaction = (0, extrinsic_1.createSubmitProofExtrinsic)(api, options.proofOptions.proofType, formattedProofData);
        }
        else if ('extrinsic' in input && input.extrinsic) {
            transaction = input.extrinsic;
        }
        else {
            throw new Error('Invalid input: Either proofData or extrinsic must be provided.');
        }
        const result = await (async () => {
            if ('account' in connection) {
                return await (0, transactions_1.handleTransaction)(api, transaction, connection.account, undefined, emitter, options, enums_1.TransactionType.Verify);
            }
            else if ('injector' in connection) {
                const { signer } = connection.injector;
                const { accountAddress } = connection;
                return await (0, transactions_1.handleTransaction)(api, transaction, accountAddress, signer, emitter, options, enums_1.TransactionType.Verify);
            }
            else {
                throw new Error('Unsupported connection type.');
            }
        })();
        return result;
    }
    catch (error) {
        emitter.emit(enums_1.ZkVerifyEvents.ErrorEvent, error);
        emitter.removeAllListeners();
        throw error;
    }
};
exports.verify = verify;
//# sourceMappingURL=index.js.map