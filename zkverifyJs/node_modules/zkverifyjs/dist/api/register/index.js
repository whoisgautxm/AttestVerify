"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerVk = registerVk;
const events_1 = require("events");
const transactions_1 = require("../../utils/transactions");
const helpers_1 = require("../../utils/helpers");
const enums_1 = require("../../enums");
async function registerVk(connection, options, verificationKey) {
    const { proofOptions } = options;
    const emitter = new events_1.EventEmitter();
    const processor = await (0, helpers_1.getProofProcessor)(proofOptions.proofType);
    if (!processor) {
        throw new Error(`Unsupported proof type: ${proofOptions.proofType}`);
    }
    if (verificationKey == null || verificationKey === '') {
        throw new Error('verificationKey cannot be null, undefined, or an empty string');
    }
    const formattedVk = processor.formatVk(verificationKey, proofOptions);
    const pallet = (0, helpers_1.getProofPallet)(proofOptions.proofType);
    if (!pallet) {
        throw new Error(`Unsupported proof type: ${proofOptions.proofType}`);
    }
    const registerExtrinsic = connection.api.tx[pallet].registerVk(formattedVk);
    const transactionResult = new Promise((resolve, reject) => {
        (0, transactions_1.handleTransaction)(connection.api, registerExtrinsic, connection.account, undefined, emitter, options, enums_1.TransactionType.VKRegistration)
            .then(resolve)
            .catch((error) => {
            emitter.emit(enums_1.ZkVerifyEvents.ErrorEvent, error);
            reject(error);
        });
    });
    return { events: emitter, transactionResult };
}
//# sourceMappingURL=index.js.map