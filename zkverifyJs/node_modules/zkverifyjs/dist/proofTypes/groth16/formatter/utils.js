"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatPublicSignals = exports.formatScalar = exports.formatG2Point = exports.formatG1Point = exports.toHex = exports.extractCurve = exports.getEndianess = exports.unstringifyBigInts = void 0;
const config_1 = require("../../../config");
/**
 * Recursively converts numeric strings and hexadecimal strings in an object, array, or string
 * to `bigint`. Handles nested arrays and objects.
 */
const unstringifyBigInts = (o) => {
    if (typeof o === 'string' && /^[0-9]+$/.test(o))
        return BigInt(o);
    if (typeof o === 'string' && /^0x[0-9a-fA-F]+$/.test(o))
        return BigInt(o);
    if (Array.isArray(o))
        return o.map(exports.unstringifyBigInts);
    if (typeof o === 'object' && o !== null) {
        const result = {};
        for (const key in o) {
            if (Object.prototype.hasOwnProperty.call(o, key)) {
                result[key] = (0, exports.unstringifyBigInts)(o[key]);
            }
        }
        return result;
    }
    return o;
};
exports.unstringifyBigInts = unstringifyBigInts;
/**
 * Determines endianess based on the curve type.
 */
const getEndianess = (curve) => {
    return curve.toLowerCase() === 'bn254' ? 'LE' : 'BE';
};
exports.getEndianess = getEndianess;
/**
 * Extracts and normalizes curve type.
 */
const extractCurve = (curve) => {
    if (curve === config_1.CurveType.bn128 || curve === config_1.CurveType.bn254)
        return 'bn254';
    if (curve === config_1.CurveType.bls12381)
        return 'Bls12_381';
    throw new Error(`Unsupported curve: ${curve}`);
};
exports.extractCurve = extractCurve;
/**
 * Converts bigint to a hexadecimal string based on endianess.
 */
const toHex = (value, length, endianess) => {
    const hex = value.toString(16).padStart(length * 2, '0');
    const reversed = hex
        .match(/.{1,2}/g)
        .reverse()
        .join('');
    return `0x${endianess === 'LE' ? reversed : hex}`;
};
exports.toHex = toHex;
/**
 * Formats a G1 point based on endianess and curve type.
 */
const formatG1Point = (point, endianess) => {
    const [x, y] = [BigInt(point[0]), BigInt(point[1])];
    return ((0, exports.toHex)(x, endianess === 'LE' ? 32 : 48, endianess) +
        (0, exports.toHex)(y, endianess === 'LE' ? 32 : 48, endianess).slice(2));
};
exports.formatG1Point = formatG1Point;
/**
 * Formats a G2 point based on endianess and curve type.
 */
const formatG2Point = (point, endianess, curve) => {
    const [x1, x2, y1, y2] = [
        BigInt(point[0][0]),
        BigInt(point[0][1]),
        BigInt(point[1][0]),
        BigInt(point[1][1]),
    ];
    const formatX = curve === 'Bls12_381'
        ? [x2.toString(), x1.toString()] // bls12381 uses (x2, x1)
        : [x1.toString(), x2.toString()]; // bn254 uses (x1, x2)
    const formatY = curve === 'Bls12_381'
        ? [y2.toString(), y1.toString()] // bls12381 uses (y2, y1)
        : [y1.toString(), y2.toString()]; // bn254 uses (y1, y2)
    return ((0, exports.formatG1Point)(formatX, endianess) +
        (0, exports.formatG1Point)(formatY, endianess).slice(2));
};
exports.formatG2Point = formatG2Point;
/**
 * Formats a scalar as little-endian hexadecimal string.
 */
const formatScalar = (scalar) => (0, exports.toHex)(BigInt(scalar), 32, 'LE');
exports.formatScalar = formatScalar;
/**
 * Formats an array of public signals.
 *
 * @param {string[]} pubs - Array of public signals.
 * @returns {string[]} - Formatted public signals.
 */
const formatPublicSignals = (pubs) => {
    if (!Array.isArray(pubs) || pubs.some(() => false)) {
        throw new Error('Invalid public signals format: Expected an array of strings.');
    }
    return pubs.map(exports.formatScalar);
};
exports.formatPublicSignals = formatPublicSignals;
//# sourceMappingURL=utils.js.map