"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatPubs = exports.formatVk = exports.formatProof = void 0;
const utils_1 = require("../utils");
/**
 * Formats zk-SNARK proof data for Groth16 using Gnark.
 *
 * @param {ProofInput} proof - Raw proof data.
 * @param {ProofOptions} options - Proof options containing curve information.
 * @returns {Proof} - Formatted proof data.
 */
const formatProof = (proof, options) => {
    try {
        if (typeof proof !== 'object' || proof === null) {
            throw new Error('Invalid proof format: Expected an object.');
        }
        const proofData = (0, utils_1.unstringifyBigInts)(proof);
        const curve = (0, utils_1.extractCurve)(options.curve);
        const endianess = (0, utils_1.getEndianess)(curve);
        return {
            curve,
            proof: {
                a: (0, utils_1.formatG1Point)([proofData.Ar.X, proofData.Ar.Y], endianess),
                b: (0, utils_1.formatG2Point)([
                    [proofData.Bs.X.A0, proofData.Bs.X.A1],
                    [proofData.Bs.Y.A0, proofData.Bs.Y.A1],
                ], endianess, curve),
                c: (0, utils_1.formatG1Point)([proofData.Krs.X, proofData.Krs.Y], endianess),
            },
        };
    }
    catch (error) {
        const proofSnippet = JSON.stringify(proof).slice(0, 50);
        throw new Error(`Failed to format ${options.proofType} proof: ${error instanceof Error ? error.message : 'Unknown error'}. Proof snippet: "${proofSnippet}..."`);
    }
};
exports.formatProof = formatProof;
/**
 * Formats verification key for Groth16 zk-SNARK proof using Gnark.
 *
 * @param {Groth16VerificationKeyInput} vk - Raw verification key data.
 * @param {ProofOptions} options - Proof options containing curve information.
 * @returns {Groth16VerificationKey} - Formatted verification key.
 */
const formatVk = (vk, options) => {
    try {
        if (typeof vk !== 'object' || vk === null) {
            throw new Error('Invalid verification key format: Expected an object.');
        }
        const vkData = (0, utils_1.unstringifyBigInts)(vk);
        const curve = (0, utils_1.extractCurve)(options.curve);
        const endianess = (0, utils_1.getEndianess)(curve);
        return {
            curve,
            alpha_g1: (0, utils_1.formatG1Point)([vkData.G1.Alpha.X, vkData.G1.Alpha.Y], endianess),
            beta_g2: (0, utils_1.formatG2Point)([
                [vkData.G2.Beta.X.A0, vkData.G2.Beta.X.A1],
                [vkData.G2.Beta.Y.A0, vkData.G2.Beta.Y.A1],
            ], endianess, curve),
            gamma_g2: (0, utils_1.formatG2Point)([
                [vkData.G2.Gamma.X.A0, vkData.G2.Gamma.X.A1],
                [vkData.G2.Gamma.Y.A0, vkData.G2.Gamma.Y.A1],
            ], endianess, curve),
            delta_g2: (0, utils_1.formatG2Point)([
                [vkData.G2.Delta.X.A0, vkData.G2.Delta.X.A1],
                [vkData.G2.Delta.Y.A0, vkData.G2.Delta.Y.A1],
            ], endianess, curve),
            gamma_abc_g1: vkData.G1.K.map((point) => (0, utils_1.formatG1Point)([point.X, point.Y], endianess)),
        };
    }
    catch (error) {
        const vkSnippet = JSON.stringify(vk).slice(0, 50);
        throw new Error(`Failed to format ${options.proofType} verification key: ${error instanceof Error ? error.message : 'Unknown error'}. VK snippet: "${vkSnippet}..."`);
    }
};
exports.formatVk = formatVk;
/**
 * Formats an array of public signals.
 *
 * @param {string[]} pubs - Array of public signals.
 * @returns {string[]} - Formatted public signals.
 */
const formatPubs = (pubs) => {
    return (0, utils_1.formatPublicSignals)(pubs);
};
exports.formatPubs = formatPubs;
//# sourceMappingURL=index.js.map